 c#에서 선택할 수 있는 actor 구현체들중 akka.net, orleans, proto.actor들과 이 구현모델을 비교해서 설명하고, 이들 라이브러리와의 차별점, 강점들을 위주로 부각하고 싶어. 내가 생각한 차별점은 아래에 나열할게.
  - message를 던지지 않고 lambda를 던지기 때문에 보일러플레이트가 적음
  - C# lambda는 클로저에 암묵적으로 변수가 끼어들어가기 쉽고, 그렇게 참조가 생기면 gc에서 수거하지 않기 때문에 IActor<T>의 경우 self 참조를 별도 제공.
  - 디버깅을 용이하게 하기 위해 Post 호출 위치를 tag로 제공
  - 객체 수명관리에 각별히 신경쓴 점. 게임오브젝트의 소멸시점 (캐릭터의 사망, 땅떨 아이템의 루팅 후 소멸 등)이 명확해야 하기에 IScopedActor 계열 구현에서의 여러가지 수명 관리. weakpost, weakmessage등
  - c++ std::shared_ptr, std::weak_ptr과의 차이. c#은 언어차원에서 참조와 객체수명을 알아서 관리하지만, 그것이 논리적 게임 객체와 꼭 맞지 않다. shared_ptr이 모든 참조를 푸는 순간 객체는 소멸하고 소멸자를 사용할 수 있지만, c#은 모든 참조가 풀려도 gc가 돌기전엔
  객체가 소멸하지 않으며, destructor나 Dispose함수도 C++의 소멸자와 꼭 맞는 패턴으로 사용할 수 없다. 이를 위한 대체제로 OnZeroReferenceAsync() 구현.
  - 작고 간결하면서 빠르다. 내부에 lock(스레드 대기)이 없다. actor 구현 자체가 리소스를 먹지 않으므로 큰 트래픽을 다루기 유리하다.
  - 위치투명성은 버린다. 프로세스를 넘어서는 scope의 처리를 커버하지 않는 대신 코드베이스를 작고 단순하게 유지한다.

   한가지 더 추가해줘. c#은 단일상속받 제공하기 때문에, 임의 대상을 Actor로 만들때 상속을 받지 않아도 되도록 인터페이스와 Implementor를 이용한 점. 상태를 못가지는 interface대신 모든 상태는 implementor에 두고, 외부에서는 extention method를 이용해 상속과 다름없는
  사용성을 가져간다.

 용어를 조금 수정할게. 위치투명성을 포기했다기보단 분산시스템을 기본 클래스 단계에서 지원하는 것을  포기한거라고 해야겠다. 대신 직접 네트워크 로직과 함께 코드를 작성해서 인터서버간 처리를 내부객체간 접근과 동일하게 async로 할 수 있고. 분산시스템 자체지원을 포기한
  대신 가벼움과 간결함을 선택한거야. 내가 잘 말한거지? 이 말을 참고해서 단어선택 혼동이 없도록 잘 정리 부탁해. 글을 작성해줘.
  

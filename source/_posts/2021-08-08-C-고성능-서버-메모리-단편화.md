---
title: C# 고성능 서버 - 메모리 단편화
date: 2021-08-08 21:44:20
tags: [c#, 고성능, 게임서버, ArrayPool, Memory, Fragmentation]
---

{% asset_img 00.jpg %}

요즘의 닷넷 GC는 꽤나 쓸만하게 발전하여, 웬만한 경우는 프로그래머가 메모리 관리를 굳이 신경쓰지 않고 코딩할 수 있게 도와준다. 그리고 그것이 C++ 대신 C#을 선택하는 큰 이유이기도 하다. 하지만 게임서버에서 성능에 조금 욕심을 내고자 할 때, 짧은 순간 대량의 TPS를 내는 네트워크 IO를 구현하고자 할 때는 어느정도 메모리 운용에 대한 이해가 필요하다.

서버 네트워크 엔진 구현시 접할 수 있는 메모리 단편화 현상에 대해서 정리해본다. 

<!-- more -->

## 기본 용어 및 개념 정리

#### SOH / LOH / POH
가장 먼저 `관리 힙(managed heap)`의 구분부터 이야기 해야한다. 관리힙은 사용 메모리의 크기와 용도 등에 따라 `SOH`, `LOH`, `POH`로 나뉜다.

* `SOH`는 Small Object Heap으로, 85kb보다 작은 사이즈의 메모리를 할당한다. 경우에 따라 차이는 있겠지만 대다수의 객체들이 주로 할당/해제 되는 공간이다. 
* `LOH`는 Large Object Heap으로, 85kb보다 큰 사이즈의 메모리를 할당한다. 
* `POH`는 Pinned Object Heap으로, pinning할 메모리를 위해 .Net 5부터 새롭게 추가된 공간이다.

POH는 사실 다짜고자 단편화의 솔루션에 가까운 존재이긴하나.. 분류상 미리 언급되었다. 이후에 다시 추가적으로 설명한다.

#### Compression
`SOH`의 메모리는 객체가 얼마나 오래 살았느냐에 따라 0세대부터 2세대까지 세대를 구분한다. GC가 한 번 발생하면 참조가 없는(=사용이 끝난) 메모리는 해제되고, 여전히 사용중인 메모리는 다음 세대로 승격한다. 이 때 살아남은 메모리들은 `압축(Compression)`의 과정을 거친다. 압축이란 메모리 단편화를 줄이기 위해, 살아남은 메모리들을 사이사이 공백이 없도록 한 공간으로 몰아서 재배치하는 동작을 말한다. 실제로 관리 힙 내부에서 객체들은 세대별로 모여 있기 때문에, 메모리 해제 및 승격을 거친 후에는 세대별 구획에 맞춰 메모리를 재정렬하는 과정은 불가피한 필수 절차다.
{% asset_img 01.png %}

오.. 이거 처음에 너무 신기했다. C++로 만드는 서버는 불가능한 동작이다. 프로그래머가 직접 제어하는 user mode의 로직에서도 무수히 많은 포인터들이 가상 메모리 공간상의 주소값을 바로 가르키고 있기 때문이다. C#의 참조타입 변수들도 실상은 포인터에 가깝지만 직접적으로 메모리 주소를 노출하고 있지는 않기 때문에, 메모리 압축이 발생하면 매니지드 레벨보다 더 아래의 로우레벨에서 새로운 주소값으로 모든 참조를 갱신해 주기 때문에 가능한 동작이다. 

#### Pinned Memory
메모리 압축이 이미 할당된 모든 객체들의 위치를 제멋대로 바꿀 수 있는 것은 아니며, 모든 법칙에 항상 예외는 존재한다. 매니지드 레벨은 결국 네이티브 레벨 위에서 돈다. 네이티브 영역과의 상호참조가 필요한 매니지드 메모리는 함부로 값을 옮겨다닐 수가 없다. 위에서 언급한 `C++로 만든 네이티브 서버`에서는 불가능하다고 말한 이유와 같다. 
네이티브 영역에서 매니지드 영역의 메모리를 참조할 일이 있을 때는 메모리를 복사(copying)하거나 고정(pinning)한다. 매니지드 메모리가 다른 주소로 이동하지 않도록 고정하는 것을 `Memory Pinning`, 이렇게 고정된 메모리를 `Pinned Memory`라고 부른다.
{% asset_img 02.gif %}

데이터 마샬링(매니지트/네이티브 상호통신)의 입장에서 보면 pinning은 불필요한 복사를 줄여주는 효율적인 동작이다. 하지만 가비지 컬렉터 입장에서 보자면 엄청난 방해꾼임이 분명하다. pinned memory 는 gc의 압축 동작을 방해하기 때문이다

> 고정(Pinning)은 데이터를 현재 메모리 위치상에 임시로 잠그기 때문에, CLR의 가비지 수집기에 의한 재배치를 막아줍니다.
> Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector. 
> (https://docs.microsoft.com/en-us/dotnet/framework/interop/copying-and-pinning)

> 고정(pinning)은 메모리의 단편화를 유발하고, 일반적으로 객체 압축 과정을 복잡하게 만들기 때문에 자체적인 비용 부담을 가집니다.
> Pinning has its own costs, because it introduces fragmentation (and in general complicates object compaction a lot). 
> (https://tooslowexception.com/pinned-object-heap-in-net-5/)

## 단편화 발생의 원인

게임서버의 메모리 단편화는 어디서 발생하는가. 
핵심부터 말하자면 소켓의 send / receive에 걸어주는 바이트 배열 버퍼가 pinning되기 때문에, 가비지 컬렉터의 압축과정을 많이 방해하게 되면서 메모리 단편화를 유발시킨다. 이 부분이 메모리 단편화의 가장 주된 요인이다. 하지만 TPS가 높은 고성능 게임서버를 만들려고 한다면.. 소켓 IO의 수가 많아짐에 따라 네트워크 버퍼의 개수와 사용빈도도 당연히 많아질 수밖에 없다. 때문에 대량의 네트워크 통신을 견딜 수 있도록 만드려면 네트워크 버퍼를 어떻게 운용할 것인지가 중요하다.

DB와 통신하기 위한 DBMS 클라이언트도 많은 수의 pinned handle을 만들어낸다. 현재 프로젝트에서는 `System.Data.SqlClient` 네임스페이스 하위의 클래스들을 사용해 Azure SQL과 통신하고 있는데, 생각해보면 db client도 DBMS에 연결되어 쿼리와 데이터를 던지고 받는 통신모듈이니 당연한 이야기다. 

서버 엔진 프레임워크 작업을 하면서 객체를 약참조 하기 위해 `System.WeakReference`을 많이 사용했는데, 여기서도 메모리 pinning이 발생한다. 아이러니한 일이다. 참조하는 대상이 쉽게 메모리 해제될 수 있도록 약참조하는 기능을 하지만, 다른쪽으로는 고정된 메모리를 만들어내서 메모리 단편화를 가속시킨다. `WeakReference`가 GC를 방해한다는 사실을 처음엔 몰랐다가, 실제 서비스에서 메모리 문제들을 겪으면서 windbg에서 힙 공간을 들여다 보던 중 알게 되었다. 지금은 거의다 드러내고, 약참조 사용이 불가피한 구현에만 일부 남아있다.

## 단편화 해결 솔루션

상술한 원인들 중 가장 명백한 원인제공자는 네트워크 버퍼다. 빈번히 쓰이는 네트워크 버퍼를 잘 운용하는 것이 단편화 해결의 핵심이다.

네트워크 버퍼용 `byte[]` 객체를 `ArrayPool<T>` 를 이용해 풀링하는 것은 그다지 개선의 효과가 없었다. `ArrayPool<T>`클래스는 효율적으로 객체의 할당과 해제 빈도를 완화하고 관리해주지만, 어쨌거나 `SOH` 공간에서 할당을 받기 때문에, 이글에서 말하고 있는 pinning 이나 fragmentation과는 크게 상관이 없다. 

메모리 압축은 SOH에서만 발생한다. 따라서 pinned memory가 GC성능 저하 및 메모리 단편화를 일으키는 것도 SOH에만 해당하는 이야기다. 그러니 네트워크 버퍼는 그냥 SOH에 잡지 않는 것이 좋겠다.

#### 솔루션 1. 네트워크 버퍼를 POH에 할당하기

MS 형들도 역시 성능상에서 이런 문제가 있음을 분명히 알고 있다. `.NET 5`부터는 고정된 메모리로 사용할 객체를 할당하는 별도의 힙 공간인 `POH`가 새로 생겼다. 현재 회사에서 서비스중인 게임 서버는 .NET Framework 4.7.2로 개발을 시작해서 현재 .NET Core 3.1을 사용중이어서, 아직 실제 서비스에 `POH`를 사용해보지는 못했다. [이 글](https://tooslowexception.com/pinned-object-heap-in-net-5/)에서 `POH`에 대한 기본적인 설명을 확인할 수 있다. 개발에 사용하는 프레임워크가 `.NET 5` 이상이라면 `POH`의 도입을 고려해 볼 만 하다.

#### 솔루션 2. 네트워크 버퍼를 LOH에 할당하기
 
LOH의 객체들은 메모리 압축으로 인한 재배치를 진행하지 않으며, 세대가 구분되어있지도 않다. 2세대 GC가 수행될 때만 LOH상의 메모리 해제가 진행되므로, 모두 2세대 객체라고 부르기도 한다. 세대 구분이 없으니 메모리 공간상에서 꼭 재배치 해주어야 할 필요도 없다. 
LOH의 객체는 가상 메모리 주소공간에 한 번 할당되면 위치가 이동되지 않는다(설정을 바꾸면 LOH도 압축을 할 수는 있다). 이런 특성은 오히려 단편화를 유발할 수도 있고, 감소시킬 수도 있다. 빈번하게 할당 해제를 반복하는 메모리라면 LOH에 할당했을 때 괜히 공간상에 구멍만 많이 뚫어놓는 꼴이 되면서 더 안좋은 결과를 보일지도 모른다. 
우리는 게임 런칭 전 부하테스트를 진행하면서 메모리 단편화 이슈를 겪던 중, [이 글의 해결 사례](https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation)를 보고나서 네트워크 버퍼 할당을 LOH로 옮겨 보기로 했다.

네트워크 버퍼를 LOH에서 할당받은 이후 메모리 단편화 문제는 말끔해 해결되었다. 링크한 블로그 포스팅에서 소개한 것처럼 충분히 큰 버퍼를 LOH에 잡아두고, `ArraySegment<byte>`로 나누어 풀링하고 사용하는 방식이다. C++에서 고전적으로 메모리 풀링을 구현할 때 접근하는 방식과 유사하다. 

C++에서 `byte[]`는 넓은 의미에서 보면 가르키는 대상이 고정인 포인터 (`byte * const`)와 유사하고 - 물론 문법상 둘은 다르지만 - 커다란 바이트 배열을 여러개의 작은 배열로 쪼개어 다시 `byte[]`로 표현하는 것이 크게 문제될 것이 없다. 하지만 C#에서의 `byte[]`는 하나의 독립된 참조형 객체이므로 C++과는 차이가 있다. 큰 배열의 단위조각을 표현할 때 `ArraySegment<byte>`를 사용해야 하는 이유다.

LOH에서 버퍼용 메모리를 할당 및 관리하는 구현체는 다음 포스팅을 통해 좀 더 자세히 설명한다. 

어차피 게임서버가 실행중인 동안 네트워크 버퍼는 지속적으로 필요한 공간이므로, 서버가 처음 뜰 때 LOH에 큼직한 청크를 할당한다. 한 번 할당한 청크 메모리는 해제하지 않는다. 실행 도중 접속자가 몰려 네트워크 버퍼가 더 필요한 경우는 추가로 청크를 할당하기만 한다. 이 청크를 다시 여러 개의 `ArraySegment<byte>`로 나누어 풀링하도록 만든다. `ArraySegment<byte>`를 소켓에 바로 연결하면 통신 가능한 데이터 사이즈가 고정되는 문제 등이 있으므로, `System.IO.Pipeline`처럼 단위버퍼를 연속된 메모리 스트림처럼 취급해주는 구현체를 만들어 이를 사용했다. (이전 포스팅 [C# 고성능 서버 - System.IO.Pipeline 도입 후기](https://leafbird.github.io/devnote/2020/12/27/C-고성능-서버-System-IO-Pipeline-도입-후기/) 참고)

우리는 위와 같이 LOH에서 네트워크 버퍼용 바이트 배열을 풀링하는 구현체를 `LohPool`이라는 이름으로 구현했다. 서버에는 명시적인 lock을 하나도 사용하지 않는 lock-free 아키텍쳐를 사용하였으므로, LohPool 구현에도 명시적인 lock은 없다. 버퍼의 수요가 증가할 것으로 예상될 때 가장 먼저 ownership을 잡는 스레드가 추가 청크를 할당하는 역할을 수행한다.

## 참고자료

* https://prodotnetmemory.com/data/netmemoryposter.pdf
* https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation
* https://tooslowexception.com/pinned-object-heap-in-net-5/
* https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.arraypool-1?view=net-5.0
* https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.0
* https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance#Pinned
* https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation
* https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream
---
title: C# 고성능 서버 - Thread Local Storage
date: 2021-01-01 16:00:49
tags: [c#, 고성능, 게임서버, Thread, AsyncLocal, TLS]
---

프로그래밍에서 각 스레드별로 고유한 상태를 설정할 수 있는 공간을 [Thread Local Storage](https://en.wikipedia.org/wiki/Thread-local_storage) (이하 TLS. transport layer security 아님) 라고 한다. C++에서는 `__declspec(thread)` 키워드를 이용해서 tls 변수를 선언할 수 있다. 

C#에도 `ThreadLocal<T>` 라는 클래스를 이용해 TLS를 사용할 수 있지만, 막상 실제로 사용해보면 C++에서 했던 것처럼 쉽게 해결되지 않을것이다. C# 5.0부터 들어온 async / await 문법을 이용해 비동기 프로그래밍을 구현했다면, await 대기 시점 이전과 이후에 스레드가 달라지기 때문이다. 

이를 해결하는 방법과 주의해야 할 사항을 정리해본다. 

<!--more-->

## async / await 을 절대 가볍게 접근하면 안된다

주제와 약간 벗어날 수 있지만 서두에 미리 한 번 짚고 넘어갈 부분이 있다. **절대로 async / await를 이용한 비동기 프로그래밍을 만만하게 보아서는 안된다**는 것이다.

나도 제일 처음 이 문법을 보고는 아주 쉽고 간단한 기능이라고 착각했었다. 개인적으로는 비동기 메서드를 적용하고난 후의 코드 모양새가 동기 프로그래밍과 너무 비슷해져 버리는 점이 착각을 유발하는 큰 원인이라고 생각한다 (MS: 얘는 뭐 좋게 해줘도 불만이 많네..) 

이전에 DB 쿼리나 네트워크 통신같은 IO 작업 등에서 비동기로 받는 결과값을 처리하기 위해서는 하나의 동일한 주제(single concern)를 위한 로직임에도 불구하고 비동기 요청 이전과 이후의 코드가 분절되어야 했다. 이를테면 비동기 요청 이전의 전처리와 응답 후의 처리를 서로 다른 메서드로 나누어서 짜야 했다는 뜻이다. 코드의 가독성에 대해 고민을 좀 해봤던 개발자라면 람다를 써서 어떻게든 읽기 좋고 관리하기 좋도록 애써 보았을 수도 있으나, 이들은 수행 시간의 분절과 함께 코드상에서도 명백한 분절을 피할 수 없었다. 

비동기 메서드의 등장으로 이런 상황은 옛날 이야기가 되었다. 안간힘을 써보아도 완전하게 붙이기 힘들었던 분절된 코드들은 이제 온전하게 하나의 async 함수 안에 구현할 수 있게 되었다. 나중에 코드를 읽을 때에도 (신경써서 읽지 않는다면) 어디가 동기 처리이고, 어디가 비동기 처리인지도 잘 모르게 술술 읽어내려가게 되었다. 좋게 해석하자면 비즈니스 로직 개발자가 좀 더 로직에만 집중 할 수 있는 환경이 되었다.

이것은 호수에 떠있는 우아한 백조와 같다. 일단 겉으로 보기에는 아주 심플하게 비동기 코드를 표현해 내었으나, 조금만 내려가보면 - 당장 IL 코드까지만 가보더라도 - 이들 로직 자체의 여전한 분절, 그에 따른 실행 시점 시간차 및 실행 환경상의 차이 등은 당연하게 존재하고 있기 때문이다. MS는 실제로 프로그래머들이 하부의 복잡한 메커니즘을 잘 모르더라도 쉽고 편하게 비동기 로직을 구현할 수 있는 유토피아를 꿈꾸었을지 모르나, 간단한 툴 한두개 짜는거면 몰라도... C#이란 언어로 고성능 서버를 만들겠다고 한다면, 이에 대한 충분한 이해가 없이는 런타임에서 예상못한 오작동을 피할 수 없을 것이다.

이후 글에서 언급할 내용도 비동기 함수의 실행 흐름 및 시점의 차이와 관련되어 있으므로, 비동기 메서드에 대한 어느정도의 이해가 필요하다.



## TLS를 용도에 따라 stateless / statefull로 나누자



## AsyncLocal 소개 및 한계



## 해결방안 : AsyncLocal 뒷정리 해주기



## 마치면서
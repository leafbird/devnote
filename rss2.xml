<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>leafbird/devnote</title>
    <link>http://leafbird.github.io/devnote/</link>
    
    <atom:link href="http://leafbird.github.io/devnote/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 18 Feb 2026 06:41:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>openclaw에 PR없이 버그제보만 올린 썰 푼다</title>
      <link>http://leafbird.github.io/devnote/2026/02/18/openclaw%EC%97%90-PR%EC%97%86%EC%9D%B4-%EB%B2%84%EA%B7%B8%EC%A0%9C%EB%B3%B4%EB%A7%8C-%EC%98%AC%EB%A6%B0-%EC%8D%B0-%ED%91%BC%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2026/02/18/openclaw%EC%97%90-PR%EC%97%86%EC%9D%B4-%EB%B2%84%EA%B7%B8%EC%A0%9C%EB%B3%B4%EB%A7%8C-%EC%98%AC%EB%A6%B0-%EC%8D%B0-%ED%91%BC%EB%8B%A4/</guid>
      <pubDate>Wed, 18 Feb 2026 05:24:45 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2026/02/18/openclaw%EC%97%90-PR%EC%97%86%EC%9D%B4-%EB%B2%84%EA%B7%B8%EC%A0%9C%EB%B3%B4%EB%A7%8C-%EC%98%AC%EB%A6%B0-%EC%8D%B0-%ED%91%BC%EB%8B%A4/issue_up.webp&quot; class=&quot;&quot;&gt;

&lt;p&gt;openclaw을 집에서 띄워 쓰고 있다가 밀린 업데이트를 여러 개 받았는데, 조금 있으니 대시보드가 제대로 동작하지 않았다. 권한이 없다는 오류가 찍히면서 API 호출이 줄줄이 실패하는 상황.&lt;/p&gt;
&lt;p&gt;설정을 잘못 건드렸나 싶어서 이것저것 확인해봤는데, 내 설정 문제는 아닌 것 같았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2026/02/18/openclaw%EC%97%90-PR%EC%97%86%EC%9D%B4-%EB%B2%84%EA%B7%B8%EC%A0%9C%EB%B3%B4%EB%A7%8C-%EC%98%AC%EB%A6%B0-%EC%8D%B0-%ED%91%BC%EB%8B%A4/issue_up.webp" class=""><p>openclaw을 집에서 띄워 쓰고 있다가 밀린 업데이트를 여러 개 받았는데, 조금 있으니 대시보드가 제대로 동작하지 않았다. 권한이 없다는 오류가 찍히면서 API 호출이 줄줄이 실패하는 상황.</p><p>설정을 잘못 건드렸나 싶어서 이것저것 확인해봤는데, 내 설정 문제는 아닌 것 같았다.</p><span id="more"></span><h3 id="AI와-함께-원인-추적"><a href="#AI와-함께-원인-추적" class="headerlink" title="AI와 함께 원인 추적"></a>AI와 함께 원인 추적</h3><p>터미널에서 AI한테 상황을 설명하고 같이 코드를 뒤졌다. 원인은 금방 찾았다. 대시보드를 처리하는 js 코드 중에서 <code>dangerouslyDisableDeviceAuth</code>를 켜면 device가 null이 되는데, 이때 scopes를 무조건 빈 배열로 날려버리는 코드가 있었다. 그러니 당연히 이후 호출은 전부 권한 없음으로 떨어지는 거였다.</p><p>조건문 한 줄 고치면 되는 문제라, 로컬에서 패치해서 정상 동작하는 것까지 확인했다.</p><h3 id="PR을-보낼까요"><a href="#PR을-보낼까요" class="headerlink" title="PR을 보낼까요?"></a>PR을 보낼까요?</h3><blockquote><p>이제 정상적으로 동작합니다. PR 만들어서 보낼까요?</p></blockquote><p>정상 동작이 확인되자마자, AI가 먼저 물었다.<br><code>yes</code> 라고 대답 한 번만 하면 커밋 메시지 작성부터 PR 생성까지 알아서 해줄 기세였다. 근데… 뭔가 마음에 걸렸다.</p><p>원인을 찾은 것도, 수정 방향을 잡은 것도 AI와 함께한 작업이었다. 물론 문제 상황을 설명하고 방향을 잡아준 건 나지만, 코드를 직접 읽고 파고든 건 솔직히 AI 비중이 컸다. 이걸 내 이름으로 PR을 보내는 게 맞나? 하는 생각이 들었다.</p><p>그래서 PR 대신, 수정 방향까지 상세하게 적은 이슈만 등록해달라고 했다. 실제로 몇 시간 안에 메인테이너가 수정해서 바로 반영해줬다.</p><img src="/devnote/2026/02/18/openclaw%EC%97%90-PR%EC%97%86%EC%9D%B4-%EB%B2%84%EA%B7%B8%EC%A0%9C%EB%B3%B4%EB%A7%8C-%EC%98%AC%EB%A6%B0-%EC%8D%B0-%ED%91%BC%EB%8B%A4/patch_note.png" class=""><h3 id="1년-반-만에-뒤집어진-세상"><a href="#1년-반-만에-뒤집어진-세상" class="headerlink" title="1년 반 만에 뒤집어진 세상"></a>1년 반 만에 뒤집어진 세상</h3><p>24년도에 hexo에 PR을 보냈을 때가 떠올랐다. 그때도 hexo 엔진을 직접 쓰다가 발견한 버그였는데, 상황이 꽤 달랐다.</p><ul><li><a href="/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/" title="hexo에 PR을 보냈습니다">hexo에 PR을 보냈습니다</a></li></ul><p>그 땐 잘 모르는 TypeScript 환경에서 버그 찾아서 고쳐보겠다고 혼자 끙끙대면서 코드를 들여다보았다. 익숙하지 않은 환경에서 코드를 고치다보니 단위 테스트가 자꾸 실패해서 몇 번이고 재도전 해가며 다시 돌렸다. lint 규칙에 맞추느라 코드 스타일도 여러 차례 수정했다. 그 과정 전부를 내가 직접 해냈고, 그래서 PR을 보내서 머지 됐을때 정말 뿌듯했었던 기억이 난다. node가 익숙한 작업자에겐 별 것 아닌 수정일 수도 있지만.. 나한테는 뭐랄까. 갑자기 멕시코 시내 한복판에 혼자 떨어졌지만 당당하게 혼자 힘으로 타코를 사먹은 기분이랄까.</p><p>그랬던 게 불과 1년 반 전인데, 이번에는 분위기가 많이 다르다. 나는 거의 입만 털었고, 실제 코드를 확인하고 수정한 것은 모두 ai가 해주었다. <strong>이건 내가 고친 버그가 맞는걸까.</strong></p><h3 id="앞으로는"><a href="#앞으로는" class="headerlink" title="앞으로는"></a>앞으로는</h3><p>이번엔 왠지 찜찜한 마음에 원인을 상세히 적어 이슈로만 올려달라고 ai에게 대답했고. 이슈를 올리는 것 마저도 내가 아니라 ai가 모두 처리해줬다. </p><p>이상한 기분. 전엔 없었던 상황… 처음 느끼는 느낌. </p><p>이미 지금도 ai가 던지는 PR이 너무 많아 오픈소스 메인테이너의 고충이 커진다는 뉴스가 들려온다. 앞으로는 AI와 함께 작업한 PR이 훨씬 자연스러워지지 않을까 싶다. 이미 많은 사람들이 그렇게 하고 있겠지. 그 사람들은 AI에게 PR을 던지라고 대답할 때, 어떤 기분이었을까?</p><p>정말 조금만 더 지나도 내가 느낀 이 찜찜함도 시대에 뒤쳐지는 옛날 감성이 되겠지. 아직은 그 경계 어딘가에 서 있는 기분이다.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/contributor/">contributor</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/ai/">ai</category>
      
      
      <comments>http://leafbird.github.io/devnote/2026/02/18/openclaw%EC%97%90-PR%EC%97%86%EC%9D%B4-%EB%B2%84%EA%B7%B8%EC%A0%9C%EB%B3%B4%EB%A7%8C-%EC%98%AC%EB%A6%B0-%EC%8D%B0-%ED%91%BC%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Implementing Lightweight Actor in C# (1) - 기본 구조와 스케줄링</title>
      <link>http://leafbird.github.io/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/</link>
      <guid>http://leafbird.github.io/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/</guid>
      <pubDate>Thu, 29 Jan 2026 01:00:00 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/header.png&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;들어가며&quot;&gt;&lt;a href=&quot;#들어가며&quot; class=&quot;headerlink&quot; title=&quot;들어가며&quot;&gt;&lt;/a&gt;들어가며&lt;/h2&gt;&lt;p&gt;지난 글(&lt;a href=&quot;/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/&quot; title=&quot;Applying the Actor Pattern to MMO Servers&quot;&gt;링크&lt;/a&gt;)에서는 Actor 패턴을 MMO 서버에 적용할 때의 두 가지 접근 방식 — Zone 단위의 Coarse-grained 방식과 Object 단위의 Fine-grained 방식 — 을 비교해 보았습니다.&lt;/p&gt;
&lt;p&gt;이제 드디어 실제 코드를 살펴볼 차례입니다. 이번 글에서는 현재 프로젝트에서 사용 중인 &lt;strong&gt;경량 Actor 구현체&lt;/strong&gt;의 핵심 구조를 소개합니다. 주로 스레드가 어떻게 운용되는지, 그리고 c#의 비동기 메서드(async&amp;#x2F;await)로 인해 끊겼다 이어지는 스레드 흐름을 어떻게 다루는지에 대해 적어보겠습니다. 다음 주제들을 하나씩 다뤄볼게요. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Symmetric 스레드 모델&lt;/strong&gt;: 역할이 고정된 스레드가 아닌, 모든 스레드가 모든 일을 처리하는 방식&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 큐와 스케줄링&lt;/strong&gt;: &lt;code&gt;JobDispatcher&lt;/code&gt;를 중심으로 한 작업 분배&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Starvation 방지&lt;/strong&gt;: &lt;code&gt;readyQueue&lt;/code&gt;를 통한 공정한 처리&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동기&amp;#x2F;비동기 메시지 분리&lt;/strong&gt;: &lt;code&gt;await&lt;/code&gt; 키워드와 함께 자연스럽게 동작하는 구조&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/header.png" class=""><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>지난 글(<a href="/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/" title="Applying the Actor Pattern to MMO Servers">링크</a>)에서는 Actor 패턴을 MMO 서버에 적용할 때의 두 가지 접근 방식 — Zone 단위의 Coarse-grained 방식과 Object 단위의 Fine-grained 방식 — 을 비교해 보았습니다.</p><p>이제 드디어 실제 코드를 살펴볼 차례입니다. 이번 글에서는 현재 프로젝트에서 사용 중인 <strong>경량 Actor 구현체</strong>의 핵심 구조를 소개합니다. 주로 스레드가 어떻게 운용되는지, 그리고 c#의 비동기 메서드(async&#x2F;await)로 인해 끊겼다 이어지는 스레드 흐름을 어떻게 다루는지에 대해 적어보겠습니다. 다음 주제들을 하나씩 다뤄볼게요. </p><ul><li><strong>Symmetric 스레드 모델</strong>: 역할이 고정된 스레드가 아닌, 모든 스레드가 모든 일을 처리하는 방식</li><li><strong>메시지 큐와 스케줄링</strong>: <code>JobDispatcher</code>를 중심으로 한 작업 분배</li><li><strong>Starvation 방지</strong>: <code>readyQueue</code>를 통한 공정한 처리</li><li><strong>동기&#x2F;비동기 메시지 분리</strong>: <code>await</code> 키워드와 함께 자연스럽게 동작하는 구조</li></ul><span id="more"></span><hr><h2 id="왜-직접-만드는가"><a href="#왜-직접-만드는가" class="headerlink" title="왜 직접 만드는가?"></a>왜 직접 만드는가?</h2><p>본격적인 설명에 앞서, 한 가지 의문을 먼저 다루어 보겠습니다.</p><blockquote><p><strong>C#에는 Akka.NET, Orleans 같은 검증된 Actor 프레임워크가 있는데, 왜 직접 만들어 쓰나요?</strong></p></blockquote><p>분명 바퀴를 다시 발명하지 말라고 했는데. 게임 만들기도 바쁜 와중에 Actor까지 직접 구현을 하는 걸까요.</p><p><code>게임 개발</code>이라는 이름으로 모든 게임 프로젝트를 통틀어 이야기할 수는 없습니다. 모든 상황에는 필요와 목적이 다 다를테니까요.  하지만 기존의 훌륭한 프레임워크들은 적어도 제가 필요한 용도로 활용하기에는 조금 <strong>목적이 달랐기 때문</strong>입니다.</p><h3 id="분산-시스템이-목표가-아니다"><a href="#분산-시스템이-목표가-아니다" class="headerlink" title="분산 시스템이 목표가 아니다"></a>분산 시스템이 목표가 아니다</h3><p>Akka.NET이나 Microsoft Orleans는 많은 곳에서 사용되는 검증된 범용적인 Actor 프레임워크입니다. 다양한 프로젝트에 사용할 수 있도록 말 그대로의 범용성(generality)을 중시하는 프레임워크면서, 다분히 <strong>네트워크를 넘어 여러 노드에 걸쳐 동작하는 분산 Actor 시스템</strong>을 목표로 합니다. 클러스터 관리, 원격 메시징, 장애 복구, 퍼시스턴스 등 엔터프라이즈급 기능들을 제공합니다.</p><p>하지만 제가 필요한 것은 그런 게 아닙니다. <strong>단일 프로세스 내에서 게임 오브젝트들 간의 동시성을 관리</strong>하는 것이 목표입니다. 네트워크를 넘어가는 분산 처리도 물론 필요한 부분이 있습니다만, 그건 제가 별도의 스택으로 만들어 올리는 것이 모듈화 면에서도 더 낫다고 판단했습니다.</p><p>이런 상황에서 분산 시스템용 프레임워크를 사용한다면 뭐랄까.. 체형보다 좀 큰 사이즈의 헐거운 옷을 입는 느낌이 듭니다.</p><ul><li>필요 없는 기능들이 오버헤드로 작용</li><li>프레임워크의 추상화들은 학습 곡선을 높임</li><li>디버깅과 성능 튜닝이 어려워짐</li></ul><h3 id="검증된-구현에서-출발하기"><a href="#검증된-구현에서-출발하기" class="headerlink" title="검증된 구현에서 출발하기"></a>검증된 구현에서 출발하기</h3><p>저는 운이 좋게도 이전의 몇몇 프로젝트들에서 출중하신 고수 동료님들이 계신 좋은 환경에서 자체 구현한 lock-free Actor 기반으로 게임을 만들어본 경험이 있었습니다. 다행히 지금의 아키텍처가 어느 정도 익숙하고 부담이 없는 편이었습니다. </p><p>특히 github에 공개된 <a href="https://github.com/zeliard/Dispatcher">zeliard&#x2F;Dispatcher</a> 구현은 큰 바탕이 되었습니다. 현재 사용 중인 코드는 zeliard님의 구현을 상당부분 C#으로 그대로 이식해온 단계에서 시작했다고 할 수 있어요. 본 포스팅에서 초반부에 설명할 스레드 운용 방식은 완전히 동일합니다. 좋은 자료를 공유해주시는 zeliard님 감사드립니다 _ _) </p><p>제가 필요한 기능들은 몇백 줄이면 충분히 작성할 수 있습니다. 직접 만들어둔 기반 코드는 프로젝트를 진행하여 변화해가는 필요에 따라 민첩하게 개량하기에도 용이합니다.</p><p><strong>필요한 것:</strong></p><ul><li>메시지 큐와 단일 스레드 실행 보장</li><li><code>async/await</code>와의 자연스러운 통합</li><li>가벼운 메모리 풋프린트</li><li>빠른 메시지 처리</li></ul><p><strong>필요 없는 것:</strong></p><ul><li>원격 Actor 지원</li><li>클러스터링</li><li>Actor 퍼시스턴스</li><li>복잡한 감독(Supervision) 전략</li></ul><p>몇가지 관점에서 서로간의 특징을 간단히 정리해보면 다음과 같습니다.</p><table><thead><tr><th>비교 항목</th><th>자체 구현</th><th>Akka.NET</th><th>Orleans</th></tr></thead><tbody><tr><td><strong>코드 복잡도</strong></td><td>✅ 낮음 (수백 줄)</td><td>❌ 높음</td><td>❌ 높음</td></tr><tr><td><strong>외부 의존성</strong></td><td>✅ 없음</td><td>❌ 많음</td><td>❌ 많음</td></tr><tr><td><strong>학습 곡선</strong></td><td>✅ 낮음</td><td>❌ 높음</td><td>⚠️ 중간</td></tr><tr><td><strong>분산 시스템</strong></td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>클러스터링</strong></td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>퍼시스턴스</strong></td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>적합 용도</strong></td><td>단일 서버 게임</td><td>분산 시스템</td><td>클라우드 분산</td></tr></tbody></table><hr><h2 id="고전적-스레드-모델-vs-Symmetric-모델"><a href="#고전적-스레드-모델-vs-Symmetric-모델" class="headerlink" title="고전적 스레드 모델 vs Symmetric 모델"></a>고전적 스레드 모델 vs Symmetric 모델</h2><p>코드로 들어가기 전에, 먼저 스레드 운용 방식에 대한 배경을 짚고 넘어가겠습니다.</p><h3 id="Role-based-Threading-고전적-방식"><a href="#Role-based-Threading-고전적-방식" class="headerlink" title="Role-based Threading (고전적 방식)"></a>Role-based Threading (고전적 방식)</h3><p>전통적인 게임 서버에서는 스레드에 <strong>역할(Role)</strong> 을 부여하는 방식이 흔합니다.</p><p><img src="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/thread_00.png"></p><p>이 방식은 직관적이고 이해하기 쉽습니다. 네트워크 패킷은 I&#x2F;O 스레드가, 게임 로직은 로직 스레드가, DB 쿼리는 DB 스레드가 담당합니다. 각 스레드가 자기 일만 하면 됩니다.</p><p>하지만 문제가 있습니다. <strong>부하가 불균형</strong>할 때 비효율이 발생합니다. 로직이 폭주하는 상황에서 I&#x2F;O 스레드는 놀고 있을 수 있고, 반대의 경우도 마찬가지입니다.</p><h3 id="Symmetric-Threading-Actor-방식"><a href="#Symmetric-Threading-Actor-방식" class="headerlink" title="Symmetric Threading (Actor 방식)"></a>Symmetric Threading (Actor 방식)</h3><p>Actor 모델에서는 다른 접근을 취합니다. 스레드에 역할을 부여하지 않고, <strong>모든 스레드가 모든 종류의 일을 처리</strong>합니다.</p><p><img src="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/thread_01.png"></p><p>“일을 스레드에 배정”하는 것이 아니라, “일을 큐에 넣으면 아무 스레드나 가져가서 처리”하는 방식입니다. 이렇게 하면 <strong>모든 코어를 균등하게 활용</strong>할 수 있습니다. 한쪽이 바쁠 때 놀고 있는 스레드가 없습니다.</p><p>이렇게 서로간에 affinity가 없는 워커와 잡을 어떻게 연결할 것인가.<br>누가 어떤 일을 하게 할 것인가.<br>얼마나 가볍고(lock-free) 간결하게(simplicity) 스케줄링할 것인가.</p><p>아쉽게도 전체 코드를 공개하긴 어렵지만 맥락을 이해할 수 있는 적절한 단계의 코드들과 함께 차례대로 살펴보겠습니다.</p><hr><h2 id="Actor의-핵심-JobDispatcher"><a href="#Actor의-핵심-JobDispatcher" class="headerlink" title="Actor의 핵심: JobDispatcher"></a>Actor의 핵심: JobDispatcher</h2><p>이제 실제 코드를 살펴보겠습니다. 이 Actor 구현체의 핵심은 <code>JobDispatcher</code> 클래스입니다.</p><h3 id="기본-구조"><a href="#기본-구조" class="headerlink" title="기본 구조"></a>기본 구조</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">JobDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 현재 스레드가 처리 중인 dispatcher 추적</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AsyncLocal&lt;JobDispatcher&gt; asyncLocalDispatcher = <span class="keyword">new</span> AsyncLocal&lt;JobDispatcher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 대기 중인 dispatcher들의 큐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentQueue&lt;JobDispatcher&gt; readyQueue = <span class="keyword">new</span> ConcurrentQueue&lt;JobDispatcher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이 dispatcher의 메시지 큐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentQueue&lt;IMessage&gt; jobQueue = <span class="keyword">new</span> ConcurrentQueue&lt;IMessage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 현재 대기 중인 메시지 수</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="built_in">int</span> jobCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비동기 메시지 실행 중일 때 보관</span></span><br><span class="line">    <span class="keyword">private</span> IMessage pending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>핵심 필드들을 살펴보면:</p><ul><li><strong><code>asyncLocalDispatcher</code></strong>: <code>AsyncLocal</code>을 사용하여 현재 스레드가 어떤 dispatcher를 처리 중인지 추적합니다. 이것이 “이 스레드는 지금 이 Actor의 일을 하고 있다”를 나타내는 표식입니다.</li><li><strong><code>readyQueue</code></strong>: 처리 대기 중인 dispatcher들을 담는 전역 큐입니다. Starvation을 방지하기 위해 사용합니다.</li><li><strong><code>jobQueue</code></strong>: 이 dispatcher에 쌓인 메시지들입니다. <code>ConcurrentQueue</code>를 사용하여 lock-free로 동작합니다.</li><li><strong><code>jobCount</code></strong>: 현재 큐에 있는 메시지 수입니다. <code>Interlocked</code> 연산으로 관리됩니다.</li></ul><blockquote><p><strong>Note:</strong> Concurrent Collections in C#</p><p>C#에는 <code>ConcurrentDictionary</code>, <code>ConcurrentQueue</code>, <code>ConcurrentBag</code> 등 여러 Concurrent Collection들이 기본 라이브러리로 제공됩니다. 이들은 모두 스레드 안전성을 보장하지만, 모든 컬렉션이 lock-free로 만들어진 것은 아닙니다. 대표적으로 <code>ConcurrentDictionary</code>는 멀티스레드 환경에 사용하기 아주편리한 api를 갖고 있으나, 내부적으로 잠금을 사용하며 상대적으로 무겁습니다.<br>반면 <code>ConcurrentQueue</code>는 내부 잠금 없이 동작하여 가볍습니다. C++의 경우 MPSC(Multi-Producer Single-Consumer) Queue를 직접 구현하여 사용했었지만, C#의 <code>ConcurrentQueue</code>는 충분히 대체 가능한 수준의 성능을 제공합니다.</p><ul><li>C++ MPSC Queue 는 <a href="https://github.com/zeliard/Dispatcher">zeliard&#x2F;Dispatcher</a> 저장소에 참고할 만한 코드가 있습니다.</li></ul></blockquote><h3 id="Post-메시지-전송"><a href="#Post-메시지-전송" class="headerlink" title="Post() - 메시지 전송"></a>Post() - 메시지 전송</h3><p>Actor에게 메시지를 보내는 것은 <code>Post()</code> 메서드를 통해 이루어집니다. 이 부분이 스레드 스케줄링 방식을 가장 직접적으로 담고 있는 곳입니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class JobDispatcher의 멤버 메서드입니다.</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">IMessage message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 메시지 수 증가 &amp; 큐에 추가</span></span><br><span class="line">    <span class="built_in">int</span> incremented = Interlocked.Increment(<span class="keyword">ref</span> <span class="keyword">this</span>.jobCount);</span><br><span class="line">    <span class="keyword">this</span>.jobQueue.Enqueue(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 이미 다른 메시지가 처리 중이면 리턴</span></span><br><span class="line">    <span class="keyword">if</span> (incremented != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 현재 스레드가 다른 dispatcher를 처리 중이면</span></span><br><span class="line">    <span class="keyword">if</span> (asyncLocalDispatcher.Value != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 대기열에 넣고 나중에 처리</span></span><br><span class="line">        readyQueue.Enqueue(<span class="keyword">this</span>);</span><br><span class="line">        BackgroundJob.Execute(() =&gt; TryConsumeReadyQueue());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 바로 실행 시작</span></span><br><span class="line">    <span class="keyword">this</span>.Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흐름을 따라가 보면:</p><ol><li>먼저 <code>jobCount</code>를 증가시키고 메시지를 큐에 넣습니다.</li><li><code>incremented</code>가 1이 아니면, 이미 다른 메시지가 처리 중이므로 그냥 리턴합니다. 나중에 차례가 오면 처리됩니다.</li><li>현재 스레드가 이미 다른 dispatcher를 처리 중이라면, <code>readyQueue</code>에 넣어둡니다.</li><li>그렇지 않으면 바로 <code>Execute()</code>를 호출하여 실행을 시작합니다.</li></ol><p>이 로직의 핵심은 Post() 메서드를 처리중인 스레드의 입장에서, <strong>“큐의 맨 앞에 메시지를 넣은 것이 내가 맞는지”</strong> 확인하는 것입니다. <code>incremented == 1</code>이면 내가 방금 넣은 메시지가 큐의 첫 번째이므로, 실행을 시작해야 합니다.</p><p><code>Post()</code> 메서드를 처리중인 스레드를 <code>나</code>라고 표현하고 순서도를 그려보면 다음과 같습니다. 개념을 이해할 때에도 스레드의 입장에서 따라가보는 것이 좀 더 쉽습니다.</p><p><img src="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/flowchart_post.png"></p><hr><h2 id="Starvation-방지-readyQueue"><a href="#Starvation-방지-readyQueue" class="headerlink" title="Starvation 방지: readyQueue"></a>Starvation 방지: readyQueue</h2><p><code>readyQueue</code>의 존재 이유를 좀 더 자세히 살펴보겠습니다.</p><h3 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h3><p>Actor A의 메시지를 처리하는 도중에, 처리 로직이 Actor B에게 메시지를 보낸다고 가정해 봅시다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actor A의 메시지 핸들러 내부</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleSomething</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... 처리 ...</span></span><br><span class="line">    actorB.Post(() =&gt; DoSomething());  <span class="comment">// B에게 메시지 전송</span></span><br><span class="line">    <span class="comment">// ... 계속 처리 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B의 <code>Post()</code>가 호출될 때, 현재 스레드는 A를 처리 중입니다. 만약 B의 메시지도 즉시 실행한다면?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A 처리 중 → B.Post() → B 처리 시작 → B가 C에게 Post → C 처리 시작 → ...</span><br></pre></td></tr></table></figure><p>이런 식이라면 <strong>스택이 끝도없이 깊어질 수 있습니다.</strong> 또한 특정 호출 체인에 있는 Actor들만 계속 처리되고, 다른 Actor들은 굶주리는(starve) 상황이 발생할 수 있습니다. 우리가 잠금없는 가벼운 actor를 구현하는 목적을 다시 생각해볼까요. 게임 월드내에 밀집된 공간에서 수많은 유저들이 주고받는 상호작용들도 충분히 소화할 수 있는 가벼운 기반을 만드는 것이었잖아요. 하지만 게임 오브젝트간 인터랙션이 인텐시브 해질수록 처리못한 메시지가 쌓이기만 하는 식이라면 맘편히 이 위에 게임 로직을 쌓아올릴 수 없을 것입니다.</p><h3 id="해결책-readyQueue"><a href="#해결책-readyQueue" class="headerlink" title="해결책: readyQueue"></a>해결책: readyQueue</h3><p>그래서 <code>readyQueue</code>를 사용합니다. 현재 스레드가 이미 dispatcher를 하나 소유하고 처리하고 있는 중이라면(on busy), 새로 활성화된 dispatcher가 생기더라도 <code>readyQueue</code>에 넣어두고 나중에 처리합니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class JobDispatcher의 멤버 메서드입니다.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    JobDispatcher target = <span class="keyword">this</span>;</span><br><span class="line">    asyncLocalDispatcher.Value = <span class="keyword">this</span>;  <span class="comment">// 이 스레드가 이 dispatcher를 소유</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        target.InvokeMessages();  <span class="comment">// 메시지들 처리</span></span><br><span class="line">        readyQueue.TryDequeue(<span class="keyword">out</span> target);  <span class="comment">// 대기 중인 다른 dispatcher</span></span><br><span class="line">        asyncLocalDispatcher.Value = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 모든 처리 완료</span></span><br><span class="line">    asyncLocalDispatcher.Value = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Execute()</code>는 단순히 자신의 메시지만 처리하고 끝나는 것이 아닙니다. 처리가 끝나면 <code>readyQueue</code>에서 대기 중인 다른 dispatcher를 꺼내서 연속으로 처리합니다. 그래야 스레드를 할당받지 못하는 Actor가 없이 모든 메세지들을 소화할 수 있게 됩니다.</p><p>또한 스레드의 불필요한 반환을 줄이는 역할도 합니다. 작업을 마친 스레드가 ThreadPool로 돌아갔다가 다시 깨어나는 과정에는 비용이 듭니다. <code>readyQueue</code>에 처리할 dispatcher가 남아있다면 스레드를 바로 반환하지 않고 연속으로 처리하여, 이런 왕복 비용을 줄입니다. OS의 타임 슬라이스 만료로 인한 컨텍스트 스위칭은 피할 수 없지만, 그 외에 우리 코드에서 발생시키는 부가적인 스위칭 비용은 최소화합니다.</p><p><img src="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/flowchart_execute.png"></p><p>여기까지. 스레드가 어떤 식으로 자기 할 일을 찾게 되는지 조금 전달이 되었나요? 이제 우리는 충분히 가볍고 빠르면서 문제없이 동작하는 스레드 스케줄링 방식을 알아보았습니다.</p><hr><h2 id="동기-비동기-메시지-분리"><a href="#동기-비동기-메시지-분리" class="headerlink" title="동기&#x2F;비동기 메시지 분리"></a>동기&#x2F;비동기 메시지 분리</h2><p>마지막으로, 동기 메시지와 비동기 메시지의 분리에 대해 살펴보겠습니다.<br>포스팅의 길이상 여기에서 한 번 끊어갈까, 생각도 했습니다만… 스레드 운용 측면에서 c#의 await 분절 이후 처리까지 같이 이야기 되어야 온전한 세트가 됩니다. 글이 조금 길어지지만 조금만 더 따라가 봅시다.</p><h3 id="왜-분리가-필요한가"><a href="#왜-분리가-필요한가" class="headerlink" title="왜 분리가 필요한가?"></a>왜 분리가 필요한가?</h3><p>C#의 <code>async/await</code>를 사용하면, <code>await</code> 키워드를 만나는 순간 실행 컨텍스트가 “끊깁니다”. 메서드가 중간에 리턴하고, 나중에 비동기 작업이 완료되면 이어서 실행됩니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">DoSomethingAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;시작&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> SomeAsyncOperation();  <span class="comment">// 여기서 리턴됨. 아주 매끄럽게 아랫줄 실행할 것처럼 생겼지만 훼이크임.</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;끝&quot;</span>);     <span class="comment">// 나중에 실행됨. 사실 언제 어느 스레드가 이어서 실행할지 알 수도 없음.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actor에게 전달한 메시지(job)의 로직이 <code>async</code>라면, 실행 도중 <code>await</code>를 만났을 때 <code>JobDispatcher.InvokeMessages()</code> 입장에서는 메서드가 이미 리턴한 것입니다. 아직 실제 처리는 다 끝나지 않았지만 말이예요!</p><p>이 상태에서 잡큐에 들어있는 다음 메시지를 꺼내 이어서 처리하면, <strong>동일한 Actor에 대해 두 개의 메시지가 동시에 실행</strong>되는 문제가 발생합니다. Actor의 가장 핵심 원칙인 “단일 스레드 접근”이 깨져 버리는 순간입니다.</p><h3 id="IMessage-인터페이스"><a href="#IMessage-인터페이스" class="headerlink" title="IMessage 인터페이스"></a>IMessage 인터페이스</h3><p>이 문제를 해결하기 위해 메시지에 <code>Continuable</code> 플래그를 둡니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> Continuable &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="built_in">string</span> Tag &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Continuable = true</code></strong>: 동기 메시지. <code>Execute()</code> 호출 후 바로 다음 메시지로 넘어가도 됨.</li><li><strong><code>Continuable = false</code></strong>: 비동기 메시지. <code>Execute()</code> 호출 후 await 완료를 기다려야 함.</li></ul><h3 id="동기-메시지-ActorSync"><a href="#동기-메시지-ActorSync" class="headerlink" title="동기 메시지 (ActorSync)"></a>동기 메시지 (ActorSync)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ActorSync</span> : <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Action action;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Continuable =&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.action.Invoke();  <span class="comment">// 실행하고 끝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동기 메시지는 단순합니다. <code>Execute()</code>가 리턴하면 처리가 완료된 것입니다.</p><h3 id="비동기-메시지-ActorAsync"><a href="#비동기-메시지-ActorAsync" class="headerlink" title="비동기 메시지 (ActorAsync)"></a>비동기 메시지 (ActorAsync)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ActorAsync</span> : <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Func&lt;Task&gt; func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Continuable =&gt; <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">this</span>.func.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// await가 완료된 후 다음 메시지 처리 재개</span></span><br><span class="line">            JobDispatcher.AsyncLocalDispatcher.ContinueAfterAwait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>비동기 메시지는 <code>async void Execute()</code>입니다. <code>await</code>가 완료된 후에 <code>ContinueAfterAwait()</code>를 호출하여 다음 메시지 처리를 재개합니다.</p><h3 id="InvokeMessages-에서의-처리-분기"><a href="#InvokeMessages-에서의-처리-분기" class="headerlink" title="InvokeMessages()에서의 처리 분기"></a>InvokeMessages()에서의 처리 분기</h3><p>다시 JobDispatcher로 돌아옵니다. <code>InvokeMessages()</code>는 이 <code>Continuable</code> 플래그에 따라 다르게 동작합니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class JobDispatcher의 멤버 메서드입니다.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InvokeMessages</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.jobQueue.TryPeek(<span class="keyword">out</span> IMessage message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pending = message;</span><br><span class="line">        message.Execute();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!message.Continuable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 비동기 메시지: await 완료 대기</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 동기 메시지: 바로 다음으로</span></span><br><span class="line">        <span class="keyword">this</span>.jobQueue.TryDequeue(<span class="keyword">out</span> _);</span><br><span class="line">        <span class="keyword">this</span>.pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> decremented = Interlocked.Decrement(<span class="keyword">ref</span> <span class="keyword">this</span>.jobCount);</span><br><span class="line">        <span class="keyword">if</span> (decremented == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메세지를 하나씩 꺼내서 처리할 때 비동기 메시지라면, <code>IMessage.Execute()</code> 호출 후 다음 메세지를 꺼내지 않고 바로 리턴합니다. 멤버변수 <code>this.pending</code>에 지금 처리중인 메시지의 참조를 기억해 두었습니다. 나중에 처리중인 메시지 내부의 <code>await</code>가 완료되어 <code>JobDispatcher.ContinueAfterAwait()</code>가 호출되면 그때 <code>this.pending</code>을 정리하고 다음 메시지 처리를 재개합니다.</p><p><img src="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/flowchart_invokemessages.png"></p><hr><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 경량 Actor 구현체의 핵심 구조를 살펴보았습니다. 이번 글은 여러가지 주제를 언급하는 대신 가장 기본이라 할만한 스레드의 흐름을 위주로 정리했습니다. 이렇게만 해도 내용이 제법 적지 않네요. 좀 더 소개하고 싶은 구현상의 이슈들은 분량 조절의 실패로 인해… 다음 포스팅에서 정리 해보겠습니다.</p><p><strong>핵심 정리:</strong></p><ol><li><strong>Symmetric 스레드 모델</strong>: 모든 스레드는 모든 일을 처리. 작업 분배의 불균형 없이 리소스 활용 극대화.</li><li><strong>JobDispatcher</strong>: Actor의 메시지 큐와 실행을 담당. <code>AsyncLocal</code>로 소유권 추적.</li><li><strong>readyQueue</strong>: 현재 스레드가 바쁠 때 다른 dispatcher를 대기열에 넣어 Starvation 방지.</li><li><strong>Continuable 플래그</strong>: 동기&#x2F;비동기 메시지 구분. <code>await</code>후 안전하게 진행을 재개.</li></ol><p>다음 글에서는 실제 구현하고 직접 사용하는 과정에서 은근히 고민하게 만들거나 신경이 쓰였던 세부적인 내용 주제들을 다룹니다:</p><ul><li><strong>람다를 이용한 작업 효율 향상</strong>: 액터에 전달할 메세지타입을 일일이 정의하지 말고, 컴파일러가 제공하는 편의성을 누려봅시다.</li><li><strong>생명주기 제어</strong>: C#은 GC가 있는 대신 C++의 <code>std::shared_ptr&lt;&gt;</code>에 “꼭 맞는” 동작이 없더라고요.</li><li><strong>클로저 캡처 문제</strong>: C++의 람다는 캡쳐리스트가 좀 더 명시적인 반면, C#의 람다는 암묵적인 캡쳐가 너무 쉽게 일어나더라고요.</li><li><strong>C# 단일 상속 제약</strong>: C#에서는 단일상속만 지원을 해요. 부모클래스가 두 개일 수 없더라고요.</li></ul><hr><p><em>다음 글: C#으로 구현하는 경량 Actor (2) - 생명주기 제어 및 언어적 특성들 (예정)</em></p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/actor/">actor</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/multithread/">multithread</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/csharp/">csharp</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/gameserver/">gameserver</category>
      
      
      <comments>http://leafbird.github.io/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Applying the Actor Pattern to MMO Servers</title>
      <link>http://leafbird.github.io/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/</link>
      <guid>http://leafbird.github.io/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/</guid>
      <pubDate>Tue, 27 Jan 2026 02:25:23 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/actor_mmo.png&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;들어가며&quot;&gt;&lt;a href=&quot;#들어가며&quot; class=&quot;headerlink&quot; title=&quot;들어가며&quot;&gt;&lt;/a&gt;들어가며&lt;/h2&gt;&lt;p&gt;지난 글(&lt;a href=&quot;/devnote/2026/01/21/Understanding-the-Actor-Pattern/&quot; title=&quot;Prologue - Understanding the Actor Pattern&quot;&gt;링크&lt;/a&gt;)에서는 POSA 2의 동시성 패턴들 — Reactor, Proactor, Actor — 을 간단하게 소개하고 살펴보았습니다. 이론적 배경을 이해했으니, 이제 실전으로 넘어갈 차례입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;근데 이제.. 실제 게임 만들 때 Actor 모델을 어떻게 적용한다는 건가?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 질문에 정해진 답은 없습니다. 하지만 Actor의 적용 범위에 따라 실제 프로그래머가 코딩하는 환경이나 완성된 시스템의 동작 특성은 제법 큰 차이가 발생합니다. 이번 글에서는 MMO 게임속 상황을 예시로, 두 가지 대조적인 접근 방식을 살펴보겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/actor_mmo.png" class=""><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>지난 글(<a href="/devnote/2026/01/21/Understanding-the-Actor-Pattern/" title="Prologue - Understanding the Actor Pattern">링크</a>)에서는 POSA 2의 동시성 패턴들 — Reactor, Proactor, Actor — 을 간단하게 소개하고 살펴보았습니다. 이론적 배경을 이해했으니, 이제 실전으로 넘어갈 차례입니다.</p><blockquote><p><strong>근데 이제.. 실제 게임 만들 때 Actor 모델을 어떻게 적용한다는 건가?</strong></p></blockquote><p>이 질문에 정해진 답은 없습니다. 하지만 Actor의 적용 범위에 따라 실제 프로그래머가 코딩하는 환경이나 완성된 시스템의 동작 특성은 제법 큰 차이가 발생합니다. 이번 글에서는 MMO 게임속 상황을 예시로, 두 가지 대조적인 접근 방식을 살펴보겠습니다.</p><span id="more"></span><hr><h2 id="MMO-서버의-도전-과제"><a href="#MMO-서버의-도전-과제" class="headerlink" title="MMO 서버의 도전 과제"></a>MMO 서버의 도전 과제</h2><p>먼저 저는 지금은 MMO 게임 프로젝트를 진행하고 있지는 않아요. 그보다는 좀 더 인터랙션이 간소한 수집형 턴제 전투형 게임 서버를 개발 중입니다. 하지만 동시성 문제를 해결하는 예시와 설명을 위해서는 대량의 동시 접속자와 복잡한 상호작용이 요구되는 MMO 서버가 좀 더 실감나는 사례라고 생각합니다.</p><p>MMO 서버는 동시성 프로그래밍의 극한을 보여주는 영역입니다.</p><ul><li><strong>수천 명의 동시 접속</strong> — 하나의 월드에 수천 명이 실시간으로 상호작용</li><li><strong>복잡한 상태 공유</strong> — 캐릭터, 몬스터, 아이템, 발사체가 서로 영향을 주고받음</li><li><strong>낮은 지연 요구</strong> — 100ms의 지연도 플레이어 경험을 해침</li></ul><img src="/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/aion.png" class=""><p>&lt;출처: <a href="https://www.ncsoft.com/games/aion">아이온</a> 요새전. 이미지는 본 글의 내용과 직접적인 관련이 없습니다.&gt;</p><p>전통적인 lock 기반 접근은 이러한 규모에서 한계를 드러냅니다. 아주 간단하게, 캐릭터 a가 b를 한 대 때려볼까요?</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전통적인 lock 기반 접근</span></span><br><span class="line"><span class="keyword">lock</span> (zone.Lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (characterA.Lock)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (characterB.Lock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 데드락 위험, 성능 저하</span></span><br><span class="line">            characterA.Attack(characterB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock의 순서를 관리하고, 데드락을 피하고, 경합을 최소화하는 것은 시스템이 커질수록 기하급수적으로 어려워집니다.</p><p>Actor 패턴은 이 문제에 대한 우아한 해법을 제시합니다. 그런데 한 가지 중요한 설계 결정이 남아 있습니다. Actor의 범위를 어디까지로 잡을 것인가?</p><hr><h2 id="예시-시나리오-필드에서의-전투"><a href="#예시-시나리오-필드에서의-전투" class="headerlink" title="예시 시나리오: 필드에서의 전투"></a>예시 시나리오: 필드에서의 전투</h2><p>구체적인 상황을 가정해 봅시다.</p><blockquote><p><strong>시나리오</strong>: 캐릭터 A가 캐릭터 B를 공격한다</p></blockquote><p>이 단순해 보이는 상호작용에는 여러 처리가 얽혀 있습니다.</p><ol><li>A의 공격 판정 (스킬 쿨다운, 마나 소모)</li><li>B의 피격 판정 (회피, 방어력 계산)</li><li>B의 HP 감소</li><li>주변 캐릭터들에게 전투 이펙트 브로드캐스트</li><li>B가 사망 시 아이템 드랍, 경험치 분배</li><li>B의 사망으로 트리거되는 다양한 게임 이벤트들. 퀘스트 완료, 업적 달성, 땅이 갈라지며 보스몹 등장(갑자기?) 등등..</li></ol><p>이 시나리오를 Actor 패턴으로 처리할 때, <strong>Actor의 범위를 어떻게 설정하느냐</strong>에 따라 이후 구현은 크게 달라집니다.</p><hr><h2 id="접근-1-Coarse-grained-—-Zone-단위-Actor"><a href="#접근-1-Coarse-grained-—-Zone-단위-Actor" class="headerlink" title="접근 1: Coarse-grained — Zone 단위 Actor"></a>접근 1: Coarse-grained — Zone 단위 Actor</h2><h3 id="Zone이란"><a href="#Zone이란" class="headerlink" title="Zone이란?"></a>Zone이란?</h3><p>캐릭터가 존재하는 가상의 공간(World)은 완전하게 무한할 수는 없기 때문에, 보통은 논리적 &amp; 물리적 한계를 고려한 일정 단위로 분리하고 다시 이어붙여서 만들어집니다. 이 단위는 여러가지 이름으로 불립니다. 채널이라 부르기도 하고, Zone이라 부르기도 합니다. 이 글에서는 Zone이라고 지칭하겠습니다.</p><p>대부분의 게임 내 상호작용은 같은 Zone 안에서 이루어집니다. 캐릭터끼리 전투하고, 아이템을 줍고, 몬스터를 사냥하는 일은 모두 하나의 Zone 내에서 발생합니다. 반면 서로 다른 Zone 간에는 상호작용이 거의 없습니다. 기껏해야 Zone 이동(텔레포트, 포탈) 정도입니다.</p><p>이런 특성을 고려하면, <strong>Zone 전체를 하나의 Actor</strong>로 만드는 접근이 자연스럽습니다.</p><img src="/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/diagram_00.png" class=""><h3 id="공격-처리-흐름"><a href="#공격-처리-흐름" class="headerlink" title="공격 처리 흐름"></a>공격 처리 흐름</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zone Actor 내부</span></span><br><span class="line">zoneActor.Post(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> attacker = _characters[attackerId];</span><br><span class="line">    <span class="keyword">var</span> target = _characters[targetId];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 모든 처리가 동기적으로, 같은 컨텍스트에서</span></span><br><span class="line">    <span class="keyword">if</span> (attacker.CanAttack())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> damage = attacker.CalculateDamage();</span><br><span class="line">        target.TakeDamage(damage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target.IsDead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> loot = target.DropLoot();</span><br><span class="line">            _items.Add(loot);</span><br><span class="line">            attacker.GainExp(target.ExpValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 주변 캐릭터에게 브로드캐스트도 즉시 처리</span></span><br><span class="line">        BroadcastToNearby(attacker.Position, <span class="keyword">new</span> CombatEffect(...));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><p><strong>1. 구현이 단순하다</strong></p><p>Zone 내의 모든 객체가 같은 Actor에 속하므로, 객체 간 상호작용이 일반적인 메서드 호출과 같습니다. 메시지를 주고받을 필요 없이 직접 상태를 읽고 쓸 수 있습니다.</p><p><strong>2. 일관성이 자동으로 보장된다</strong></p><p>“A가 B를 공격하는 동안 B가 다른 Zone으로 이동”하는 상황이 구조적으로 발생하지 않습니다. 모든 처리가 순차적이므로 race condition이 없습니다.</p><p><strong>3. 디버깅이 쉽다</strong></p><p>단일 스레드에서 순차 실행되므로, 문제 발생 시 콜스택을 따라가면 원인을 찾을 수 있습니다.</p><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><p><strong>1. 멀티코어를 활용할 수 없다</strong></p><p>Zone 하나는 CPU 코어 하나만 사용합니다. 8코어 서버에서 8개 Zone이 균등하게 분산되어 있다면 괜찮지만, 한 Zone에 플레이어가 몰리면 그 Zone은 단일 코어로 모든 부하를 감당해야 합니다.</p><p><strong>2. 핫스팟 문제</strong></p><p>보스 레이드, 공성전처럼 많은 플레이어가 한 Zone에 모이는 상황에서 성능이 급격히 저하됩니다. Zone당 처리량에 상한이 생깁니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8코어 서버, 3개 Zone 운영 중</span><br><span class="line"></span><br><span class="line">[Zone A: 50명]  → 코어 1개로 충분</span><br><span class="line">[Zone B: 500명] → 코어 1개로 버거움 (병목)</span><br><span class="line">[Zone C: 30명]  → 코어 1개로 충분</span><br><span class="line"></span><br><span class="line">                  나머지 5개 코어는 놀고 있음</span><br></pre></td></tr></table></figure><p><strong>3. 확장성 한계</strong></p><p>서버를 증설해도 Zone 단위로만 분산되므로, Zone 내부의 부하를 분산할 방법이 없습니다. 결국 단일 Zone에 많은 유저가 몰리지 않도록 게임 디자인을 조정하거나, Zone에 입장 가능한 최대 유저 수를 제한해야 합니다.</p><hr><h2 id="접근-2-Fine-grained-—-Object-단위-Actor"><a href="#접근-2-Fine-grained-—-Object-단위-Actor" class="headerlink" title="접근 2: Fine-grained — Object 단위 Actor"></a>접근 2: Fine-grained — Object 단위 Actor</h2><p>이번에는 트래픽 처리 능력을 증가시키기 위해, 더 자잘한 단위로 쪼개보겠습니다. 게임 내의 <strong>각각의 오브젝트(캐릭터, 몬스터, 아이템 등)를 독립된 Actor</strong>로 만드는 접근입니다.</p><img src="/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/diagram_01.png" class=""><h3 id="공격-처리-흐름-1"><a href="#공격-처리-흐름-1" class="headerlink" title="공격 처리 흐름"></a>공격 처리 흐름</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Character A Actor</span></span><br><span class="line">attackerActor.Post(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CanAttack()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> damage = CalculateDamage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// B에게 lambda 전송 (비동기)</span></span><br><span class="line">    targetActor.Post(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        TakeDamage(damage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsDead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 아이템 Actor 생성</span></span><br><span class="line">            <span class="keyword">var</span> lootActor = SpawnItemActor(DropLoot());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// A에게 경험치 부여</span></span><br><span class="line">            attackerActor.Post(() =&gt; GainExp(expValue));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Zone에게 사망 알림</span></span><br><span class="line">            zoneActor.Post(() =&gt; OnCharacterDeath(characterId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="장점-1"><a href="#장점-1" class="headerlink" title="장점"></a>장점</h3><p><strong>1. 멀티코어를 최대한 활용한다</strong></p><p>각 Actor가 독립적으로 실행되므로, 시스템은 가용한 모든 코어에 작업을 분산할 수 있습니다. Zone에 1000명이 몰려도 1000개의 Actor가 병렬로 처리됩니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Zone: 1000명]</span><br><span class="line">  └─ Actor 1 → 코어 1</span><br><span class="line">  └─ Actor 2 → 코어 2</span><br><span class="line">  └─ Actor 3 → 코어 3</span><br><span class="line">  └─ ...</span><br><span class="line">  └─ Actor 1000 → 코어들에 분산</span><br></pre></td></tr></table></figure><p><strong>2. 수평 확장이 가능하다</strong></p><p>Actor는 위치 투명성을 가지므로, 이론적으로 여러 서버에 걸쳐 분산할 수 있습니다. 부하가 증가하면 서버를 추가하여 대응할 수 있습니다.</p><p><strong>3. 장애 격리</strong></p><p>한 Actor에서 예외가 발생해도 다른 Actor에 직접 영향을 주지 않습니다. 시스템의 일부 장애가 전체로 전파되지 않습니다.</p><h3 id="단점-1"><a href="#단점-1" class="headerlink" title="단점"></a>단점</h3><p><strong>1. 구현 복잡도가 상승한다</strong></p><p>모든 상호작용이 비동기 호출로 이루어지므로, 단순한 “A가 B를 공격”도 여러 단계의 콜백이 됩니다. 순차적 사고에 익숙한 개발자에게는 진입 장벽이 있습니다.</p><p><strong>2. 일관성 보장이 어렵다</strong></p><p>“A가 B를 공격하는 요청”과 “B가 Zone을 떠나는 요청”이 동시에 발생하면? 요청 순서와 상태 정합성을 신중하게 설계해야 합니다.</p><p><strong>3. 메시지 폭증 가능성</strong></p><p>모든 상호작용이 비동기 호출이므로, 설계를 잘못하면 호출이 기하급수적으로 증가할 수 있습니다. 이 문제는 별도의 최적화 전략이 필요하며, 추후 다른 글에서 다뤄보겠습니다.</p><hr><h2 id="비교-정리"><a href="#비교-정리" class="headerlink" title="비교 정리"></a>비교 정리</h2><table><thead><tr><th align="center">구분</th><th align="center">Coarse-grained (Zone)</th><th align="center">Fine-grained (Object)</th></tr></thead><tbody><tr><td align="center"><strong>Actor 단위</strong></td><td align="center">Zone 전체</td><td align="center">개별 오브젝트</td></tr><tr><td align="center"><strong>멀티코어 활용</strong></td><td align="center">❌ Zone당 1코어</td><td align="center">✅ 최대 활용</td></tr><tr><td align="center"><strong>구현 난이도</strong></td><td align="center">✅ 낮음</td><td align="center">⚠️ 높음</td></tr><tr><td align="center"><strong>일관성 보장</strong></td><td align="center">✅ 자동</td><td align="center">⚠️ 명시적 설계 필요</td></tr><tr><td align="center"><strong>확장성</strong></td><td align="center">❌ Zone 단위 한계</td><td align="center">✅ 수평 확장 가능</td></tr><tr><td align="center"><strong>핫스팟 대응</strong></td><td align="center">❌ 취약</td><td align="center">✅ 강함</td></tr></tbody></table><hr><h2 id="어떤-방식을-선택할-것인가"><a href="#어떤-방식을-선택할-것인가" class="headerlink" title="어떤 방식을 선택할 것인가"></a>어떤 방식을 선택할 것인가</h2><p>앞서 살펴본 바와 같이 두 접근 방식은 명확한 트레이드오프가 있습니다. 게임의 규모와 방향성에 맞는 구조를 선택해야 합니다.</p><p>하지만 장르 이름 자체가 <strong>MMO(Massively Multiplayer Online)</strong> 인 만큼, 대량의 트래픽을 처리하는 것은 MMO 엔진의 핵심 요소입니다. Fine-grained 방식의 구현 복잡도 문제는 분명 존재하지만, 적절한 추상화와 도구를 통해 상당 부분 완화할 수 있습니다.</p><p>이와 관련하여 NDC25에서 발표된 <strong>“MMO 서버에서 태스크 그래프를 활용한 확장성 있는 멀티스레드 아키텍처”</strong> (넥슨게임즈)는 매우 좋은 참고 사례입니다. Fine-grained Actor 환경에서 복잡도를 관리하는 소중한 실전 노하우를 소개하고 있습니다. (링크 : <a href="https://www.youtube.com/watch?v=6nYtK7kNiH8">https://www.youtube.com/watch?v=6nYtK7kNiH8</a>) 이 발표의 내용을 차근히 풀어서 설명하는 포스팅을 작성해도 지금의 시리즈 연작과 잘 어울리겠다는 생각이 듭니다. 일단 제가 하고 싶은 말을 다하고 여력이 된다면… 한 번 시도해 보겠습니다.</p><hr><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 글에서는 지난 글에서 패턴의 이름으로만 소개했던 Actor 모델을, 실제 MMO 서버 구현에 어떻게 적용할 수 있는지 살펴보았습니다. Zone 단위의 <code>Coarse-grained</code> 접근과 Object 단위의 <code>Fine-grained</code> 접근을 비교하며, 각각의 장단점을 확인했습니다.</p><p>다음 글에서는 (진짜로) <strong>C#으로 작성해본 경량 Actor 구현기</strong>를 살펴봅니다. 게임서버에서 특히나 중요하게 여기는 빠른 응답성, 객체 수명주기 관리, 대량 트래픽을 위한 가벼운 구현 등을 어떻게 달성했는지 구체적인 코드와 함께 다루어 보겠습니다.</p><hr><p>다음 글: <a href="/devnote/2026/01/29/Implementing-Lightweight-Actor-in-CSharp-Part1/" title="Implementing Lightweight Actor in C# (1) - 기본 구조와 스케줄링">Implementing Lightweight Actor in C# (1) - 기본 구조와 스케줄링</a> </p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/actor/">actor</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/multithread/">multithread</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/gameserver/">gameserver</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/mmo/">mmo</category>
      
      
      <comments>http://leafbird.github.io/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Prologue - Understanding the Actor Pattern</title>
      <link>http://leafbird.github.io/devnote/2026/01/21/Understanding-the-Actor-Pattern/</link>
      <guid>http://leafbird.github.io/devnote/2026/01/21/Understanding-the-Actor-Pattern/</guid>
      <pubDate>Wed, 21 Jan 2026 01:09:02 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2026/01/21/Understanding-the-Actor-Pattern/actor_prologue.png&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;들어가며&quot;&gt;&lt;a href=&quot;#들어가며&quot; class=&quot;headerlink&quot; title=&quot;들어가며&quot;&gt;&lt;/a&gt;들어가며&lt;/h2&gt;&lt;p&gt;동시성 프로그래밍은 현대 소프트웨어 개발에서 피할 수 없는 주제입니다. 멀티코어 프로세서가 보편화되고, 분산 시스템이 일상이 된 지금, 효율적이고 안전한 동시성 처리는 더 이상 선택이 아닌 필수가 되었습니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 현재 프로젝트에서 직접 작성해 사용하고 있는 C# Actor 구현체를 소개하기에 앞서, 먼저 Actor 패턴의 이론적 배경을 살펴보고자 합니다. 특히 &lt;strong&gt;POSA 2&lt;/strong&gt;에서 소개하는 동시성 패턴들을 중심으로, Actor 패턴이 어떤 맥락에서 등장했는지 이해해 보겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2026/01/21/Understanding-the-Actor-Pattern/actor_prologue.png" class=""><h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h2><p>동시성 프로그래밍은 현대 소프트웨어 개발에서 피할 수 없는 주제입니다. 멀티코어 프로세서가 보편화되고, 분산 시스템이 일상이 된 지금, 효율적이고 안전한 동시성 처리는 더 이상 선택이 아닌 필수가 되었습니다.</p><p>이 글에서는 현재 프로젝트에서 직접 작성해 사용하고 있는 C# Actor 구현체를 소개하기에 앞서, 먼저 Actor 패턴의 이론적 배경을 살펴보고자 합니다. 특히 <strong>POSA 2</strong>에서 소개하는 동시성 패턴들을 중심으로, Actor 패턴이 어떤 맥락에서 등장했는지 이해해 보겠습니다.</p><span id="more"></span><hr><h2 id="POSA-2-Patterns-for-Concurrent-and-Networked-Objects"><a href="#POSA-2-Patterns-for-Concurrent-and-Networked-Objects" class="headerlink" title="POSA 2: Patterns for Concurrent and Networked Objects"></a>POSA 2: Patterns for Concurrent and Networked Objects</h2><p><strong>POSA(Pattern-Oriented Software Architecture)</strong> 는 소프트웨어 아키텍처 패턴을 집대성한 시리즈로, 총 5권으로 구성되어 있습니다. 그 중 2권인 <strong>“Patterns for Concurrent and Networked Objects”</strong> 는 2000년에 출간되어, 동시성과 네트워크 프로그래밍 패턴의 바이블로 자리잡았습니다.</p><h3 id="저자들"><a href="#저자들" class="headerlink" title="저자들"></a>저자들</h3><p>POSA 2는 네 명의 저자가 공동 집필했습니다:</p><ul><li><p><strong>Douglas C. Schmidt</strong>: 미국 Vanderbilt 대학 교수이자 <strong>ACE(Adaptive Communication Environment)</strong> 프레임워크의 창시자입니다. ACE는 크로스플랫폼 동시성&#x2F;네트워킹 프레임워크로, 이 책에서 소개하는 패턴들의 실제 구현체이기도 합니다. 보잉, 모토로라, 시스코 등 수많은 기업의 미션 크리티컬 시스템에 적용되었습니다.</p></li><li><p><strong>Michael Stal</strong>: Siemens 연구소의 수석 엔지니어로, 대규모 분산 시스템 아키텍처 분야의 권위자입니다.</p></li><li><p><strong>Hans Rohnert</strong>: 역시 Siemens 연구소 출신으로, 산업용 소프트웨어 아키텍처 전문가입니다.</p></li><li><p><strong>Frank Buschmann</strong>: POSA 시리즈 전체의 주축이 되는 인물로, 1996년 출간된 POSA 1권의 주 저자이기도 합니다. 현재는 Siemens Technology에서 수석 엔지니어로 활동하고 있습니다.</p></li></ul><h3 id="책의-위상"><a href="#책의-위상" class="headerlink" title="책의 위상"></a>책의 위상</h3><p>1994년 GoF(Gang of Four)의 <strong>“Design Patterns”</strong> 이 객체지향 설계 패턴의 교과서가 되었다면, POSA 2는 <strong>동시성 패턴의 교과서</strong>입니다. 25년이 지난 지금도 이 책에서 정의한 패턴 용어와 개념들—Reactor, Proactor, Active Object, Half-Sync&#x2F;Half-Async, Leader&#x2F;Followers 등—은 업계 표준으로 사용되고 있습니다.</p><p>Boost.Asio, libuv, Netty, gRPC 같은 현대 네트워킹 라이브러리들의 설계 철학을 이해하려면, 결국 이 책으로 돌아오게 됩니다.</p><hr><h2 id="POSA-2의-동시성-패턴들"><a href="#POSA-2의-동시성-패턴들" class="headerlink" title="POSA 2의 동시성 패턴들"></a>POSA 2의 동시성 패턴들</h2><p>POSA 2권은 동시성과 네트워킹을 위한 패턴들을 집중적으로 다룹니다. 그 중에서도 이벤트 처리와 관련된 세 가지 핵심 패턴이 있습니다:</p><ul><li><strong>Reactor</strong></li><li><strong>Proactor</strong></li><li><strong>Active Object (Actor)</strong></li></ul><p>이 패턴들은 모두 “이벤트를 어떻게 효율적으로 처리할 것인가”라는 공통된 문제를 다루지만, 각기 다른 접근 방식을 취합니다.</p><hr><h2 id="Reactor-패턴"><a href="#Reactor-패턴" class="headerlink" title="Reactor 패턴"></a>Reactor 패턴</h2><p><strong>Reactor</strong>는 동기적 이벤트 디멀티플렉싱(demultiplexing)을 담당하는 패턴입니다. 하나의 스레드가 여러 이벤트 소스를 감시하다가, 이벤트가 발생하면 해당 이벤트 핸들러에게 처리를 위임합니다.</p><h3 id="핵심-구조"><a href="#핵심-구조" class="headerlink" title="핵심 구조"></a>핵심 구조</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Event Sources] → [Synchronous Event Demultiplexer] → [Dispatcher] → [Event Handlers]</span><br></pre></td></tr></table></figure><h3 id="대표적인-예시-Event-Handler-기반-GUI-프레임워크"><a href="#대표적인-예시-Event-Handler-기반-GUI-프레임워크" class="headerlink" title="대표적인 예시: Event Handler 기반 GUI 프레임워크"></a>대표적인 예시: Event Handler 기반 GUI 프레임워크</h3><p>Windows Forms나 WPF 같은 GUI 프레임워크의 메시지 루프가 전형적인 Reactor 패턴입니다:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 단일 스레드가 메시지 큐를 감시하며 이벤트를 디스패치</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(<span class="keyword">out</span> msg, IntPtr.Zero, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(<span class="keyword">ref</span> msg);</span><br><span class="line">    DispatchMessage(<span class="keyword">ref</span> msg);  <span class="comment">// 적절한 핸들러로 전달</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마우스 클릭, 키보드 입력 등 다양한 이벤트 소스를 하나의 루프에서 감시하고, 이벤트 발생 시 등록된 핸들러를 동기적으로 호출합니다.</p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li><strong>동기적 처리</strong>: 이벤트 핸들러가 완료될 때까지 다음 이벤트를 처리하지 않음</li><li><strong>단순한 프로그래밍 모델</strong>: 핸들러 내에서 동시성을 고려할 필요가 적음</li><li><strong>I&#x2F;O 바운드 작업에 취약</strong>: 핸들러가 블로킹되면 전체 시스템이 멈춤</li></ul><hr><h2 id="Proactor-패턴"><a href="#Proactor-패턴" class="headerlink" title="Proactor 패턴"></a>Proactor 패턴</h2><p><strong>Proactor</strong>는 비동기 I&#x2F;O 완료를 처리하는 패턴입니다. Reactor와 달리 I&#x2F;O 작업 자체를 OS에게 위임하고, 완료 통지를 받아 처리합니다.</p><h3 id="핵심-구조-1"><a href="#핵심-구조-1" class="headerlink" title="핵심 구조"></a>핵심 구조</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Async Operation] → [OS Kernel] → [Completion Event Queue] → [Proactor] → [Completion Handlers]</span><br></pre></td></tr></table></figure><h3 id="대표적인-예시-IOCP-I-O-Completion-Port"><a href="#대표적인-예시-IOCP-I-O-Completion-Port" class="headerlink" title="대표적인 예시: IOCP (I&#x2F;O Completion Port)"></a>대표적인 예시: IOCP (I&#x2F;O Completion Port)</h3><p>Windows의 IOCP는 Proactor 패턴의 대표적인 구현입니다:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 비동기 작업 시작</span></span><br><span class="line">socket.BeginReceive(buffer, <span class="number">0</span>, buffer.Length, SocketFlags.None,</span><br><span class="line">    OnReceiveCompleted, state);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OS가 I/O를 수행하고, 완료되면 Completion Port에 통지</span></span><br><span class="line"><span class="comment">// Proactor(IOCP)가 완료 이벤트를 감지하여 핸들러 호출</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnReceiveCompleted</span>(<span class="params">IAsyncResult ar</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// I/O는 이미 완료된 상태 - 결과만 처리</span></span><br><span class="line">    <span class="built_in">int</span> bytesRead = socket.EndReceive(ar);</span><br><span class="line">    ProcessData(buffer, bytesRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reactor-vs-Proactor"><a href="#Reactor-vs-Proactor" class="headerlink" title="Reactor vs Proactor"></a>Reactor vs Proactor</h3><table><thead><tr><th>구분</th><th>Reactor</th><th>Proactor</th></tr></thead><tbody><tr><td>I&#x2F;O 수행 주체</td><td>애플리케이션</td><td>OS 커널</td></tr><tr><td>이벤트 의미</td><td>“읽을 준비가 됨”</td><td>“읽기가 완료됨”</td></tr><tr><td>스레드 블로킹</td><td>I&#x2F;O 중 블로킹</td><td>블로킹 없음</td></tr><tr><td>대표 구현</td><td>select, epoll, kqueue</td><td>IOCP, io_uring</td></tr></tbody></table><hr><h2 id="Active-Object-Actor-패턴"><a href="#Active-Object-Actor-패턴" class="headerlink" title="Active Object (Actor) 패턴"></a>Active Object (Actor) 패턴</h2><p><strong>Active Object</strong> 패턴은 메서드 호출(invocation)과 메서드 실행(execution)을 분리합니다. 각 Active Object는 자신만의 실행 컨텍스트(스레드)를 가지며, 외부 요청은 메시지 큐에 저장되어 순차적으로 처리됩니다.</p><h3 id="핵심-구조-2"><a href="#핵심-구조-2" class="headerlink" title="핵심 구조"></a>핵심 구조</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Client] → [Proxy] → [Activation Queue] → [Scheduler] → [Servant]</span><br><span class="line">                                              ↑</span><br><span class="line">                                    [자체 스레드에서 실행]</span><br></pre></td></tr></table></figure><h3 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h3><p>Active Object는 다음과 같은 구성요소로 이루어집니다:</p><ol><li><strong>Proxy</strong>: 클라이언트가 호출하는 인터페이스</li><li><strong>Activation Queue</strong>: 요청을 저장하는 메시지 큐</li><li><strong>Scheduler</strong>: 큐에서 요청을 꺼내 실행하는 컴포넌트</li><li><strong>Servant</strong>: 실제 비즈니스 로직을 수행하는 객체</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 개념적인 Active Object 사용 예시</span></span><br><span class="line"><span class="keyword">var</span> actor = <span class="keyword">new</span> BankAccountActor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메시지를 큐에 넣고 즉시 반환 (Fire-and-Forget)</span></span><br><span class="line">actor.Post(() =&gt; actor.Deposit(<span class="number">100</span>));</span><br><span class="line">actor.Post(() =&gt; actor.Withdraw(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과가 필요한 경우 - 큐잉 후 완료를 대기</span></span><br><span class="line"><span class="keyword">var</span> balance = <span class="keyword">await</span> actor.PostAsync(() =&gt; actor.GetBalance());</span><br></pre></td></tr></table></figure><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><p><strong>1. 암묵적 동기화 (Implicit Synchronization)</strong></p><p>각 Actor는 자신의 상태에 대해 단일 스레드로 접근하므로, lock이나 mutex 같은 명시적 동기화가 필요 없습니다:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actor 내부 - lock 없이 안전</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">decimal</span> _balance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deposit</span>(<span class="params"><span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _balance += amount;  <span class="comment">// 단일 스레드 접근 보장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 논리적 분리 (Logical Separation)</strong></p><p>각 Actor는 독립적인 실행 단위로, 복잡한 시스템을 작은 단위로 분해할 수 있습니다. 각 Actor는 자신의 책임에만 집중하면 됩니다.</p><p><strong>3. 위치 투명성 (Location Transparency)</strong></p><p>메시지 기반 통신은 Actor가 같은 프로세스에 있든, 다른 머신에 있든 동일한 방식으로 작동할 수 있게 합니다.</p><p><strong>4. 장애 격리 (Fault Isolation)</strong></p><p>한 Actor의 실패가 다른 Actor에게 직접적으로 전파되지 않습니다. 이는 탄력적인 시스템 설계를 가능하게 합니다.</p><p><strong>5. 자연스러운 비동기 처리</strong></p><p>메시지 전송은 본질적으로 비동기이므로, 시스템 전체가 논블로킹 방식으로 동작합니다.</p><hr><h2 id="세-패턴의-관계"><a href="#세-패턴의-관계" class="headerlink" title="세 패턴의 관계"></a>세 패턴의 관계</h2><p><strong>동시성 이벤트 처리</strong></p><table><thead><tr><th align="center">구분</th><th align="center">Reactor</th><th align="center">Proactor</th><th align="center">Active Object</th></tr></thead><tbody><tr><td align="center"><strong>특성</strong></td><td align="center">동기 이벤트 디멀티플렉싱</td><td align="center">비동기 I&#x2F;O 완료 이벤트 처리</td><td align="center">메시지 기반 처리, 실행 분리</td></tr><tr><td align="center"><strong>대표 구현</strong></td><td align="center">Event Handler</td><td align="center">IOCP</td><td align="center">Actor, Akka, Erlang</td></tr></tbody></table><p>Reactor와 Proactor가 “이벤트를 어떻게 효율적으로 감지할 것인가”에 집중한다면, Active Object는 “이벤트(메시지)를 어떻게 안전하게 처리할 것인가”에 집중합니다. 실제로 많은 Actor 시스템들은 내부적으로 Reactor나 Proactor를 사용하여 I&#x2F;O를 처리하고, 그 위에 Actor 모델을 구축합니다.</p><hr><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 POSA 2에서 소개하는 Reactor, Proactor, Active Object 패턴을 살펴보았습니다. 이 패턴들은 동시성 프로그래밍의 복잡성을 다루기 위한 검증된 해법들입니다.</p><p>특히 Active Object(Actor) 패턴은 “공유 상태 없이 메시지로 소통한다”는 단순하면서도 강력한 원칙으로, 복잡한 동시성 문제를 우아하게 해결할 수 있게 합니다.</p><p>첫 번째 글에서는 공감대 형성을 위해 간단한 소개만 적어 보았습니다. <strong>다음 포스팅에서는 현재 프로젝트에서 구현하여 사용하고 있는 C# Actor 구현기를 적어보겠습니다.</strong> 이론적 배경을 바탕으로, 실제로 어떻게 Actor 패턴을 C#에서 구현하고 활용할 수 있는지 구체적인 코드와 함께 살펴봅니다. 게임서버에서 중요하게 여기는 빠른 응답성, 게임객체들의 수명주기와 관련한 고려사항, 대량의 트래픽을 소화하기 위한 가벼운 구현 등의 이슈를 정리해 보겠습니다.</p><hr><p>다음 글: <a href="/devnote/2026/01/27/Applying-the-Actor-Pattern-to-MMO-Servers/" title="Applying the Actor Pattern to MMO Servers">Actor 패턴 적용 예시: MMO 서버 구현</a> </p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/actor/">actor</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/multithread/">multithread</category>
      
      
      <comments>http://leafbird.github.io/devnote/2026/01/21/Understanding-the-Actor-Pattern/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>the best choice of the year</title>
      <link>http://leafbird.github.io/devnote/2025/11/11/the-best-choice-of-the-year/</link>
      <guid>http://leafbird.github.io/devnote/2025/11/11/the-best-choice-of-the-year/</guid>
      <pubDate>Tue, 11 Nov 2025 02:30:24 GMT</pubDate>
      
      <description>&lt;p&gt;올 해에 가장 잘 했던 기술적 선택을 꼽으라고 한다면&lt;br&gt;연초에 서비스 환경을 리눅스로 전환하겠다고 결정한 점이다.&lt;/p&gt;
&lt;img src=&quot;/devnote/2025/11/11/the-best-choice-of-the-year/image.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>올 해에 가장 잘 했던 기술적 선택을 꼽으라고 한다면<br>연초에 서비스 환경을 리눅스로 전환하겠다고 결정한 점이다.</p><img src="/devnote/2025/11/11/the-best-choice-of-the-year/image.png" class=""><span id="more"></span><p>그동안은 MMO 프로젝트를 하면서 윈도우 커널이 제공하는 컴퓨팅 환경을 바닥까지 쥐어짜서 쓰는 고수님들의 실력에 감탄하고 동경했다. 스레드 컨텍스트 스위칭 하나, cpu 캐시미스 하나까지 절약하는 핵고수님들을 따라가려면 나는 주제넘게 여러 분야 건드리지 말고 하나 만이라도 잘 따라가자는 생각이 있었던 것 같다.</p><p>이제는 상황이 변했고, 생각도 조금 바뀌었다. 지금은 단일스팟(&#x3D;단일 윈도우 머신)에서 벌어지는 많은 유저들의 인터랙션을 처리하는 것이 고민의 주제가 아니게 되었고, 인터랙션이 거의 없거나 아예 없는 개별 트래픽들을 보다 쉽고 유연하게 대응하는 것이 더 중요한 상황이 되었다.</p><p>리눅스의 개발 생태계, 가상화를 통해 얻게 되는 새로운 관점의 변화들은 너무 신선하다. 이제까지 내가 생각하지 못했던 방법들로 사고할 수 있게 된다. 훨씬 많은 개발자들과 선례들이 남긴 방대한 자료들이 인터넷에 가득하다. 약간 과장하자면 갈라파고스 섬에 살다가 뉴욕 맨하튼 거리로 나온 느낌.</p><p>이제 갓 일년차 수준이니 아직은 미숙하고 서툰 부분이 많지만, 앞으로 더 배우고 경험하고 놀라워 할 일이 많다는 점도 즐겁다. 연초에 리눅스 전환을 결정하지 않았다면 이 만큼의 새로운 자극이나 만족감이 있었을까.</p><p>이번 프로젝트는 개발 도중에 리눅스 환경 도입을 결정한 케이스이지만, 만약 지금 시점에 신규 프로젝트의 기술스택을 결정하고 아키텍처를 짜야 한다면… 이제까지의 프로젝트들과 얼마나 유사할 것인가. 아마 꽤나 다른 결정을 하게 될 것이다. 좀 다르게 말하면.. 꽤나 다른 결정도 이제는 할 수 있게 되었고, 여러가지 선택지를 마련해서 보다 적합한 솔루션을 고민해 고를 수 있게 되었고. 그 말은 내가 할 수 있는 것이 전보다는 좀 더 많아졌다는 말도 되지 않을까. 너무 논리적인 비약인가.</p><img src="/devnote/2025/11/11/the-best-choice-of-the-year/minipc.png" class=""><p>리눅스 생태계는 개발자 장난감(?)으로도 꽤나 재미가 있다. 지금 내 방에 띄워둔 vm 하이퍼바이저만 2대가 된다. 홈 네트워크, 홈 서버, 터미널 개발환경들 모든 것이 재미있다. 비 개발자들도 집에서 취미로 반려서버를 많이 가꾸신다는데. 그야말로 세상 건전한 취미가 아닌가.</p><p>아무튼 다시 생각해봐도 올 해의 최고의 결정이었다. </p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/linux/">linux</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/11/11/the-best-choice-of-the-year/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>요즘의 취미 - 터미널?</title>
      <link>http://leafbird.github.io/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/</link>
      <guid>http://leafbird.github.io/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/</guid>
      <pubDate>Mon, 03 Mar 2025 06:34:59 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/screenshot.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;아니, 정말로요. 빈 말이 아니고요. &lt;/p&gt;
&lt;p&gt;만약에 요즘에 누군가와 사교적인 말하기를 하다가 취미가 무엇이냐는 질문을 받는다면, &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;요즘 터미널 꾸미는 것에 빠져있어요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;라고 대답할 것 같아요.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/screenshot.png" class=""><p>아니, 정말로요. 빈 말이 아니고요. </p><p>만약에 요즘에 누군가와 사교적인 말하기를 하다가 취미가 무엇이냐는 질문을 받는다면, </p><blockquote><p>요즘 터미널 꾸미는 것에 빠져있어요.</p></blockquote><p>라고 대답할 것 같아요.</p><span id="more"></span><h3 id="터미널이요-…-버스터미널"><a href="#터미널이요-…-버스터미널" class="headerlink" title="터미널이요? … 버스터미널?"></a>터미널이요? … 버스터미널?</h3><p>여기서부터.. 너무 개발자스러운 주제가 되어버리겠죠. 근데 정말로 요즘은 시간만 나면 터미널을 열고 한참을 집중하고 있습니다. </p><p>연초에 회사 프로젝트에서 docker와 k8s 도입이 논의되면서부터 리눅스와 터미널 환경을 찾아보게 되었습니다.</p><p>그 때부터 UI가 없는 터미널 환경에 좀 익숙해져야 겠다는 생각으로 정보를 찾아보기 시작했습니다. </p><p>그러다 neovim을 설정하게 되고… fzf, yazi, lazygit, lazydocker 같은 TUI(Terminal User Interface) 도구를 접하게 되고 한참을 빠져들고 있습니다.</p><h3 id="요즘은-알아보다-막히는-건-AI가-다-해결해줍니다"><a href="#요즘은-알아보다-막히는-건-AI가-다-해결해줍니다" class="headerlink" title="요즘은 알아보다 막히는 건 AI가 다 해결해줍니다."></a>요즘은 알아보다 막히는 건 AI가 다 해결해줍니다.</h3><p>낮선 환경을 처음 접하면 아주 사소한 것을 몰라 한참을 삽질하는 경우를 많이 겪게 됩니다. </p><p>하지만 요즘은 대 AI의 시대. 에러가 왜 발생했고 어떻게 해결해야 하는지 ai agent들이 너무 잘 알려줍니다. </p><p>심지어 <a href="https://www.warp.dev/">warp</a>같은 터미널의 사용 경험은 말할 것도 없이 놀랍습니다. </p><img src="/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/warp.png" class=""><p>warp는 ai agent가 내장된 터미널입니다. 한동안 mac, linux에서만 사용 가능했지만 얼마전에 windows 버전도 출시되었습니다.</p><p>이런 세상이 된 덕분에 터미널 환경을 익혀가는 것이 좀 더 수월하고 재미있게 느껴집니다. </p><h3 id="neovim에-깃허브-코파일럿도-정식으로-지원됩니다"><a href="#neovim에-깃허브-코파일럿도-정식으로-지원됩니다" class="headerlink" title="neovim에 깃허브 코파일럿도 정식으로 지원됩니다."></a>neovim에 깃허브 코파일럿도 정식으로 지원됩니다.</h3><img src="/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/github-copilot.png" class=""><p>깃헙 코파일럿이 <code>neovim</code> 도 공식적으로 지원하는 것을 알고 있었나요?</p><p>GUI 환경에서면 그렇겠거니 싶은데, 터미널에서 copilot이 동작하는 것을 보고 있으면 정말로 놀랍습니다.</p><p>그 옛날 대학고 시스템 프로그래밍 수업 시절에 만져봤던 터미널 환경과 지금은 엄청난 차이가 있습니다. </p><p>유튜브에 자료도 충분하고, 깃허브에 공유되는 설정도 충분하고. ai agent도 너무 든든하게 도와주고. </p><p>세상이 많이 변했습니다. </p><p>오늘도 터미널 설정하러 갑니다. </p><h3 id="see-also"><a href="#see-also" class="headerlink" title="see also"></a>see also</h3><ul><li><a href="https://www.youtube.com/watch?v=KpudmVmMWx4">https://www.youtube.com/watch?v=KpudmVmMWx4</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/terminal/">terminal</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/powershell/">powershell</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/zsh/">zsh</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/neovim/">neovim</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[slackbot] 빌드머신 점검하다가 문득 봇을 짜보았다</title>
      <link>http://leafbird.github.io/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/</guid>
      <pubDate>Sun, 02 Feb 2025 05:24:14 GMT</pubDate>
      
      <description>&lt;p&gt;회사에서 빌드머신으로 사용중인 맥미니 장비들은 주기적으로 몇가지 관리가 필요하다.&lt;/p&gt;
&lt;p&gt;최근에 유니티6로 엔진 업데이트한 이후 빌드머신에 갖가지 이슈들이 생기면서 디스크 용량 체크를 해보던 중이었다.&lt;/p&gt;
&lt;img src=&quot;/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_00.png&quot; class=&quot;&quot; width=&quot;500&quot;&gt;

&lt;p&gt;&lt;code&gt;이거 코드 작업 조금만 하면 만들 수 있겠다&lt;/code&gt;는 생각이 들었고, 미루면 아마 영영 실천으로 옮기지 않게 될 것 같아 생각난 김에 바로 만들었다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>회사에서 빌드머신으로 사용중인 맥미니 장비들은 주기적으로 몇가지 관리가 필요하다.</p><p>최근에 유니티6로 엔진 업데이트한 이후 빌드머신에 갖가지 이슈들이 생기면서 디스크 용량 체크를 해보던 중이었다.</p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_00.png" class="" width="500"><p><code>이거 코드 작업 조금만 하면 만들 수 있겠다</code>는 생각이 들었고, 미루면 아마 영영 실천으로 옮기지 않게 될 것 같아 생각난 김에 바로 만들었다.</p><span id="more"></span><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><p>처음엔 ssh 연결로 커맨드를 실행해서 장비마다 <code>df -h</code> 결과를 받아오고 있었다. 그러다 세 대 쯤하다보니, 서버 주소만 다르고 동일한 커맨드를 반복 실행하고 있길래, 파워쉘에서 loop를 돌아 output을 수집하도록 스크립트를 작성해 돌렸다. </p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_01.png" class=""><p>그리고는 내가 이걸 눈으로 읽어서 엑셀에 수작업으로 정리해 팀원들에게 공유했다.<br>다음에 동일한 작업을 해야 할 때, 파워쉘 스크립트를 재사용할 수 있도록 정리해서 vcs에 올렸다. </p><p>근데 만약 다음에 디스크 공간 확인을 해야 할 때, 다른 멤버가 이 스크립트를 사용하려면 ssh 키 설정도 되어 있어야 하고, 스크립트 실행 환경도 잘 맞아야 하고. 혹시 제대로 실행되지 않으면 디버깅도 해야 할거고.. 뭔가 매끄럽지 않을 것 같은 생각이 들었다. 그리고 프로그래머가 아니면 애초에 엄두도 못 낼 일이다. 그래서 그냥 누구나 확인할 수 있게 팀 내 메신저로 쓰는 슬랙에 기능으로 만들어 붙이면 좋겠다고 생각했다.</p><h2 id="slackbot"><a href="#slackbot" class="headerlink" title="slackbot"></a>slackbot</h2><p>slack bot은 이슈트래커 연동 등 이미 다른 용도로 만들어 사용중인 실행파일이 있다. 새로운 기능 추가도 용이하도록 어느정도 준비도 되어 있다. <code>필요한 건 의지 뿐이다. 지금 마음 먹었을 때 바로 해야 한다.</code> 오늘이 지나기 전에 기능을 완성해서 릴리즈 하고 싶었다. </p><p>슬랙봇이 떠있는 장비에서 ssh 키를 생성해 모든 빌드머신에 등록해주었다. 슬랙봇은 윈도우 2019에서 실행중인데, 이번에 여기에도 openssh 서버를 열고 ssh로 접속해서 설정을 진행했다. 나중엔 슬랙봇 실행 os 자체도 linux로 변경하면 좋겠다. </p><p>ssh 명령으로 <code>df -h | grep -e ....</code>를 실행하고 결과를 파싱하는 건 어렵지 않게 진행됐다. C# 참 좋은 언어인데, 사람들이 많이 모르는 것 같다. </p><p>그리고 markup? 출력은 몇 번의 삽질 끝에, 최종의 형태로 다듬었다. 이런 작업도 참 재미있다. 나는 서버 말고 클라이언트 개발을 했어도 참 잘했을거야. 아무도 칭찬 해주지 않으니까 이럴 때 내가 실컷 칭찬해준다. 잘한다 아주.</p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_02.png" class="" width="500"><p>최종 형태도 조금 아쉽긴 하다. 오와 열이 딱 맞지 않아. slack api의 block kit에서 테이블 형태 레이아웃을 지원해주면 좋을텐데 그런게 없다.<br>나름대로 지금 표현할 수 있는 수준에서 최선을 다해 보았다.<br>머신별로 서로 다른 디스크의 전체 크기가 눈으로 쉽게 들어오게 하고 싶었고, 용량 대비 사용량이 어느 정도인지도 한 눈에 들어오게 하고 싶었다.</p><p>다시 한 번 감상해보는 최종 결과물. </p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_00.png" class="" width="500"><h2 id="ansible을-쓰면-좀-더-좋았을까"><a href="#ansible을-쓰면-좀-더-좋았을까" class="headerlink" title="ansible을 쓰면 좀 더 좋았을까?"></a>ansible을 쓰면 좀 더 좋았을까?</h2><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/ansible_logo.png" class="" width="500"><p>최근데 linux 진영의 생태계를 뒤늦게 살펴보고 있다. 이런 식으로 여러 장비에 수행하는 공통 작업은 주로 ansible을 통해 처리하는 듯 하다. ansible은 알게 된지 얼마 되지 않아 조만간 좀 더 깊이 공부할 생각이다. </p><p>ansible을 썼다면 결과물이 좀 더 좋았을까. </p><p>아니라는 생각이 들어서 슬랙봇으로 작업을 했다. ansible이 정확히 어디까지 지원해줄 수 있을지는 모르지만, 프로그래머가 아닌 직군의 팀원들도 명령을 수행하고 결과를 확인하기에는 슬랙봇으로 붙여두는 것보다 더 좋을 수 없다고 생각했다. 혹여나 ansibble 공부해보고 개선될만한 여지가 있다면 그 때 다시 수정하는 것도 나쁘지 않겠다. </p><h2 id="Know-how"><a href="#Know-how" class="headerlink" title="Know-how"></a>Know-how</h2><p>요즘은 기능을 구현하는 방법을 알아내는 것은 아주 쉬운 일이 되었다. 유튜브도 GPT도 원하는 질문의 대답을 너무 빠르게 친절하게 알려준다. </p><p><code>어떻게 하면 만들 수 있지?</code>하는 호기심은 실천의 원동력을 제공해준다. 모르는 것을 알고 싶다는 마음이 의지를 만들고, 그 때문에 책과 자료를 찾으며 공부를 하게 된다. </p><p>하지만 요즘은 그 해답에 너무나 빠르게 접근한다. 방법을 알아내는 동안 얻게되는 부수적인 지식도 없고, 이 산인지 저 산인지 몰라 일단 헤딩해보는 여러가지 다른 삽질들도 없다. GPT는 (거의) 정확한 정답을 알려주고, 질문만 잘하면 거의 바로 쓸 수 있는 코드도 작성해준다. </p><p>방법을 알아내고 나면 동기가 갑자기 떨어진다. <code>아~ 나 그거 할 줄 알아. 요래요래 하는거지?</code> 그럼 더이상 뭔가를 알고 싶다는 흥미는 급격히 떨어지고, 다시 유튜브와 인스타를 열고 무한 도파민의 세상으로 다이브 하게된다. 여기가 프로그래머 성장을 막는 중요한 고비라는 생각이 든다. </p><p>머리에서 원리를 깨우친 것과, 실제로 손끝에서 코드를 만들어 결과물을 내는 것에는 엄청난 차이가 있다. 막상 해보고 나서야 현실과 생각이 다르다는 것을 깨닫는 경우도 많이 있다. 돌아가는 코드를 직접 만들어 보기 전에는 내 생각을 완벽히 검증할 방법이 달리 있을까. </p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_03.png" class=""><p>그래서 만들었다. 오늘이 지나기 전에 만들어야 한다고 생각했다. 아무도 시키는 사람 없었지만 해야 한다고 생각했다. 하루가 넘긴 했지만 (완성 스샷을 보면 시간이 12:34…) 그래도 만들었다.</p><p>눈에 띄는 변화는 없을지 모르지만. 나는 오늘 다시 조금 성장했다고 생각한다. </p><p>잘했다. 아주.<br>You did a great job.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/slackbot/">slackbot</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/ssh/">ssh</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[pwsh] PsFzf가 프로필 로딩을 너무 느리게 만든다</title>
      <link>http://leafbird.github.io/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/</guid>
      <pubDate>Sat, 01 Feb 2025 04:45:31 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/psfzf_00.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;매번 터미널을 열 때마다 2 ~ 3초가 걸리는 것은 부담스럽다. &lt;/p&gt;
&lt;p&gt;방법을 찾아야 한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/psfzf_00.png" class=""><p>매번 터미널을 열 때마다 2 ~ 3초가 걸리는 것은 부담스럽다. </p><p>방법을 찾아야 한다.</p><span id="more"></span><p>기존에 사용하던 프로필은 아래와 같다. </p><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> init pwsh <span class="literal">--config</span> <span class="string">&quot;<span class="variable">$env:POSH_THEMES_PATH</span>\atomic.omp.json&quot;</span> | <span class="built_in">Invoke-Expression</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행시간이 너무 길어서 제거</span></span><br><span class="line"><span class="comment"># neofetch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure posh-git module is installed and loaded</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> PsFzf)) &#123;</span><br><span class="line">    <span class="built_in">Install-Module</span> <span class="literal">-Name</span> PsFzf <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">Invoke-FzfTabCompletion</span> &#125;</span><br><span class="line"><span class="built_in">Set-PsFzfOption</span> <span class="literal">-TabExpansion</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># replace &#x27;Ctrl+t&#x27; and &#x27;Ctrl+r&#x27; with your preferred bindings:</span></span><br><span class="line"><span class="built_in">Set-PsFzfOption</span> <span class="literal">-PSReadlineChordProvider</span> <span class="string">&#x27;Ctrl+t&#x27;</span> <span class="literal">-PSReadlineChordReverseHistory</span> <span class="string">&#x27;Ctrl+r&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure posh-git module is installed and loaded</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> posh<span class="literal">-git</span>)) &#123;</span><br><span class="line">    <span class="built_in">Install-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Import-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span></span><br></pre></td></tr></table></figure><p>기존에도 이미 간지를 위해 호출하던 <code>neofetch</code>를 시간이 너무 오래 걸리는 문제 때문에 포기하고 있었는데</p><p>이제 다른 처리만 해도 너무 답답한 로딩시간이 되었다. </p><h3 id="원인-확인"><a href="#원인-확인" class="headerlink" title="원인 확인"></a>원인 확인</h3><p>우선은 각 줄마다 <code>Write-Host</code> 찍으면서 수행시간을 확인해보았다. Import-Module이나 Get-Module이 오래 걸리는게 아닐까 생각했는데</p><p>가장 오래 걸리는 것은 line 11, <code>Set-PSReadLineKeyHandler -Key Tab -ScriptBlock &#123; Invoke-FzfTabCompletion &#125;</code> 이었다.</p><p>PsFzf는 명시적으로 <code>Import-Module</code>하지 않더라도, fzf관련 기능이 처음 호출되는 순간 자동으로 모듈이 로드된다. </p><p>line 11이 그 자체로 오래 걸리는 것이 아니라, 가장 처음 수행하는 fzf 설정이기 때문에 implicit하게 모듈을 임포트하는 시간이 발생했기 때문이다. 실제로 앞에서 미리 명시적으로 <code>Import-Module</code>을 수행하면 로딩시간이 줄어든다.</p><h3 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h3><p>해결이라기 보단 타협에 가까운데, 매번 초기화 하지 않는 대신 필요한 경우 쉽게 초기화할 수 있게 준비만 해두는 식으로 처리했다.</p><ul><li>매번 터미널이 뜰 때마다 모듈을 임포트하지 않게 한다. </li><li>대신 필요한 경우 설정 함수를 불러 간단하게 셋업되도록 한다.</li></ul><p>변경된 스크립트는 아래와 같다. </p><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> init pwsh <span class="literal">--config</span> <span class="string">&quot;<span class="variable">$env:POSH_THEMES_PATH</span>\atomic.omp.json&quot;</span> | <span class="built_in">Invoke-Expression</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$script:enableFzf</span> = <span class="variable">$false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Enable-Fzf</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$script:enableFzf</span>) &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;Fzf가 이미 활성화되어 있습니다.&quot;</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$script:enableFzf</span> = <span class="variable">$true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$script:stopwatch</span> = [<span class="type">System.Diagnostics.Stopwatch</span>]::StartNew()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> PsFzf)) &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;PsFzf 모듈을 설치합니다...&quot;</span></span><br><span class="line">        <span class="built_in">Install-Module</span> <span class="literal">-Name</span> PsFzf <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;탭 완성을 위한 설정을 추가합니다...&quot;</span></span><br><span class="line">    <span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">Invoke-FzfTabCompletion</span> &#125;</span><br><span class="line">    <span class="built_in">Set-PsFzfOption</span> <span class="literal">-TabExpansion</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Ctrl+t / Ctrl+r 키 입력을 설정합니다...&quot;</span></span><br><span class="line">    <span class="built_in">Set-PsFzfOption</span> <span class="literal">-PSReadlineChordProvider</span> <span class="string">&#x27;Ctrl+t&#x27;</span> <span class="literal">-PSReadlineChordReverseHistory</span> <span class="string">&#x27;Ctrl+r&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure posh-git module is installed and loaded</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> posh<span class="literal">-git</span>)) &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;posh-git 모듈을 설치합니다...&quot;</span></span><br><span class="line">        <span class="built_in">Install-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;posh-git 모듈을 로드합니다...&quot;</span></span><br><span class="line">    <span class="built_in">Import-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Fzf 활성화가 완료되었습니다.&quot;</span></span><br><span class="line">    <span class="variable">$script:stopwatch</span>.Stop()</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;소요 시간: <span class="variable">$</span>(<span class="variable">$script:stopwatch</span>.ElapsedMilliseconds)ms&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oh-my-posh 초기화 외에는 모두 함수로 묶어두기만 했다. </p><p>터미널 사용 도중 fzf 기능이 필요한 경우는 <code>Enable-Fzf</code> 함수를 호출한다. history에 들어 있으므로 <code>ena + →</code>만 입력해도 호출 가능하다. </p><p>file scope의 변수를 추가해서 여러 번 초기화 함수를 부를 땐 중복 실행하지 않게 막았다.</p><img src="/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/psfzf_01.png" class=""><p>짠. 이제 새 터미널 창 여는 시간이 쾌적해졌다 :)</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/powershell/">powershell</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/fzf/">fzf</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# in 키워드 정리</title>
      <link>http://leafbird.github.io/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/</link>
      <guid>http://leafbird.github.io/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/</guid>
      <pubDate>Tue, 01 Oct 2024 07:45:38 GMT</pubDate>
      
      <description>&lt;p&gt;C#에서 메서드를 정의할 때 &lt;code&gt;in&lt;/code&gt; 키워드를 사용하면 call by value 가 아닌 call by reference로 동작하게 만들어줍니다. 그래서 주로 구조체(value type)를 복사 없이 참조로 넘길 때 유용하지요. &lt;/p&gt;
&lt;p&gt;참조 타입의 매개변수에 in 키워드를 쓰는 건 어떤 효과가 있을까요? generic parameter를 정의할 때도 in 키워드가 붙는 경우도 있던데 어떤 의미일까요?&lt;br&gt;이참에 한 번 정리해 보겠습니다. &lt;/p&gt;
&lt;img src=&quot;/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/image.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>C#에서 메서드를 정의할 때 <code>in</code> 키워드를 사용하면 call by value 가 아닌 call by reference로 동작하게 만들어줍니다. 그래서 주로 구조체(value type)를 복사 없이 참조로 넘길 때 유용하지요. </p><p>참조 타입의 매개변수에 in 키워드를 쓰는 건 어떤 효과가 있을까요? generic parameter를 정의할 때도 in 키워드가 붙는 경우도 있던데 어떤 의미일까요?<br>이참에 한 번 정리해 보겠습니다. </p><img src="/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/image.png" class=""><span id="more"></span><p>위쪽에 스샷으로 붙인 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in">learn.microsoft.com의 문서</a>에는 다섯 가지 쓰임새를 소개합니다.</p><ol><li>제네릭 타입 매개변수에서 사용</li><li>메서드 매개변수에서 값 대신 참조를 전달하도록 지정</li><li>foreach 문에서 사용</li><li>linq의 from 절에서 사용</li><li>linq의 in 절에서 사용</li></ol><p>이 중에서 3, 4, 5는 이번 포스팅의 관심사가 아닙니다. 2번을 먼저 정리하고, 그 다음 1번도 살펴보겠습니다. </p><h2 id="구조체를-인자로-넘길-때-in-사용"><a href="#구조체를-인자로-넘길-때-in-사용" class="headerlink" title="구조체를 인자로 넘길 때 in 사용"></a>구조체를 인자로 넘길 때 in 사용</h2><p><code>in</code> 키워드를 사용하여 전달받은 매개변수는 수정이 불가한 읽기 전용 참조입니다. 사이즈가 큰 구조체를 readonly로 전달할 때 사용하면 성능상의 이득을 볼 수 있습니다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> Point point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// point.X = 10; // 컴파일 에러. 값을 수정할 수 없습니다.</span></span><br><span class="line">    Console.WriteLine(point.X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point point = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">Print(point);</span><br></pre></td></tr></table></figure><p>value type 모두에 해당하는 이야기 이지만, 8byte를 넘지 않는 premitive type이나 작은 구조체인 경우에는 성능상의 이득은 없습니다.</p><h2 id="참조-타입에-in을-붙였을-때-차이점"><a href="#참조-타입에-in을-붙였을-때-차이점" class="headerlink" title="참조 타입에 in을 붙였을 때 차이점"></a>참조 타입에 in을 붙였을 때 차이점</h2><p>매개변수가 참조타입일 때 in 키워드를 사용하는 것은 어떤 효과가 있을까요? </p><h3 id="1-참조-변수가-readonly-입니다"><a href="#1-참조-변수가-readonly-입니다" class="headerlink" title="1. 참조 변수가 readonly 입니다."></a>1. 참조 변수가 readonly 입니다.</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> List&lt;<span class="built_in">int</span>&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    list.Add(<span class="number">10</span>); <span class="comment">// 컨테이너에 값을 넣을 수는 있습니다.</span></span><br><span class="line">    list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(); <span class="comment">// CS8331: 변수에 새로운 객체를 할당할 수는 없습니다.</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(list.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 C++의 <code>std::vector&lt;int&gt;</code>로 비유할 때, <code>list</code>가 <code>const std::vector&lt;int&gt;&amp;</code>와 같은 의미일 거라고 생각하는 것이 흔히 하는 실수입니다.<br>하지만 <code>std::vector&lt;int&gt; const *</code>와 같이 동작합니다. <code>list</code>컨테이너에 값을 넣을 수는 있지만, <code>list</code> 변수 자체를 다른 객체로 바꿀 수는 없습니다.</p><p>그러니 C#과 꼭 어울리는 표현은 아니지만, 참조형 매개변수에 in 키워드를 쓰는 것은 <code>포인터 변수를 const로 만들어주는 효과가 있다</code>고 말할 수 있습니다.<br>실전에선 이게 그렇게 의미있게 쓰이는 일이 많지는 않을 듯 합니다.</p><h3 id="2-호출하는-곳에서-암시적-변환이-발생하지-않도록-합니다"><a href="#2-호출하는-곳에서-암시적-변환이-발생하지-않도록-합니다" class="headerlink" title="2. 호출하는 곳에서 암시적 변환이 발생하지 않도록 합니다."></a>2. 호출하는 곳에서 암시적 변환이 발생하지 않도록 합니다.</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> IList&lt;<span class="built_in">int</span>&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(list.Count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Print(list); <span class="comment">// ok</span></span><br><span class="line">Print(<span class="keyword">in</span> list); <span class="comment">// error CS1503: 1 인수: &#x27;in System.Collections.Generic.List&lt;int&gt;&#x27;에서 &#x27;in System.Collections.Generic.IList&lt;int&gt;&#x27;(으)로 변환할 수 없습니다.</span></span><br><span class="line">Print(<span class="keyword">in</span> list <span class="keyword">as</span> IList&lt;<span class="built_in">int</span>&gt;); <span class="comment">// error CS8156: 식은 참조로 전달되거나 반환될 수 없으므로 이 컨텍스트에서 사용할 수 없습니다.</span></span><br></pre></td></tr></table></figure><p>호출하는 곳에서 <code>in</code>을 적지 않으면 문제가 없는데, <code>in</code>을 적으면 컴파일 에러가 발생합니다.<br>이는 <code>List&lt;int&gt;</code>가 <code>IList&lt;int&gt;</code>로 암시적 변환이 가능하지만, <code>in</code> 키워드를 사용하면 암시적 변환이 일어나지 않기 때문입니다.<br>이걸 암시적 변환(implicit casting)이라고 봐야 할지 모르겠습니다. <code>List&lt;int&gt;</code>는 <code>IList&lt;int&gt;</code> 인터페이스를 구현했기 때문에, upcasting인 셈이지만, in 키워드를 사용하면 이것도 불가능해집니다.<br><code>as</code> 키워드를 써서 명시적으로 변환해 주어도 에러를 피할 수 없습니다. 이 땐 ref, out 키워드에 expression을 참조로 전달할 수 없는 것과 같은 이유로 컴파일 에러가 발생합니다.<br>아예 다른 타입으로 변환하는 ‘찐’ 암시적 변환을 막아주는 예제는 아래와 같습니다. 아래 것은 좀 더 그럴싸 하지요. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">short</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">Print(<span class="keyword">value</span>); <span class="comment">// ok</span></span><br><span class="line">Print(<span class="keyword">in</span> <span class="keyword">value</span>); <span class="comment">// error CS1503: 1 인수: &#x27;in short&#x27;에서 &#x27;in int&#x27;(으)로 변환할 수 없습니다. </span></span><br></pre></td></tr></table></figure><h2 id="제네릭-타입-매개변수에서-사용"><a href="#제네릭-타입-매개변수에서-사용" class="headerlink" title="제네릭 타입 매개변수에서 사용"></a>제네릭 타입 매개변수에서 사용</h2><p>약간은 벗어나는 이야기 일 수도 있지만, in 키워드에 대해 정리하는 김에 같이 적어봅니다.</p><p>C#에서 제네릭 타입 매개변수에 in 키워드를 사용하는 것은 공변성(covariance)과 반공변성(contravariance)의 개념과 관련이 있습니다. in 키워드는 반공변성을 나타내며, 이는 특정 타입 매개변수가 제네릭 타입의 입력으로만 사용될 수 있음을 의미합니다.</p><h3 id="공변성-covariance-vs-반공변성-contravariance"><a href="#공변성-covariance-vs-반공변성-contravariance" class="headerlink" title="공변성(covariance) vs 반공변성(contravariance)"></a>공변성(covariance) vs 반공변성(contravariance)</h3><ul><li>공변성: 제네릭 타입에서 반환되는 값의 타입을 더 구체적인 하위 타입으로 사용할 수 있게 하는 것. out 키워드로 표현됩니다.</li><li>반공변성: 제네릭 타입에서 파라미터로 전달하는 값을 더 일반적인 상위 타입으로 사용할 수 있게 하는 것. in 키워드로 표현됩니다.</li></ul><h3 id="in-키워드의-효과"><a href="#in-키워드의-효과" class="headerlink" title="in 키워드의 효과"></a><code>in</code> 키워드의 효과</h3><p>in 키워드를 사용하면 제네릭 타입 매개변수가 반공변성을 가지게 됩니다. 즉, 더 일반적인 타입의 객체를 사용할 수 있습니다. 이때 해당 타입 매개변수는 입력으로만 사용되며, 반환값으로는 사용할 수 없습니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComparer</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">T x, T y</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnimalComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">Animal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">Animal x, Animal y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 단순 비교</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IComparer&lt;Dog&gt; dogComparer = <span class="keyword">new</span> AnimalComparer(); <span class="comment">// 허용됨 (반공변성)</span></span><br></pre></td></tr></table></figure><p>위 코드에서 <code>IComparer&lt;in T&gt;</code> 인터페이스는 <code>T</code> 타입 매개변수를 입력으로만 사용하므로, <code>IComparer&lt;Animal&gt;</code>을 <code>IComparer&lt;Dog&gt;</code>에 할당할 수 있게 됩니다.<br>간단하게 여기까지만. 공변성과 반공변성에 대한 이야기는 다음에 기회가 되면 다른 포스팅에서 정리해보죠.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li><code>in</code> 키워드는 주로 크기가 큰 값 타입의 매개변수를 읽기 전용 참조로 전달할 때 사용합니다.</li><li>참조 타입의 매개변수에 <code>in</code> 키워드를 사용하면 변수의 값을 readonly로 만들어줍니다.</li><li>호출하는 곳에서 <code>in</code> 키워드를 사용하면 암시적 변환이 발생하지 않습니다.</li><li>제네릭 타입 매개변수에 <code>in</code> 키워드를 사용하면 반공변성을 가지게 됩니다.</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/in-parameter-modifier">in (C# 참조)</a></li><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-7-2#in-parameters">C# 7.2의 in 매개 변수</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/C/">C#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/NET/">.NET</category>
      
      
      <comments>http://leafbird.github.io/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>한 번 더 나에게 질풍같은 용기를</title>
      <link>http://leafbird.github.io/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/</link>
      <guid>http://leafbird.github.io/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/</guid>
      <pubDate>Sat, 21 Sep 2024 10:17:16 GMT</pubDate>
      
      <description>&lt;p&gt;23년 9월부터 24년 5월까지, 8개월 정도 열심히 커밋을 남겼습니다.&lt;br&gt;그러고는 한참 손을 놓고 있었는데, 다시 한 번 시작해보려고 합니다. &lt;/p&gt;
&lt;img src=&quot;/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/github_streak.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>23년 9월부터 24년 5월까지, 8개월 정도 열심히 커밋을 남겼습니다.<br>그러고는 한참 손을 놓고 있었는데, 다시 한 번 시작해보려고 합니다. </p><img src="/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/github_streak.png" class=""><span id="more"></span><h3 id="수단이-목적이-되지-않게"><a href="#수단이-목적이-되지-않게" class="headerlink" title="수단이 목적이 되지 않게"></a>수단이 목적이 되지 않게</h3><p>꼭 커밋이 아니어도 말이죠. 무언가를 습관화 하기 위해 꾸준히 수행한다는 것이 그리 쉬운 일은 아닙니다. 토이 프로젝트를 처음 시작하면서 열정이 가득할 때에는 그래도 힘들다는 느낌이 덜한데, 프로젝트의 마지막까지 그 열정을 계속 유지하기도 쉽지 않고요. </p><p>5개월.. 6개월.. 제법 시간이 지나고 나니 버거운 느낌을 받는 날이 많았습니다. streak를 끊고 싶지 않아서, 단지 commit을 위한 commit을 올리는 날도 생겼습니다. 그래도 이 목표 덕분에 하루에 한 번은 IDE를 열게 되니, 아예 안 하는 것보단 낫다는 생각으로 진행했습니다만.. 회사 업무가 바빠지면서 어느 순간 놓아버리고 말았네요. </p><blockquote><p>특정한 행동을 추적하는 것의 문제는 우리가 본래의 목적이 아니라 숫자에 휘둘리게 된다는 점이다. 성공을 분기별 수입으로 측정한다면 판매, 수익, 신용거래 같은 수치를 활용할 것이다. 속성 다이어트, 해독 주스, 지방 감소 약물 등을 이용할 때 몸무게가 줄어드는 것으로 성공을 측정한다면 ‘낮은 숫자’를 추구하게 된다. 인간의 마음은 하고 있는 게임이 무엇이든지 ‘이기고’ 싶어 하기 때문이다. 이런 위험은 우리 삶에서 자주 나타난다. 우리는 의미 있는 일을 해낸 것보다 얼마나 오랜 시간 일했는지에 초점을 맞춘다. 얼마나 건강해졌느냐보다는 1,000보 걸었느냐를 더 신경쓴다. 배움, 호기심, 비판적인 사고를 강조하기보다는 규격화된 시험을 위한 교육을 한다. 우리는 측정할 수 있는 것을 믿는다. 문제는 잘못된 측정 도구를 선택했을 때 잘못된 행동을 하게 된다는 점이다. </p><p>제임스 클리어, &lt;아주 작은 습관의 힘&gt;</p></blockquote><h3 id="숫자-보다는-성장에-초점을-맞추기"><a href="#숫자-보다는-성장에-초점을-맞추기" class="headerlink" title="숫자 보다는 성장에 초점을 맞추기"></a>숫자 보다는 성장에 초점을 맞추기</h3><p>이번에는 streak count가 주는 동기부여는 굳이 받지 않아도 좋으니, 지난번처럼 숫자에 휘둘리지 말아야 겠다고 생각하고 있습니다. 회사 업무가 바쁘거나, 개인적으로 일이 생기면 한 두 번 놓칠 수도 있죠. 그보다 중요한 것은 <code>내가 꾸준하게 개발에 관심을 두고, 배우고, 습득하는 시간 자체를 내 삶의 일부로 만들고자 노력하는 것</code>입니다. 좋은 프로그래머가 되기 위해 노력을 쏟는 것은 꼭 commit이 아닐 수 있습니다. 다른 사람의 코드를 리뷰하는 것일 수도, 책이나 인터넷의 자료를 읽고 깨우치는 것일 수도, 문제의 해결을 위해 골똘히 생각하는 시간이 될 수도 있죠.<br>자신의 성장에 유익한 시간을 쌓아가고 있는지는 본인 스스로가 알고 있습니다. 거기에 측정 가능한 수치는 단지, 거들 뿐입니다. </p><h3 id="지난번엔-macOS-이번엔-windows"><a href="#지난번엔-macOS-이번엔-windows" class="headerlink" title="지난번엔 macOS, 이번엔 windows"></a>지난번엔 macOS, 이번엔 windows</h3><p>지난번에는 macOS와 vscode를 이용하는 환경을 우선적으로 선정했습니다. 맥북을 좀 더 활용해 보고 싶었고, vs가 아닌 IDE도 한 번 익숙해져 보려고 한 선택입니다.<br>이번에는 완전한 홈 구장, windows + vs2022 환경에서 개발을 진행합니다. 무거운 납주머니를 차고 있다 벗어던진 느낌이네요. 개발을 지속하기에도 한결 수월할 것으로 예상합니다. vscode는 LOC가 많지 않은 가벼운 로직은 상관 없는데… 점점 코드 양이 많아질 수록 디버깅 환경이 아쉬웠습니다. 이게 참.. vs2022를 쉽게 벗어날 수 없는 이유입니다. </p><p>요번에 다시 개인 공부를 진행하면서 배우는 내용들이 정리가 좀 된다면… 여기 블로그에 포스팅도 좀 할 수 있으면 좋겠네요. 개발자 블로그라고 만들어두고는 너무 글을 올리지 못해 민망하군요. 호호.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/daily-commit/">daily commit</category>
      
      
      <comments>http://leafbird.github.io/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo에 PR을 보냈습니다</title>
      <link>http://leafbird.github.io/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/</guid>
      <pubDate>Thu, 02 May 2024 04:34:55 GMT</pubDate>
      
      <description>&lt;p&gt;그리고 이번 &lt;a href=&quot;https://github.com/hexojs/hexo/releases/tag/v7.2.0&quot;&gt;7.2.0 릴리즈&lt;/a&gt;에 제가 보낸 수정사항도 반영 되었습니다&lt;/p&gt;
&lt;img src=&quot;/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/screenshot0.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>그리고 이번 <a href="https://github.com/hexojs/hexo/releases/tag/v7.2.0">7.2.0 릴리즈</a>에 제가 보낸 수정사항도 반영 되었습니다</p><img src="/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/screenshot0.png" class=""><span id="more"></span><p>이제, hexo의 새 컨트리뷰터가 되었네요 :) </p><img src="/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/screenshot1.png" class=""><p>외부 모듈에 PR을 보낸게.. 10년 만이네요. 오픈 소스에 기여하시는 분들이 새삼스레 존경스러워 집니다.</p><h3 id="수정한-내용-자체는-간단했습니다"><a href="#수정한-내용-자체는-간단했습니다" class="headerlink" title="수정한 내용 자체는 간단했습니다."></a>수정한 내용 자체는 간단했습니다.</h3><p>저는 hexo를 이용해 <a href="https://leafbird.github.io/devnote">개발용 블로그</a>와 <a href="https://leafbird.github.io/blog">개인용 블로그</a> 2개를 운용하고 있습니다. </p><p>일반적으로 1개의 블로그를 운영할 때에는 gh pages 주소가 https:&#x2F;&#x2F;개인아이디.github.io 같은 형식이 될텐데요.<br>저는 두 블로그를 나누기 위해서 <a href="https://leafbird.github.io/devnote">https://leafbird.github.io/devnote</a> , <a href="https://leafbird.github.io/blog">https://leafbird.github.io/blog</a> 처럼 서브 디렉토리가 추가로 덧붙은 url을 가지고 있어요. </p><p>근데 url이 이렇게 되면.. post_link라고, 블로그의 다른 포스팅을 링크하는 기능을 쓸 때 url을 제대로 만들어주지 못하더라고요. 그래서 간단히 문자열 처리를 보완하는 기능을 덧붙였습니다.</p><h3 id="십-년-전보다-많이-체계화된-PULL-MERGE-절차"><a href="#십-년-전보다-많이-체계화된-PULL-MERGE-절차" class="headerlink" title="십 년 전보다.. 많이 체계화된 PULL - MERGE 절차"></a>십 년 전보다.. 많이 체계화된 PULL - MERGE 절차</h3><p>십년 전에는 깃헙 액션도 없던 때입니다. 다른 사람에게서 pr이 날아오면 메인테이너가 그냥 눈으로 좀 읽고 merge 해주는 식이었지요. </p><p>이번에 PR 보낼 때보니 많은 것이 자동화 되어 있었습니다. </p><ul><li>일단 프로젝트의 지정 코딩 스타일에 맞도록 lint 자동 테스트를 통과해야 하고,</li><li>당연한 이야기지만 빌드가 가능해야 하고,</li><li>제가 추가한 기능을 테스트하는 단위 테스트 로직도 함께 추가를 해주어야 합니다.</li></ul><p>hexo는 ts로 되어있는데… ts를 다뤄본 적이 없어서 코드를 아주 능숙하게 쓰지는 못했네요 @.@…</p><p>직접 사용하다보니 불편한 점이 보여서 뜻하게 않게 PR까지 해보게 됐습니다.<br>요즘 깃허브의 시스템들 조금씩 접하게 되면서 부족한 식견을 넓히고 있습니다.<br>아직 업무에서는 vcs로 git을 사용해본 적이 없어서.. 항상 얉게만 사용하고 있거든요.</p><p>요번에 덕분에 좋은 경험을 했습니다 :) </p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/contributor/">contributor</category>
      
      
      <comments>http://leafbird.github.io/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>처음으로 접한 깃헙 액션</title>
      <link>http://leafbird.github.io/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/</link>
      <guid>http://leafbird.github.io/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/</guid>
      <pubDate>Thu, 09 Nov 2023 04:38:49 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/actions-graph.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;github actions 그거 뭐 별거냐고 대수롭지 않게 생각했었다.&lt;br&gt;근데 조금 들여다보니 자유도가 꽤나 높아서, 사람들이 정말 다양하게 활용하고 있다는 것을 알고는 흥미가 생겼다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/actions-graph.png" class=""><p>github actions 그거 뭐 별거냐고 대수롭지 않게 생각했었다.<br>근데 조금 들여다보니 자유도가 꽤나 높아서, 사람들이 정말 다양하게 활용하고 있다는 것을 알고는 흥미가 생겼다.</p><span id="more"></span><h2 id="MS-Developer-Korea에서-정리해둔-actions-소개-영상을-추천"><a href="#MS-Developer-Korea에서-정리해둔-actions-소개-영상을-추천" class="headerlink" title="MS Developer Korea에서 정리해둔 actions 소개 영상을 추천"></a>MS Developer Korea에서 정리해둔 actions 소개 영상을 추천</h2><blockquote><p>CI&#x2F;CD 그거 알지. 나도 해봤어. 울 회사에도 있어. </p></blockquote><p>actions를 제대로 알아보기 전의 내가 딱 이 정도 생각이었다. 그냥 <code>깃헙이 원래 코드 저장소를 제공하니까, 코드 올려둔 김에 빌드도 같이 돌리라고 추가기능 제공하는구나</code> 하는 느낌. 지금 일단 업무적으로는 버전 관리를 git으로 하고 있지 않기 때문에 딱히 관심이 크지 않기도 했다.</p><p>최근에 토이 프로젝트를 다시 시작하면서 actions도 조금 알아보고 있다. 한국 ms에서 만든 youtube 영상에 기본 개념 설명이 아주 잘 되어있다. actions를 처음 알아보려는 사람이라면 정주행을 권한다. 영상을 보고 나면 <code>workflow</code>, <code>job</code>, <code>step</code>, <code>action</code> 각 단계별 구성을 빠르게 잡을 수 있고, 시리즈 후반부에는 actions를 빌드나 배포가 아닌 다른 용도로 활용하는 예제 2가지를 소개하고 있다.</p><p><a href="https://www.youtube.com/watch?v=MhGpFunlmMQ&list=PLDZRZwFT9Wkt19Ox35Ir2A7CyNIWG96Nm">MS Developer Korea : Github Actions로 개발 주기 자동화</a></p><img src="/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/intro.png" class=""><p>이 영상을 보고 나면</p><ul><li>main branch는 직접 commit하지 못하게 막아둔 채로 여러 사람이 협업할 때 github을 활용하는 방법을 볼 수 있다. </li><li>pull-request를 제출한 후, 다른 사람이 리뷰를 마치고 승인했을 때, actions를 이용해서 PR에 라벨을 붙이는 예제를 볼 수 있다. (4-2)</li><li>이슈가 많이 쌓여서 관리가 필요할 때, actions를 이용해서 (라벨을 붙이면) 댓글을 달고 이슈를 닫는 예제를 볼 수 있다. (4-3)</li></ul><p>첫 번째 bullet에 적은 것처럼 main branch에는 보호 정책을 걸어두고 <code>PR - review - Merge</code>하는 흐름으로 협업하는 과정을 볼 수 있는 것도 흥미로웠다. git은 주로 개인 작업할 때 혼자서만 작업하다 보니까, commit하고 push하는거 말고는 다른 기능을 사용할 기회가 거의 없다. rebase, cherry-pick도 사용할 필요가 없어. 이 영상을 보고 branch protection rule을 어떻게 쓰는 건지 감을 잡았다.</p><h2 id="workflow를-처음-적용하면서-헤맸던-삽질들"><a href="#workflow를-처음-적용하면서-헤맸던-삽질들" class="headerlink" title="workflow를 처음 적용하면서 헤맸던 삽질들"></a>workflow를 처음 적용하면서 헤맸던 삽질들</h2><p>workflow의 문법이나 개념을 소개하기에는 이미 잘 정리된 자료들이 많이 있어서 굳이 여기에 반복할 필요는 없어 보인다. 이번에 nuget 패키지를 만들어 배포하는 workflow를 만들면서 뻘짓했던 요소들 간단히 몇가지만 정리해본다. </p><h4 id="repository가-개인-계정의-것이-아니라-organization의-소유인-경우"><a href="#repository가-개인-계정의-것이-아니라-organization의-소유인-경우" class="headerlink" title="repository가 개인 계정의 것이 아니라 organization의 소유인 경우"></a>repository가 개인 계정의 것이 아니라 organization의 소유인 경우</h4><p>packages에 파일을 올리려면 접근 권한이 필요하다. 개인 계정의 repo라면 <code>developers settings &gt; personal access tokens &gt; tokens(classic)</code>에서 발급하는 토큰을 이용하면 되는데, organization의 구성원들이 같이 공유할 수 있는 토큰 같은 개념은 없는 것 같다. 그냥 해당 repo에 접근 권한이 있는 개인이 발급한 personal token을 secret으로 등록해두고 같이 사용하게 하면 workflow를 실행하는 데에는 문제가 없다.</p><h4 id="release를-만들려면-token-외에도-권한-지정이-필요하다"><a href="#release를-만들려면-token-외에도-권한-지정이-필요하다" class="headerlink" title="release를 만들려면 token 외에도 권한 지정이 필요하다"></a>release를 만들려면 token 외에도 권한 지정이 필요하다</h4><p><a href="https://github.com/marketplace?type=actions">마켓플레이스</a>에서 검색해보면 <code>create release</code>해주는 actions가 많이 있다. 내가 사용한 것은 <a href="https://github.com/ncipollo/release-action">ncipollo&#x2F;release-action</a>이고 readme의 예시에도 설명된 내용이긴 한데, job 레벨에서 권한 지정을 해주어야 한다. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span> <span class="comment"># 이거 빼먹지 마세요... ㅜㅠ</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">ncipollo/release-action@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">artifacts:</span> <span class="string">&quot;release.tar.gz,foo/*.txt&quot;</span></span><br><span class="line">        <span class="attr">bodyFile:</span> <span class="string">&quot;body.md&quot;</span></span><br></pre></td></tr></table></figure><p>검색하다보면 permissions 설정이 없는 yml 예시도 많이 있는데, 왠지 권한 지정 문법은 나중에 추가된 것이 아닌가 싶다. 그 전에 만들어진 workflow들은 권한 지정 없이도 실행이 됐던 것 같고. 이거 빼먹고 issue 게시판에 글 올리는 사람이 나 말고도 많음.. </p><h2 id="추가로-공부할-것"><a href="#추가로-공부할-것" class="headerlink" title="추가로 공부할 것"></a>추가로 공부할 것</h2><p>지금은 <a href="https://github.com/StudioBside/Cs.Logging/blob/main/.github/workflows/nuget.yml">기본적인 nuget 패키지 배포</a> 정도 구성해봤는데, 좀 더 익숙해지려면 다른 활용을 몇가지 더 만들어봐야 할 듯 하다. actions를 미리 알았으면 지난달에 만들었던 <a href="https://github.com/leafbird/GameRankReader">모바일 게임 랭킹 순위 크롤러</a>도 깃헙에서 바로 실행&#x2F;저장하게 만들었을텐데, 그걸 몰랐네. 이거 수정하면서 좀 더 다루어봐야겠다.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://github.com/stjeong/XmlCodeGenerator/blob/master/.github/workflows/git-releases.yml">https://github.com/stjeong/XmlCodeGenerator/blob/master/.github/workflows/git-releases.yml</a> - 정성태님 repo에 있는 workflow 많이 참고했습니다. </li><li><a href="https://github.com/korea-dev-list/korea-dev-list.github.io/blob/main/.github/workflows/runner.yml">https://github.com/korea-dev-list/korea-dev-list.github.io/blob/main/.github/workflows/runner.yml</a> - workflow 활용하는 다른 예시. 정해진 시각에 실행되어 개발 블로그들의 새 글을 수집해 repo에 commit하고, github pages에 반영한다.</li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/workflow/">workflow</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/actions/">actions</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>oh-my-posh로 파워쉘 꾸미기</title>
      <link>http://leafbird.github.io/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</guid>
      <pubDate>Wed, 18 Oct 2023 23:54:03 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/win_terminal.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;지난번에 &lt;a href=&quot;/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/&quot; title=&quot;iTerm2 없이 맥 기본 터미널 꾸미기&quot;&gt;zsh을 꾸미고 나니&lt;/a&gt;, pwsh이 너무 허접해 보였다. 이런 것을 역체감이라고 하나.&lt;br&gt;어쩔 수 없지. 파워쉘도 꾸며줄 수 밖에.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/win_terminal.png" class=""><p>지난번에 <a href="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/" title="iTerm2 없이 맥 기본 터미널 꾸미기">zsh을 꾸미고 나니</a>, pwsh이 너무 허접해 보였다. 이런 것을 역체감이라고 하나.<br>어쩔 수 없지. 파워쉘도 꾸며줄 수 밖에.</p><span id="more"></span><h2 id="oh-my-posh-설치"><a href="#oh-my-posh-설치" class="headerlink" title="oh-my-posh 설치"></a>oh-my-posh 설치</h2><p>설치 자체는 어렵지 않고, 관련 정보도 검색으로 쉽게 찾을 수 있다. mac은 brew를 통해서, windows에서는 winget, choco, scoop등을 통해서 설치한다.<br>파워쉘 설정의 위치가 window와 macos가 서로 다르기 때문에 설치 스크립트에 약간 신경써줄 필요가 있음. 파워쉘의 <code>$PROFILE</code> 변수가 위치가 들어있으니까 파워쉘로 설치 동작을 작성해야 양쪽 os에 대응하기가 수월하다. </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dotfiles repository의 프로필 파일로 심볼릭 링크를 설정합니다.</span></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="variable">$profile</span> <span class="literal">-ItemType</span> SymbolicLink <span class="literal">-Value</span> <span class="variable">$sourcePath</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><p>전체 스크립트 파일은 <a href="https://github.com/leafbird/dotfiles">dotfiles</a>에 올려두었다.</p><p>동일한 테마를 사용해 mac에서 설정해 주었는데도, 프롬프트의 모양이 다르다. os별로 각각 디자인이 되어 있는 듯. 지금 사용하는 테마는 <a href="https://github.com/JanDeDobbeleer/oh-my-posh/blob/main/themes/atomic.omp.json">atomic</a>이다.</p><img src="/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/pwsh_in_macos.png" class=""><p>이미지에서 처음 프롬프트는 <code>agnoster</code> 테마를 쓰는 oh-my-zsh, 아래가 <code>atomic</code> mac 버전의 oh-my-posh이다.</p><h2 id="윈도우-로고-출력하기"><a href="#윈도우-로고-출력하기" class="headerlink" title="윈도우 로고 출력하기"></a>윈도우 로고 출력하기</h2><p>스크린샷에 있는 os 로고와 하드웨어 스펙 정보 출력을 위해 <code>neofetch</code>를 설치해 실행한다. 윈도우에서는 버전이 몇가지가 되는 듯 하고 각자 윈도우 로고 출력 모양이 다르다. 그 중에 scoop에서 설치하는 버전이 로고가 가장 예뻐서 이것으로 선택했다. 하지만 부팅 시간이 너무 오래 걸려서 평상시엔 비활성 해두었다. </p><h2 id="윈도우-터미널에-폰트-지정"><a href="#윈도우-터미널에-폰트-지정" class="headerlink" title="윈도우 터미널에 폰트 지정"></a>윈도우 터미널에 폰트 지정</h2><img src="/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/wt_font_broken.png" class=""><p>240406: 알리 세일 기간에 저렴한 윈도우 미니 PC를 구매해서 세팅. dotfiles 적용하면 폰트 깨짐. <code>Hack</code> 폰트 사용하게 지정해줘도 복구되지 않음. <code>Hack Nerd Font</code>를 사용해야 한다. 설정에 지정할 때 폰트 이름이 <code>Hack Nerd Font</code> 까지 모두 포함인 것도 주의 필요.</p><ul><li>hack nerd font download : <a href="https://www.nerdfonts.com/font-downloads">https://www.nerdfonts.com/font-downloads</a></li></ul><p>설정은 터미널 설정장에서 먼저 프로필 중에 <code>pwsh</code> 를 선택한 후, 모양 &gt; 글꼴 &gt; <code>Hack Nerd Font</code></p><img src="/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/wt_font_fine.png" class=""><h3 id="윈도우에서-vscode-폰트-설정"><a href="#윈도우에서-vscode-폰트-설정" class="headerlink" title="윈도우에서 vscode 폰트 설정"></a>윈도우에서 vscode 폰트 설정</h3><p>설정창 검색에서 <code>font family</code> 키워드로 필터링하고, Terminal &gt; Intergrated: Font Family 항목에 폰트명 지정</p><img src="/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/windows_vscode_font.png" class="">]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/pwsh/">pwsh</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/oh-my-posh/">oh-my-posh</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/10/19/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>웹페이지 반응형 디자인하기</title>
      <link>http://leafbird.github.io/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Thu, 12 Oct 2023 04:19:34 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/before_after.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;모바일에서 볼 때 왼쪽같이 보이던 페이지를 오른쪽처럼 변경했다. 지금은 블록 여백 등도 조금 더 정리해서 일단락 지었다. 실제 페이지는 &lt;a href=&quot;https://leafbird.github.io/&quot;&gt;https://leafbird.github.io&lt;/a&gt; 에서 확인 가능하다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/before_after.png" class=""><p>모바일에서 볼 때 왼쪽같이 보이던 페이지를 오른쪽처럼 변경했다. 지금은 블록 여백 등도 조금 더 정리해서 일단락 지었다. 실제 페이지는 <a href="https://leafbird.github.io/">https://leafbird.github.io</a> 에서 확인 가능하다. </p><span id="more"></span><p>수정한 문서는 오래전에 간단하게 만들어둔 프로필인데, 얼마전에 이걸 최신화 해야겠단 생각이 들어 다시 열었다. 디자인 수정을 마치고 확인하다 보니… 맥에서 작업할 때는 괜찮았는데, 폰으로 볼 때는 디자인이 그대로 축소되면서 사람의 시력으로 읽을 수 없는 상태가 되어버리고 있었다. 이 페이지를 처음 만들 때는 10년 전이었고 모바일이 지금만큼 많이 쓰이지는 않던 시절이었지만, 이제는 모바일이 주류가 되었으니 수정이 필요했다.</p><h2 id="meta-태그를-이용해-화면이-축소되지-않도록-붙잡아준다"><a href="#meta-태그를-이용해-화면이-축소되지-않도록-붙잡아준다" class="headerlink" title="meta 태그를 이용해 화면이 축소되지 않도록 붙잡아준다"></a>meta 태그를 이용해 화면이 축소되지 않도록 붙잡아준다</h2><p>너비가 줄어들 때 컨텐츠도 동일 비율로 작아져 버리는 현상만 놓고 보면 아래 meta 태그만 추가해주면 끝이다. 그럼 화면이 축소될 때 컨텐츠를 스케일하지 않고 기존의 크기를 유지해준다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>문제는 그 다음부터인데.. 요소들의 크기는 변하지 않으면서 페이지의 넓이만 좁아지면 레이아웃이 엉망이 된다. 테이블이 삐져나가고 사진 위로 글이 올라오고… 이 페이지를 처음 만들었을 때는 모바일 지원 같은 것에 별 뜻이 없었기 때문에 문서 폭을 620px로 고정해두고 절대값 수치들로 디자인을 해뒀었는데, 그렇게 해서는 대응이 어렵다.</p><h2 id="bootstrap의-grid를-이용하면-수월하다"><a href="#bootstrap의-grid를-이용하면-수월하다" class="headerlink" title="bootstrap의 grid를 이용하면 수월하다"></a>bootstrap의 grid를 이용하면 수월하다</h2><p>bootstrap은 2.x 버전 붙어있던 것을 5.3으로 변경했다. 그사이 부쩍 올라가있는 버전을 보니 세월이 많이 흘렀구나. 이전 버전에도 물론 grid 시스템은 존재하지만 이제는 2.x 버전 문서 억지로 찾아들어가 보기가 더 어렵다. 굳이 예전 버전을 유지할 이유도 없고. 사용법이 약간 달라지긴 했지만 워낙에 별 내용 없는 페이지라 수정할 것은 많지 않았다.</p><p><a href="https://getbootstrap.com/docs/5.3/layout/grid/">https://getbootstrap.com/docs/5.3/layout/grid/</a></p><img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/grid_table.png" class=""><p>예전부터 bootstrap 에 기웃거리긴 했지만 grid 시스템 어떻게 써먹는 것인지 이번에야 이해하게 되었다. <code>-sm-</code>, <code>-md-</code>, <code>-lg-</code> 이런거 바꿔 달아봐야 화면상에 변하는 것도 없고 뭐때문제 붙이는 건지 몰랐는데, 브라우저 너비마다 폭을 다르게 잡아주기 위해 쓰는 거였어. 가운데 블록은 화면이 넓을 때는 이미지와 테이블을 한 줄에 표현하고, 화면이 좁으면 두 줄로 나눠서 표현하는데, 아래처럼 처리했다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 이미지가 들어가는 블록 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 offset-lg-2 col-md-3 offset-md-1 col-sm-4 offset-sm-0&quot;</span>&gt;</span></span><br><span class="line">    .... 이미지 컨텐츠</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 내용 테이블 들어가는 블록 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6 offset-lg-0 col-md-7 offset-md-0 col-sm-12 offset-sm-0&quot;</span>&gt;</span></span><br><span class="line">    .... 테이블 컨텐츠</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>브라우저 넓이가 sm, md, lg 영역에 해당할 때 컨텐츠 영역과 오프셋의 크기를 별도로 지정해준다. grid의 합이 12보다 작으면 한 줄에 출력하고, 넘으면 두 줄로 나누어 출력된다.</p><p>난 사실 frontend 쪽은 전문 분야가 아니라서 거의 취미 코더에 가깝다. bootstrap은 디자인 자유도가 떨어지고 제한적이라 pro들은 기피한다는 이야기를 들은 듯 하지만 나하곤 상관 없는 이야기다. 너무 좋아 bootstrap. 가끔씩 업무상 필요한 간단한 in-house tool을 만들 때에도 정말 큰 도움을 준다. </p><h2 id="media-태그를-이용해서-추가로-레이아웃을-다듬는다"><a href="#media-태그를-이용해서-추가로-레이아웃을-다듬는다" class="headerlink" title="@media 태그를 이용해서 추가로 레이아웃을 다듬는다"></a>@media 태그를 이용해서 추가로 레이아웃을 다듬는다</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media">https://developer.mozilla.org/en-US/docs/Web/CSS/@media</a></p><p>bootstrap의 grid도 사실은 <code>@media</code> 태그를 이용해 미리 정의된 디자인 세트일 뿐이다. viewport 사이즈에 따라 다른 디자인을 가능하게 만드는 핵심은 스타일 시트에서 <code>@media</code>를 이용해 각각 다른 디자인을 적용해 주는 것이다.</p><p>처음엔 <code>@media</code>로 별도 제어하는 디자인을 많이 정의했다가, grid를 제대로 붙이고 나니 거의 다 사라지게 되었고 내가 별도로 처리할 만한 것이 많이 없었다. viewport가 필요 이상으로 넓을 때 컨텐츠가 너무 넓게 퍼지지는 않도록 최대 폭을 제한해 준다거나, 레이아웃이 바뀌면서 어색해지는 서로간의 간격 정도만 다듬어준다.</p><p>media 태그 기능과 사용방법을 정리한 글은 구글링으로 아주 많이 찾을 수 있다. 내가 참고한 게 뭐였는지 다시 찾으려고 했는데 못찾을 많큼 많음. 나중에 필요하면 다시 구글링 하면서 써도 충분하기에 정리는 생략.</p><h2 id="최종-결과"><a href="#최종-결과" class="headerlink" title="최종 결과"></a>최종 결과</h2><ul><li>desktop에서 본 화면 (windows, chrome)</li></ul><img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/final_desktop.png" class=""><ul><li>내 폰에서 본 화면 (iPhone 13 mini)</li></ul><img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/final_ios.png" class=""><h2 id="크롬에서-작업할-것을-추천"><a href="#크롬에서-작업할-것을-추천" class="headerlink" title="크롬에서 작업할 것을 추천"></a>크롬에서 작업할 것을 추천</h2><ul><li>크롬의 기본 개발자 기능이 반응형 디자인을 확인하기 좀 더 수월하다.</li><li>크롬 익스텐션 중에 반응형 웹디자인에 <a href="http://icunow.co.kr/chrome-extension5/">도움을 주는 툴들</a>이 많음. </li><li>사파리에도 <a href="https://developer.apple.com/documentation/safari-developer-tools/responsive-design-mode">Responsive Design Mode</a>라는 것이 있지만, 크롬이 더 나은 것 같애.</li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/bootstrap/">bootstrap</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/html/">html</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/responsive/">responsive</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>iTerm2 없이 맥 기본 터미널 꾸미기</title>
      <link>http://leafbird.github.io/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</guid>
      <pubDate>Mon, 09 Oct 2023 11:14:20 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/mac_terminal.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;아,&lt;br&gt;사람들이 왜 터미널을 예쁘게 꾸미는지 이제야 알았다.&lt;br&gt;코딩 뽕이 막 차오르네. 뭐라도 막 만들고 싶어진다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/mac_terminal.png" class=""><p>아,<br>사람들이 왜 터미널을 예쁘게 꾸미는지 이제야 알았다.<br>코딩 뽕이 막 차오르네. 뭐라도 막 만들고 싶어진다.</p><span id="more"></span><h2 id="백업을-위한-설정-내용-간단-정리"><a href="#백업을-위한-설정-내용-간단-정리" class="headerlink" title="백업을 위한 설정 내용 간단 정리"></a>백업을 위한 설정 내용 간단 정리</h2><p>맥 터미널 꾸미기에 대한 자료는 이미 수도 없이 많지만 이번에 세팅해둔 설정을 백업하는 의미로 간단히 정리한다. 우선 나는 주로 아래의 포스팅을 보고 진행했다. </p><ul><li><a href="https://kdohyeon.tistory.com/m/122">터미널 꾸미기: Oh-my-zsh + iTerm2</a></li><li><a href="https://velog.io/@seona-jung/%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0-oh-my-zsh">iTerm2 없이 터미널 꾸미기</a></li></ul><p>본 포스팅에 기술할 변경 내용을 반영한 거의 모든 설정 파일은 <a href="https://github.com/leafbird/dotfiles.git">dotfiles</a>에 백업해 두었다.<br>거의 모든이라 함은.. <code>Hack</code> 폰트 설치 같은 것은 설정 파일 반영만으로 어려우니, 재설정이 필요할 때 이 부분은 별도 진행 해야 한다.</p><h3 id="oh-my-zsh의-테마-변경"><a href="#oh-my-zsh의-테마-변경" class="headerlink" title="oh-my-zsh의 테마 변경"></a>oh-my-zsh의 테마 변경</h3><p>두 글 다 테마로 <code>agnoster</code>를 사용한다. 다른 포스팅에서도 이 테마가 자주 언급되는 걸 보니 꽤나 인기 테마인듯 하다. 하지만 git 상태 알려주는 부분 폰트가 깨지기 때문에 <a href="https://sourcefoundry.org/hack/">Hack</a> 폰트를 따로 설치해 주어야 한다.</p><h3 id="터미널-컬러-테마-변경"><a href="#터미널-컬러-테마-변경" class="headerlink" title="터미널 컬러 테마 변경"></a>터미널 컬러 테마 변경</h3><p>터미널의 color theme를 <a href="https://github.com/sindresorhus/terminal-snazzy">snazzy</a>로 변경해준다. 터미널의 윈도우 사이즈도 같이 바뀌니까 적당히 조절해주고, 모니터 크기에 맞춰 폰트 사이즈도 조절한다 (나는 맥미니와 맥북의 폰트 사이즈를 다르게 설정해둠.) 한가지 중요한 점이 커서 모양인데, 터미널에서 사각박스 모양의 커서를 사용해야 vim에서 normal&#x2F;insert 모드 인식이 쉽기 때문에 이 설정을 다시 사각박스로 되돌려준다. </p><img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/cursor_setting.png" class=""><h3 id="zsh-플러그인-설치"><a href="#zsh-플러그인-설치" class="headerlink" title="zsh 플러그인 설치"></a>zsh 플러그인 설치</h3><p>나중엔 다른 걸 더 쓰게 될지 모르겠지만 지금은 우선 <code>zsh-syntax-highlighting</code>만 설치.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h3 id="agnoster-테마파일을-열어서-터미널-입력-위치에-개행-추가"><a href="#agnoster-테마파일을-열어서-터미널-입력-위치에-개행-추가" class="headerlink" title="agnoster 테마파일을 열어서 터미널 입력 위치에 개행 추가"></a>agnoster 테마파일을 열어서 터미널 입력 위치에 개행 추가</h3><p>이건 참고한 포스팅에서 텍스트 대신에 스크린샷을 올려두셔서… 보고 따라치느라 애먹음;; 스크립트 중간에 문자열 안의 줄바꿈을 그대로 인식하는 식이라서, 예쁘게 적는다로 한 줄로 적으면 제대로 개행되지 않는다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">## Main prompt</span><br><span class="line">build_prompt() &#123;</span><br><span class="line">  RETVAL=$?</span><br><span class="line">  prompt_status</span><br><span class="line">  prompt_virtualenv</span><br><span class="line">  prompt_aws</span><br><span class="line">  prompt_context</span><br><span class="line">  prompt_dir</span><br><span class="line">  prompt_git</span><br><span class="line">  prompt_bzr</span><br><span class="line">  prompt_hg</span><br><span class="line">  prompt_newline // 이 부분을 추가. 꼭 순서 지켜서.</span><br><span class="line">  prompt_end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROMPT=&#x27;%&#123;%f%b%k%&#125;$(build_prompt) &#x27;</span><br><span class="line"></span><br><span class="line">prompt_newline() &#123;</span><br><span class="line">  if [[ -n $CURRENT_BG ]]; then</span><br><span class="line">    echo -n &quot;%&#123;%k%F&#123;$CURRENT_BG&#125;%&#125;$SEGMENT_SEPARATOR</span><br><span class="line">%&#123;%k%F&#123;blue&#125;%&#125;$SEGMENT_SEPARATOR&quot;</span><br><span class="line">  else</span><br><span class="line">    echo -n &quot;%&#123;%k%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo -n &quot;%&#123;%f%&#125;&quot;</span><br><span class="line">  CURRENT_BG=&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vscode-에-hack-폰트-지정"><a href="#vscode-에-hack-폰트-지정" class="headerlink" title="vscode 에 hack 폰트 지정"></a>vscode 에 hack 폰트 지정</h3><p>기본 순정 터미널을 설정했기 때문에 vscode에서 별다른 것 해주지 않아도 알아서 변경사항이 반영된다. 새로 설치한 font만 추가 지정해주면 끝.</p><img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/vscode_setting.png" class=""><img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/vscode.png" class="">]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/iTerm2/">iTerm2</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/terminal/">terminal</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/osx/">osx</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/agnoster/">agnoster</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/vscode/">vscode</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - 메모리 단편화</title>
      <link>http://leafbird.github.io/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/</link>
      <guid>http://leafbird.github.io/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/</guid>
      <pubDate>Sun, 08 Aug 2021 12:44:20 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/00.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;이제 닷넷의 GC는 꽤나 쓸만하게 발전하여, 웬만한 경우는 프로그래머가 메모리 관리를 굳이 신경쓰지 않고 코딩할 수 있게 도와준다. 그리고 그것이 C++ 대신 C#을 선택하는 큰 이유이기도 하다. 하지만 C# 게임서버로도 성능에 욕심을 내고자 한다면, 짧은 순간 대량의 TPS를 낼 수 있는 네트워크 IO를 구현하려고 한다면 어느정도 메모리 운용에 대한 이해가 필요하다.&lt;/p&gt;
&lt;p&gt;이번 포스팅에서는 네트워크 IO의 부하가 가중될 때 겪을 수 있는 메모리 단편화 현상에 대해서 정리해본다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/00.jpg" class=""><p>이제 닷넷의 GC는 꽤나 쓸만하게 발전하여, 웬만한 경우는 프로그래머가 메모리 관리를 굳이 신경쓰지 않고 코딩할 수 있게 도와준다. 그리고 그것이 C++ 대신 C#을 선택하는 큰 이유이기도 하다. 하지만 C# 게임서버로도 성능에 욕심을 내고자 한다면, 짧은 순간 대량의 TPS를 낼 수 있는 네트워크 IO를 구현하려고 한다면 어느정도 메모리 운용에 대한 이해가 필요하다.</p><p>이번 포스팅에서는 네트워크 IO의 부하가 가중될 때 겪을 수 있는 메모리 단편화 현상에 대해서 정리해본다. </p><span id="more"></span><h2 id="기본-용어-및-개념-정리"><a href="#기본-용어-및-개념-정리" class="headerlink" title="기본 용어 및 개념 정리"></a>기본 용어 및 개념 정리</h2><h3 id="SOH-LOH-POH"><a href="#SOH-LOH-POH" class="headerlink" title="SOH &#x2F; LOH &#x2F; POH"></a>SOH &#x2F; LOH &#x2F; POH</h3><p>가장 먼저 <code>관리 힙(managed heap)</code>의 구분부터 이야기 해야한다. 관리힙은 사용 메모리의 크기와 용도 등에 따라 <code>SOH</code>, <code>LOH</code>, <code>POH</code>로 나뉜다.</p><ul><li><code>SOH</code>는 Small Object Heap으로, 85kb보다 작은 사이즈의 메모리를 할당한다. 경우에 따라 차이는 있겠지만 대다수의 객체들이 주로 할당&#x2F;해제 되는 공간이다. </li><li><code>LOH</code>는 Large Object Heap으로, 85kb보다 큰 사이즈의 메모리를 할당한다. </li><li><code>POH</code>는 Pinned Object Heap으로, pinning할 메모리를 위해 .Net 5부터 새롭게 추가된 공간이다.</li></ul><p>POH는 사실 다짜고자 단편화의 해법에 가까운 존재이긴하나.. 분류상 미리 언급되었다. 이후에 다시 추가적으로 설명한다.</p><h3 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h3><p><code>SOH</code>의 메모리는 객체가 얼마나 오래 살았느냐에 따라 0세대부터 2세대까지 세대를 구분한다. GC가 한 번 실행될 때 사용이 끝난 메모리는 해제되고, 아직 사용중인 메모리는 다음 세대로 승격한다. 이 때 살아남은 메모리들은 <code>압축(Compression)</code>의 과정을 거친다. 압축이란 메모리 단편화를 줄이기 위해, 살아남은 메모리들을 사이사이 공백이 없도록 한 공간으로 몰아서 재배치하는 동작을 말한다. 실제로 관리 힙 내부에서 객체들은 세대별로 모아두어야 하기 때문에, 메모리 해제 및 승격을 거친 후에는 세대별 구획에 맞춰 메모리를 재정렬하는 과정이 반드시 필요하다.</p><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/01.png" class=""><p>오.. 이거 처음에 너무 신기했다. 네이티브 언어로 만들어진 코드에서는 불가능한 동작이다. C++로 짠 코드라면 프로그래머가 직접 작성한 비즈니스 로직 상에서 이미 무수히 많은 포인터들이 가상 메모리의 주소값 자체를 가르키고 있기 때문이다. C#의 참조타입 변수들도 C++ 포인터와 유사하다고 볼 순 있지만 직접적으로 메모리 주소가 노출되어 있지는 않기 때문에 가능한 일이다. 객체의 메모리상 주소가 바뀌더라도 모든 참조들을 새로운 주소값으로 알아서 갱신해 주어서, 매니지드 레벨의 코드상에서는 마치 아무 일도 없었다는 듯이 시치미를 떼는 신박한 동작이다. </p><h3 id="Pinned-Memory"><a href="#Pinned-Memory" class="headerlink" title="Pinned Memory"></a>Pinned Memory</h3><p>하지만 메모리 압축이 이미 할당된 모든 객체들의 위치를 제멋대로 바꿀 수 있는 것은 아니며, 모든 법칙에 항상 예외는 존재한다. 매니지드 레벨은 결국 네이티브 레벨 위에서 돈다. 네이티브 영역과의 상호참조가 필요한 매니지드 메모리는 함부로 값을 옮겨다닐 수가 없다. 위에서 언급한 <code>C++로 만든 코드였다면 불가능</code>하다고 말한 이유와 크게 다르지 않은 상황이다.<br>네이티브 영역에서 매니지드 영역의 메모리를 참조할 일이 있을 때는 메모리를 이동이 발생하지 않는 안전한 공간에 복사(copying)하거나, 이동할 수 없도록 고정(pinning)해둬야 한다. 매니지드 메모리가 다른 주소로 이동하지 않도록 고정하는 것을 <code>Memory Pinning</code>, 이렇게 고정된 메모리를 <code>Pinned Memory</code>라고 부른다.</p><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/02.gif" class=""><p>데이터 마샬링(매니지트&#x2F;네이티브 상호통신)의 입장에서 보면 pinning은 불필요한 복사를 줄여주는 효율적인 동작이다. 하지만 가비지 컬렉터 입장에서 보자면 엄청난 방해꾼임이 분명하다. pinned memory 는 gc의 압축 동작을 방해하기 때문이다</p><blockquote><p>고정(Pinning)은 데이터를 현재 메모리 위치상에 임시로 잠그기 때문에, CLR의 가비지 수집기에 의한 재배치를 막아줍니다.<br>Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime’s garbage collector.<br>(<a href="https://docs.microsoft.com/en-us/dotnet/framework/interop/copying-and-pinning">https://docs.microsoft.com/en-us/dotnet/framework/interop/copying-and-pinning</a>)</p></blockquote><blockquote><p>고정(Pinning)은 메모리의 단편화를 유발하고, 일반적으로 객체 압축 과정을 복잡하게 만들기 때문에 자체적인 비용 부담을 가집니다.<br>Pinning has its own costs, because it introduces fragmentation (and in general complicates object compaction a lot).<br>(<a href="https://tooslowexception.com/pinned-object-heap-in-net-5/">https://tooslowexception.com/pinned-object-heap-in-net-5/</a>)</p></blockquote><h2 id="단편화-발생의-원인"><a href="#단편화-발생의-원인" class="headerlink" title="단편화 발생의 원인"></a>단편화 발생의 원인</h2><p>성능좀 끌어올려보겠다고 다짐한 C# 게임서버의 메모리 단편화는 어디서 발생하는가. </p><p>핵심부터 말하자면 소켓의 send &#x2F; receive에 걸어주는 바이트 배열 버퍼가 pinning되기 때문에, 가비지 컬렉터의 압축과정을 많이 방해하게 되면서 메모리 단편화를 유발한다. 이 부분이 메모리 단편화의 가장 주된 요인이다. 그런데다가 높은 TPS를 처리해내는 고성능 게임서버를 만들려고 한다면.. 소켓 IO의 수가 많아짐에 따라 네트워크 버퍼의 개수와 사용 빈도도 당연히 높아질 수밖에 없다. 때문에 대량의 네트워크 통신을 견딜 수 있도록 만드려면 네트워크 버퍼를 어떻게 운용할 것인지가 중요하다.</p><p>DB와 통신하기 위한 DBMS 클라이언트도 많은 수의 pinned handle을 만들어낸다. 현재 우리 프로젝트는 <code>System.Data.SqlClient</code> 네임스페이스 하위의 클래스들을 이용해 Azure SQL과 통신하고 있는데, 생각해보면 db client도 DBMS에 연결되어 쿼리와 데이터를 던지고 받는 통신모듈이니 당연한 이야기다. </p><p>코드상에서 임의의 객체를 약참조 하기 위해 사용하는 <code>System.WeakReference</code>도 pinning handle을 사용하고 있어, 단편화 유발의 원인이 된다. 이건 참 아이러니한 일이다. 참조하는 대상이 쉽게 메모리 해제될 수 있도록 약참조하는 기능을 하지만, <code>WeakReference</code> 자신은 고정된 메모리를 만들면서 메모리 단편화를 가속시킨다. 처음 서버 기반을 만들 땐 <code>WeakReference</code>가 GC를 방해한다는 사실을 모르고 엄청시리 쓰고 있었는데, 비교적 근래에 실 서비스에서 메모리 문제들을 겪으면서 디버깅 하던 중 메모리가 고정되고 있음을 알게됐다. 현재는 약참조 사용이 꼭 필요한 일부를 제외하고는 모두 제거하였고, 가능하면 <code>WeakReference</code> 의 사용을 자제하고 있다.</p><p>메모리 상의 고정된 핸들에 대한 정보는 windbg로 힙을 뒤져보면 알 수 있다. <code>sos.dll</code> 로딩된 상태에서 <code>!gchandles</code> 명령 쳐보면 현재 어떤 객체가 pinning되어있고, 몇개나 존재하는지 확인할 수 있다.</p><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/memory_01.png" class=""><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/memory_00.png" class=""><h2 id="단편화-해결-솔루션"><a href="#단편화-해결-솔루션" class="headerlink" title="단편화 해결 솔루션"></a>단편화 해결 솔루션</h2><p>상술한 원인들 중 가장 명백한 원인제공자는 네트워크 버퍼다. 빈번히 쓰이는 네트워크 버퍼를 잘 운용하는 것이 단편화 해결의 핵심이다.</p><p>네트워크 버퍼용 <code>byte[]</code> 객체를 <code>ArrayPool&lt;T&gt;</code> 을 이용해 풀링하는 것은 그다지 개선의 효과가 없었다. <code>ArrayPool&lt;T&gt;</code>클래스는 효율적으로 객체의 할당과 해제 빈도를 완화하고 관리해주지만, 어쨌거나 <code>SOH</code> 공간에서 할당을 받기 때문에, 이글에서 말하고 있는 pinning 이나 단편화 현상 해결 등과는 크게 상관이 없다. </p><p>메모리 압축은 <code>SOH</code>에서만 발생한다. 따라서 pinned memory가 GC성능 저하 및 메모리 단편화를 일으키는 것도 <code>SOH</code>에만 해당하는 이야기다. 그러니 네트워크 버퍼는 그냥 <code>SOH</code>에 잡지 않는 것이 좋겠다.</p><h3 id="솔루션-1-네트워크-버퍼를-POH에-할당하기"><a href="#솔루션-1-네트워크-버퍼를-POH에-할당하기" class="headerlink" title="솔루션 1. 네트워크 버퍼를 POH에 할당하기"></a>솔루션 1. 네트워크 버퍼를 POH에 할당하기</h3><p>MS 형들도 역시 성능상에서 이런 문제가 있음을 분명히 알고 있다. <code>.NET 5</code>부터는 고정된 메모리로 사용할 객체를 할당하는 별도의 힙 공간인 <code>POH</code>가 새로 생겼다. 현재 회사에서 만든 게임 서버는 프레임워크 버전이 낮아서 아직 사용해 보지는 못했다. (우리 프로젝트는 .NET Framework 4.7.2로 개발을 시작해서 현재 .NET Core 3.1을 사용중이다). <a href="https://tooslowexception.com/pinned-object-heap-in-net-5/">이 글</a>에서 <code>POH</code>에 대한 기본적인 설명을 확인할 수 있다. 아직 서비스하기 전이거나, 사용중인 프레임워크가 <code>.NET 5</code> 이상이라면 <code>POH</code>의 도입을 검토해 볼 만 하다.<br>링크된 글에서 설명하는 것처럼 <code>POH</code>는 그 존재 목적상, blittable 형식만을 할당할 수 있도록 제한되어있다. 네이티브 코드와 통신하기 위한 데이터를 할당하는 전용의 공간이므로, 기술적인 한계가 아닌 설계상의 의도로 제한을 걸어두었다.</p><h3 id="솔루션-2-네트워크-버퍼를-LOH에-할당하기"><a href="#솔루션-2-네트워크-버퍼를-LOH에-할당하기" class="headerlink" title="솔루션 2. 네트워크 버퍼를 LOH에 할당하기"></a>솔루션 2. 네트워크 버퍼를 LOH에 할당하기</h3><p><code>LOH</code>의 객체들은 메모리 압축으로 인한 재배치를 진행하지 않으며, 세대가 구분되어있지도 않다. 2세대 GC가 수행될 때만 <code>LOH</code>상의 메모리 해제가 진행되므로, 모두 2세대 객체라고 부르기도 한다. 세대 구분이 없으니 메모리 공간상에서 꼭 재배치(Compression) 해주어야 할 필요도 없다.<br><code>LOH</code>의 객체는 기본설정상 가상 메모리 주소공간에 한 번 할당되면 위치가 이동되지 않는다. 그러니 빈번하게 할당과 해제를 반복하는 메모리를 <code>LOH</code>에 많이 만들면 금방 조각나버릴 공간이다. 이런 경우라면 <code>LOH</code>에서도 압축을 하도록 설정을 조정할 수는 있지만.. 이렇게 사용하는 것은 그다지 취지(?)에 맞지 않는 기분이 든다. <code>LOH</code>에는 오래도록 유지하거나, 아예 해제할 계획이 없는 덩치큰 메모리들을 위치시키는 것이 용도상 더 적절하다.<br>우리는 게임 런칭 전 10만 동접을 시뮬레이션하는 부하테스트를 진행했다. 당시 메모리 단편화 이슈로 한참을 고생하던 중, <a href="https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation">이 글의 해결 사례</a>를 보고나서 네트워크 버퍼 할당을 LOH로 옮겨 보기로 했다.</p><p>네트워크 버퍼를 <code>LOH</code>로 옮긴 이후 메모리 단편화 문제는 말끔해 해결되었다. 한 번에 100Mb 단위의 커다란 메모리 청크를 <code>LOH</code>에 잡아두고, 이를 다시 <code>ArraySegment&lt;byte&gt;</code>로 잘게 나누어 풀링하면서 사용하는 방식이다. C++에서 고전적으로 메모리 풀링을 구현할 때 접근하는 방식과 유사하다. </p><p>C#에서는 버퍼의 조각을 <code>byte[]</code>로 표현할 수 없다. C++에서 <code>byte[]</code>는 개념상 가르키는 대상이 고정인 포인터 (<code>byte * const</code>)와 유사하다(물론 문법상 차이는 있다). 그러므로 커다란 바이트 배열도 포인터, 여러개의 작은 배열들도 포인터로 가르키는 셈이니까 모두 <code>byte[]</code>로 표현되는게 아무 문제가 없다. 하지만 C#에서는 <code>byte[]</code>도 하나의 독립된 매니지드 객체이므로 C++과는 차이가 있다. 큰 배열의 단위조각을 표현할 때 <code>ArraySegment&lt;byte&gt;</code>를 사용해야 하는 이유다.</p><p>조금은 다른 이야기지만 처음 <code>ArrayPool&lt;T&gt;</code> 가 BCL에 들어왔을때 아주 당연하게 착각한것이, 이놈으로 <code>byte[]</code>를 풀링하면 내부적으로 큰 청크를 한 번만 할당해서 이걸 조각내서 쓸것으로 생각했다. 메모리 관리라 하면 으레 이 방식이 익숙해서였다. 하지만 조금만 생각해보면, C#에서는 불가능한 이야기다. 덩치큰 <code>byte[]</code>를 여러개의 작은 <code>byte[]</code>로 표현할 수가 없다. <code>ArrayPool&lt;T&gt;</code> 코드를 보면 할당 자체는 <code>SOH</code>상에서 단일객체 단위로 발생하나, 그 외 나머지 기법들을 이용해 최적화를 진행함을 알 수 있다. 코드를 보면 2세대 GC가 불릴 때 콜백을 얻어와 현재 메모리 압력을 진단하고, 선택적으로 메모리를 해제하는 등의 테크닉을 볼 수 있다. 이런건 나중에 메모리 로우레벨을 제어해야 할 경우 참고하여 응용하면 좋을듯 하다.</p><ul><li><a href="https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/ArrayPool.cs">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/ArrayPool.cs</a></li><li><a href="https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs</a></li></ul><p>이전 포스팅 <a href="https://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/">C# 고성능 서버 - System.IO.Pipeline 도입 후기</a>에서 여러개의 단위버퍼를 이어붙여 가상의 스트림처럼 운용하는 <code>ZeroCopyBuffer</code>의 구현에 대해 간단히 소개했었다. 이 때 등장했던 단위버퍼 <code>LohSegment</code> 클래스가 바로 <code>LOH</code>에 할당한 커다란 청크의 일부분에 해당한다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.ServerEngine.Netork.Buffer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ZeroCopyBuffer</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Queue&lt;LohSegment&gt; segments = <span class="keyword">new</span> Queue&lt;LohSegment&gt;();</span><br><span class="line">    <span class="keyword">private</span> LohSegment last;</span><br><span class="line">    <span class="comment">//       ^ 여기 얘네들이예요. </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>LohSegment</code>를 생성, 풀링하고 관리하는 구현은 크게 대단할 것은 없다. 어차피 할당 크기가 85kb보다 크기만 하면 알아서 <code>LOH</code>에 할당될 것이고.. 청크를 다시 잘 쪼개서 <code>ConcurrentQueue&lt;&gt;</code>에 넣어뒀다가 잘 빌려주고 반납하고 관리만 해주면 된다.<br>조금 더 신경을 쓴다면 서비스 도중 메모리 청크를 추가할당 할 때의 처리 정도가 있겠다. Pool에 남아있는 버퍼의 개수가 좀 모자란다 싶을 때는 CAS 연산으로 소유권을 선점한 스레드 하나만 청크를 할당하게 만든다. 메모리는 추가만 할 뿐 해제는 하지 않을거니까 이렇게 하면 lock을 안 걸어도 되고, pool의 사용도 중단되지 않게 만들 수 있다. 해당 구현체의 멤버변수들만 붙여보면 아래와 같다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.Memory</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">LohPool</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSizeMb = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> LowSegmentNumberLimit = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> segmentSizeKb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> segmentSizeBytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;<span class="built_in">byte</span>[]&gt; chunks = <span class="keyword">new</span> List&lt;<span class="built_in">byte</span>[]&gt;(capacity: <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentQueue&lt;ArraySegment&lt;<span class="built_in">byte</span>&gt;&gt; segments = <span class="keyword">new</span> ConcurrentQueue&lt;ArraySegment&lt;<span class="built_in">byte</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> AtomicFlag producerLock = <span class="keyword">new</span> AtomicFlag(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> totalSegmentCount;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>C++로만 만들던 게임서버를 C#으로 만든다고 했을 때 가장 신경쓰였던 것이 메모리 부분이었다. 초기구현과 서비스를 거치면서 메모리 누수, 관리힙 사이즈 증가등 많은 메모리 문제를 겪었다. 그 중에서 가장 크게 문제를 겪었던 단편화에 대해 정리해 보았다.<br>우리가 겪었던 메모리 단편화 가장 주된 요인은 네트워크 IO용 바이트 버퍼의 pinning 때문이었다. 적당한 수준의 부하로는 별 문제 없는데.. 부하를 세게 걸면 점유 메모리가 계속 증가하고 가라않질 않았다. 이건 C++도 마찬가지지만 외형적으로만 관측하면 메모리 누수처럼 보이기 때문에, 단편화가 원인일 것이라는 의심을 하기까지도 많은 검증의 시간이 필요했다.</p><p><code>SOH</code>에서는 pinning되는 메모리가 많으면 GC 능력이 많이 저하되고 단편화가 심각해진다. 네트워크 버퍼로 사용할 객체들을 <code>LOH</code>에 할당하면 이런 문제를 해결할 수 있다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="https://prodotnetmemory.com/data/netmemoryposter.pdf">https://prodotnetmemory.com/data/netmemoryposter.pdf</a></li><li><a href="https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation">https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation</a></li><li><a href="https://tooslowexception.com/pinned-object-heap-in-net-5/">https://tooslowexception.com/pinned-object-heap-in-net-5/</a></li><li><a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.arraypool-1?view=net-5.0">https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.arraypool-1?view=net-5.0</a></li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.0">https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.0</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance#Pinned">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance#Pinned</a></li><li><a href="https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation">https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation</a></li><li><a href="https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream">https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/ArrayPool/">ArrayPool</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Memory/">Memory</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Fragmentation/">Fragmentation</category>
      
      
      <comments>http://leafbird.github.io/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - Thread Local Storage</title>
      <link>http://leafbird.github.io/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/</link>
      <guid>http://leafbird.github.io/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/</guid>
      <pubDate>Fri, 01 Jan 2021 07:00:49 GMT</pubDate>
      
      <description>&lt;p&gt;프로그래밍에서 각 스레드별로 고유한 상태를 설정할 수 있는 공간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread-local_storage&quot;&gt;Thread Local Storage&lt;/a&gt; (이하 TLS. transport layer security 아님) 라고 한다. VC++에서는 &lt;code&gt;__declspec(thread)&lt;/code&gt; 키워드를 이용해서 tls 변수를 선언할 수 있다. &lt;/p&gt;
&lt;p&gt;C#에도 &lt;code&gt;ThreadLocal&amp;lt;T&amp;gt;&lt;/code&gt; 라는 클래스를 이용해 tls를 사용할 수 있지만, 막상 실제로 사용해보면 C++에서는 존재하지 않았던 큰 차이점이 있다. C# 5.0부터 들어온 async &amp;#x2F; await 문법을 이용해 비동기 프로그래밍을 구현했다면, await 대기 시점 이전과 이후에 스레드가 달라지기 때문이다. &lt;/p&gt;
&lt;p&gt;이를 해결하는 방법과 주의해야 할 사항을 정리해본다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>프로그래밍에서 각 스레드별로 고유한 상태를 설정할 수 있는 공간을 <a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread Local Storage</a> (이하 TLS. transport layer security 아님) 라고 한다. VC++에서는 <code>__declspec(thread)</code> 키워드를 이용해서 tls 변수를 선언할 수 있다. </p><p>C#에도 <code>ThreadLocal&lt;T&gt;</code> 라는 클래스를 이용해 tls를 사용할 수 있지만, 막상 실제로 사용해보면 C++에서는 존재하지 않았던 큰 차이점이 있다. C# 5.0부터 들어온 async &#x2F; await 문법을 이용해 비동기 프로그래밍을 구현했다면, await 대기 시점 이전과 이후에 스레드가 달라지기 때문이다. </p><p>이를 해결하는 방법과 주의해야 할 사항을 정리해본다. </p><span id="more"></span><blockquote><p>알림 : 이 글을 처음 포스팅한 후 받은 피드백을 통해 보다 명확한 원인과 해결방법을 추가 확인하게 되어 내용을 수정&#x2F;보완 했습니다. 최초 버전의 글도 유지하려 했으나 글의 문맥이 복잡해지고 읽기가 어려워져 최종 버전만 남겼습니다.</p><p>수정한 내용 요약 : 새로 깨어난 스레드인데도 <code>AsyncLocal&lt;T&gt;</code>에 값이 남아있던 이유는, 기존의 값이 지워지지 않았기 때문이 아니라, 네트워크 이벤트 콜백으로 깨어난 스레드에도 <code>AsyncLocal&lt;T&gt;</code>의 값을 복사하고 있었기 때문이었습니다.</p></blockquote><h2 id="async-await-을-절대-가볍게-접근하면-안된다"><a href="#async-await-을-절대-가볍게-접근하면-안된다" class="headerlink" title="async &#x2F; await 을 절대 가볍게 접근하면 안된다"></a>async &#x2F; await 을 절대 가볍게 접근하면 안된다</h2><p>주제와 약간 벗어날 수 있지만 서두에 미리 한 번 짚고 넘어갈 부분이 있다. <strong>절대로 async &#x2F; await를 이용한 비동기 프로그래밍을 만만하게 보아서는 안된다</strong>는 것이다.</p><p>나도 그랬지만 누구든지 제일 처음 비동기 메서드를 접했을 땐 이해하기 쉽고 간단한 기능이라는 첫인상을 가지게 될 것이다. 개인적으로는 비동기 메서드를 적용하고 난 후의 코드가 동기 프로그래밍과 너무 비슷해져 버리는 점이 착각을 유발하는 큰 원인이라고 생각한다 (MS: 얘는 뭐 좋게 해줘도 불만이 많네..) </p><p>이전에 DB 쿼리나 네트워크 통신같은 IO 작업에서 비동기로 받는 결과값을 처리하기 위해서는 하나의 동일한 주제(single concern)를 위한 로직임에도 불구하고 비동기 요청 이전과 이후의 코드가 분절되어야 했다. 이를테면 비동기 요청 전의 코드와 응답 후의 코드를 서로 다른 메서드로 나누어서 짜야 했다는 뜻이다. 코드의 가독성에 대해 고민을 좀 해봤던 개발자라면 람다를 써서 어떻게든 읽기 좋고 관리하기 좋도록 애써 보았을 수도 있으나, 가독성에서 정도의 차이가 있을 뿐 명백하게 존재하는 코드상의 분절을 피할 수 없었다. </p><p>비동기 메서드의 등장으로 이런 상황은 옛날 이야기가 되었다. 안간힘을 써보아도 완전하게 붙이기 힘들었던 분절된 코드들은 이제 하나의 async 함수 안에서 seamless하게 구현할 수 있게 되었다. 작성한 코드를 읽을 때에도 (신경써서 읽지 않는다면) 어디가 동기 처리이고, 어디가 비동기 처리인지도 잘 모르고 넘어갈만큼 술술 읽어내려가게 되었다. 좋게 해석하자면 어플리케이션 개발자가 좀 더 로직에만 집중 할 수 있는 환경이 되었다.</p><p>이것은 호수에 떠있는 백조와 같다. 일단 겉으로 보기에는 아주 우아하게 비동기 코드를 표현했으나, 조금만 안을 들여다보면 비동기 요청을 기준으로 발생하는 여전한 로직의 분절, 그에 따른 <strong>실행 시점 시간차 및 실행 환경상의 차이</strong> 등은 당연게도 여전히 존재하고 있기 때문이다. 이로 인한 이슈들은 동시성(concurrency)이 있는 멀티스레드 환경에서 더 잘 드러난다. MS는 실제로 프로그래머들이 하부의 복잡한 메커니즘을 잘 모르더라도 쉽고 편하게 비동기 로직을 다룰 수 있는 유토피아를 꿈꾸었을지 모르겠다. 하지만 싱글 스레드로 간단한 툴 한두개 짜는거면 몰라도… C#이란 언어로 고성능 서버를 만들겠다고 한다면, 이에 대한 충분한 이해가 없이는 런타임에서 예상못한 오작동을 피할 수 없을 것이다.</p><p>이후 글에서 언급할 내용도 비동기 함수의 실행 시점차와 관련되어 있으므로, 비동기 메서드에 대한 어느 정도의 이해가 필요하다.</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>우선 잠깐 언급했던 <code>ThreadLocal&lt;T&gt;</code> 클래스를 간단히 알아보자. 이를 이용해 일반적인 tls 변수를 선언하고 사용할 수 있다. 이보다 전부터 있었던 <code>[ThreadStatic]</code> 어트리뷰트로도 똑같이 tls를 선언할 수 있지만, 변수의 초기화 처리에서 <code>ThreadLocal&lt;T&gt;</code> 가 좀 더 매끄러운 처리를 지원한다. 일반적인 tls가 필요할 때는 좀 더 최신의 방식인 <code>ThreadLocal&lt;T&gt;</code> 를 사용하면 된다.</p><p>모든 tls 변수에 동일한 값의 복제본을 저장해 두려는 경우가 있다. 예를들어 스레드가 3개 있으면, 메모리 공간상에 각 스레드를 위한 변수 3개가 있고, 이들 모두에 같은 의미를 가지는 인스턴스를 하나씩 생성해 할당하는 경우를 말한다. <strong>서로 다른 스레드끼리 공유해야 할 자원이 있을 때, 해당 자원에 lock이 없이 접근하고 싶다면</strong> tls를 이용해 각 스레드마다 자원을 따로 만들어 각자 자기 리소스를 쓰게 하면 된다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.Math</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RandomGenerator</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> maxValue</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> PerThreadRandom.Instance.Next(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 중략    </span></span><br><span class="line">    <span class="comment">// 사용 계층에 노출할 인터페이스를 이곳에 정의. 사용자는 tls에 대해 알지 못한다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// System.Random 객체는 멀티스레드 사용에 안전하지 않으므로 각 스레드마다 개별 생성.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PerThreadRandom</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ThreadLocal&lt;Random&gt; Random = <span class="keyword">new</span> ThreadLocal&lt;Random&gt;(() =&gt; <span class="keyword">new</span> Random());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">internal</span> <span class="keyword">static</span> Random Instance =&gt; Random.Value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이런 경우는 비동기 메서드의 실행중 스레드의 교체가 발생하더라도 아무 문제가 되지 않는다. 어차피 어떤 스레드로 바뀌더라도 tls 변수가 하는 역할은 동일하기 때문이다. 0번 스레드가 불러다 쓰는 <code>Random</code> 객체가 어느순간 2번 스레드의 <code>Random</code> 객체로 바뀐다 해도 동작에 큰 영향이 없다. </p><h2 id="AsyncLocal"><a href="#AsyncLocal" class="headerlink" title="AsyncLocal"></a>AsyncLocal</h2><p>문제는 스레드별로 tls의 상태가 서로 달라야 할 때 발생한다. 0번 스레드에는 tls에 “철수”가, 2번 스레드에는 “영희”가 적혀있어야 하고, 이를 사용해 스레드마다 다른 동작을 해야 하는 경우. 그런데 거기다 async&#x2F;await를 이용한 비동기 프로그래밍을 함께 사용한 경우. 0번 철수 스레드가 코드 수행 도중 await 구문을 만나 task의 완료를 기다리고 있었지만, 대기가 풀렸을 때는 2번 스레드로 갈아타게 되면서 철수가 영희가 되버리는 경우다.</p><img src="/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/00.png" class=""><p>스레드별로 서로 다른 상태값을 사용해야 하는 예를 구승모 교수님의 <a href="https://github.com/zeliard/Dispatcher">Dispatcher</a> 구현에서 찾아볼 수 있다. (<a href="https://github.com/zeliard/Dispatcher/blob/master/JobDispatcher/ThreadLocal.h">ThreadLocal.h</a>) Dispatcher는 고성능 멀티스레드 로직 수행을 위한 Actor 패턴 구현체다. 스레드에 lock을 걸지 않으면서도 서로 다른 스레드간 간섭 없이 순차실행을 가능하게 하기 위해, 스레드는 현재 자신의 수행상태 일부를 tls에 기록해 두어야 한다. </p><p>친절한 ms 형들이 이런 경우를 위해 <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.asynclocal-1?view=net-5.0">AsyncLocal</a> 클래스도 미리 만들어 두었다. 생긴것도 서로 비슷해서  <code>ThreadLocal&lt;T&gt;</code> 를 사용했던 변수에 대신 <code>AsyncLocal&lt;T&gt;</code> 로 바꿔주면 위에서 말한 문제를 해결할 수 있다. 0번 스레드가 먼저 코드를 수행하다가 await 구문을 만나서 대기하고, 대기가 풀려날 때 2번 스레드로 변경이 되었더라도 <code>AsyncLocal&lt;T&gt;</code> 가 2번 스레드의 tls 값을 알아서 “영희” -&gt; “철수”로 바꿔주는 것이다. </p><img src="/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/02.png" class=""><h2 id="문제점-의도치-않게-값의-복사-발생"><a href="#문제점-의도치-않게-값의-복사-발생" class="headerlink" title="문제점 : 의도치 않게 값의 복사 발생"></a>문제점 : 의도치 않게 값의 복사 발생</h2><p>이러면 문제는 해결된 것 같지만, 또 다른 문제가 있다. 여기가 이 글의 핵심이다 집중해주기 바란다. <code>AsyncLocal&lt;T&gt;</code>는 <strong>ThreadPool이 다른 새 스레드를 추가로 깨우게 하는 특정 api들 중에 하나를 호출하는 경우, 기본적으로 호출자 스레드의 변수값을 새로운 스레드에게 복사해주는 기본 동작을 갖고 있다.</strong> 현재 스레드에서만 고유하게 유지하려고 기록해 둔 tls의 변수들이 요주의 api중 하나를 호출하는 순간 새로운 다른 스레드로 복사되는 것이다. 현재 우리 프로젝트 구현의 범위 기준에서, AsyncLocal의 값을 복사시키는 메서드들은 아래와 같다.</p><ol><li><p>Fire-and-forgot 으로 동작할 백그라운드 작업이 필요해서 직접 ThreadPool에 요청하는 메서드들 </p><ul><li>Task.Run()</li><li>ThreadPool.QueueUserWorkItem()</li></ul></li><li><p>비동기 소켓의 IO 완료통지를 포함해, 네트워크 이벤트 콜백을 유발하는 메서드들</p><ul><li>Socket.ConnectAsync() - ConnectEx() in win32</li><li>Socket.DisconnectAsync() - DisconnectEx() in win32</li><li>Socket.AcceptAsync() - AcceptEx() in win32</li><li>Socket.ReceiveAsync() - WSARecv() in win32</li><li>Socket.SendAsync() - WSASend() in win32</li></ul></li></ol><p>1번 백그라운드 작업 요청 메서드들은 스레드풀을 대상으로 하는 동작이니까 어느 정도 이해가 된다고 하지만, 2번 네트워크 콜백들은 tls를 복사한다는 점이 선뜻 연결이 잘 되지 않는다. managed 메서드의 이름이 낮설어 보일까 싶어 win32에 해당하는 함수명도 같이 적었는데, 그냥 OVERLAPPED 구조체를 이용해 IOCP에 통지를 요청하는 네트워크 api들 전체를 말한다. </p><p>0번 스레드가 게임 로직을 열심히 수행하다가 클라이언트로 동기화 패킷을 보낼 상황이 되었다. 그래서 패킷을 만들어 소켓에 SendAsync()를 한 번 걸어놓고, 다시 또 다른 로직을 열심히 수행한다. 근데 0번 스레드가 걸었던 send 요청이 완료되어 새롭게 2번 스레드가 OnSendCompleted 메서드를 실행하려고 깨어났는데, 이 때 0번 스레드가 <code>AsyncLocal&lt;T&gt;</code>에 저장해두었던 tls 값들을 2번 스레드가 고대로 복사받아서 수행을 시작하는 것이다.</p><p><code>AsyncLocal&lt;T&gt;</code>는 자신의 존재 목적과 취지에 충실하고자, 서로 다른 스레드들간에 조금이라도 관련이 있을라 치면 아주 얄짤없이 값을 복사해대는 것 같다. 하지만 win32에서 iocp에 비동기 작업의 완료 통지를 요청하고, 전혀 관련없는 다른 스레드로부터 이를 받아 처리해오던 고전적 처리방식에 익숙해서 그런지 이런 과도한 친절이 부담스럽다. 너 때문에 Dispatcher 동작이 다 깨지잖아. 조치가 필요하다.</p><h2 id="원치-않는-AsyncLocal-복사는-꺼준다"><a href="#원치-않는-AsyncLocal-복사는-꺼준다" class="headerlink" title="원치 않는 AsyncLocal 복사는 꺼준다."></a>원치 않는 AsyncLocal 복사는 꺼준다.</h2><p>다행히 이 동작은 ExecutionContext.SuppressFlow &#x2F; RestoreFlow 라는 메서드가 있어 쉽게 제어가 가능하다. 우선 스레드풀에 백그라운드 작업을 요청할 때는 <code>SuppressFlow()</code> 호출이 묶여있는 별도의 인터페이스를 만들고 이를 사용하게 한다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BackgroundJob</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">Action action</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> control = ExecutionContext.SuppressFlow();</span><br><span class="line">    ThreadPool.QueueUserWorkItem(_ =&gt; action());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 백그라운드 작업이 필요할 때. Wrapping한 인터페이스를 사용한다. </span></span><br><span class="line">    BackgroundJob.Execute(() =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">$&quot;a + b = <span class="subst">&#123;a+b&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작업 요청 후에는 <code>RestoreFlow</code> 를 불러 복구해주면 되는데, <code>SuppressFlow</code> 메서드가 IDisposable인  <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.asyncflowcontrol?view=net-5.0">AsyncFlowControl</a> 객체를 반환하니까 예시처럼 using을 쓰면 좀 더 심플하게 처리할 수 있다.</p><p>네트워크 구현부에도 수정이 필요하다. <code>SocketAsyncEventArgs</code> 객체를 사용해 비동기 요청을 수행하는 모든 곳에도 <code>RestoreFlow</code> 를 불러준다. (<code>SocketAsyncEventArgs</code>는 win32의 <code>OVERLAPPED</code> 구조체를 거의 그대로 랩핑해둔 클래스다.) 예시로 하나만 옮겨보면 아래처럼 된다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ConnectionBase</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectAsync</span>(<span class="params">IPAddress ip, <span class="built_in">int</span> port</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">args</span> = <span class="keyword">new</span> SocketAsyncEventArgs();</span><br><span class="line">    <span class="keyword">args</span>.Completed += <span class="keyword">this</span>.OnConnectCompleted; <span class="comment">// 이 메서드가 새로운 스레드에서 불리게 될 것이다.</span></span><br><span class="line">    <span class="keyword">args</span>.RemoteEndPoint = <span class="keyword">new</span> IPEndPoint(ip, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> control = ExecutionContext.SuppressFlow(); <span class="comment">// 이걸 넣어주어야 콜백 스레드로 AsyncLocal을 복사하지 않는다.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.socket.ConnectAsync(<span class="keyword">args</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.OnConnectCompleted(<span class="keyword">this</span>.socket, <span class="keyword">args</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 SendAsync, RecvAsync 등도 다 막아주어야 일반적인 iocp 콜백 사용 방식과 동일해진다. 다른 코드상에서 아무데도 <code>AsyncLocal&lt;T&gt;</code>을 사용중이지 않다면 굳이 SuppressFlow 호출이 없어도 동작에는 문제가 없다. 그래도 어차피 사용하지도 않을 암묵적인 실행 컨텍스트간 연결 동작은 그냥 끊어두는 것이 성능상 조금이라도 이득일 듯한 기분이 든다. </p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>C#의 비동기 메서드는 코드상으로는 매끈하게 이어져 있는듯 보이지만 실은 비동기 요청 지점을 전후로 분리 실행되며, 실행 스레드가 서로 다를 수도 있다.</li><li>이로 인해 <code>ThreadLocal&lt;T&gt;</code> 로는 비대칭적(asymmetric)인 tls 데이터를 다루기가 어렵기 때문에 <code>AsyncLocal&lt;T&gt;</code>라는 클래스가 별도로 존재한다.</li><li><code>AsyncLocal&lt;T&gt;</code>는 스레드풀에서 새로운 다른 스레드를 깨어나게 할 때도 값을 복사시킨다. 이는 <code>ExecutionContext.SuppressFlow()</code> 로 제어가 가능하다.</li></ul><p>현재 사용중인 게임서버의 스레드 모델도 승모님의 JobDispatcher와 유사한 Actor 기반 구조를 채택해서 락 없이 구현하고 있다. 지금 서버 구현 기준에서 값이 복사되는 tls 변수가 문제를 일으키는 케이스는 액터를 구현하기 위한 로직 한 군데 뿐이다. 일반적으로 게임 서버를 구현할 때 스레드별로 비대칭적인(asymmetric) tls 변수를 유지해야 하는 경우가 흔치는 않을 것이다. 액터 패턴을 구현한다고 해서 tls 변수가 반드시 필수적인 것도 아니다. 이전 프로젝트에서 tls를 사용하지 않는 액터 구현도 사용해본 적이 있기 때문이다.</p><p>하지만 고성능 서버를 목표로 스레드 효율성을 튜닝한다면 반드시 사용을 염두에 두게 되는 도구가 TLS이므로, 본 글에서 언급한 내용을 숙지하고 있으면 성능 튜닝에서 많은 삽질을 세이브 하게 될것이다.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Thread/">Thread</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/AsyncLocal/">AsyncLocal</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/TLS/">TLS</category>
      
      
      <comments>http://leafbird.github.io/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - System.IO.Pipeline 도입 후기</title>
      <link>http://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/</guid>
      <pubDate>Sun, 27 Dec 2020 08:34:58 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/00.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;2018년에 네트워크 레이어 성능을 끌어올리기 위해 도입했던 System.IO.Pipeline을 간단히 소개하고, 도입 후기를 적어본다. &lt;/p&gt;
&lt;p&gt;윈도우 OS에서 고성능을 내기 위한 소켓 프로그래밍을 할 때 IOCP 의 사용은 오래도록 변하지 않는 정답의 자리를 유지하고 있다. 여기에서 좀 더 성능에 욕심을 내고자 한다면 Windows Server 2012부터 등장한 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh997032(v=ws.11)&quot;&gt;Registerd IO&lt;/a&gt; 라는 새로운 선택지가 있다. 하지만 API가 C++ 로만 열려 있어서, C# 구현에서는 사용하기가 쉽지 않다. &lt;/p&gt;
&lt;p&gt;하지만 C#에도 고성능 IO를 위한 새로운 API가 추가되었다. &lt;a href=&quot;https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines&quot;&gt;Pipeline&lt;/a&gt; 이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/00.jpg" class=""><p>2018년에 네트워크 레이어 성능을 끌어올리기 위해 도입했던 System.IO.Pipeline을 간단히 소개하고, 도입 후기를 적어본다. </p><p>윈도우 OS에서 고성능을 내기 위한 소켓 프로그래밍을 할 때 IOCP 의 사용은 오래도록 변하지 않는 정답의 자리를 유지하고 있다. 여기에서 좀 더 성능에 욕심을 내고자 한다면 Windows Server 2012부터 등장한 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh997032(v=ws.11)">Registerd IO</a> 라는 새로운 선택지가 있다. 하지만 API가 C++ 로만 열려 있어서, C# 구현에서는 사용하기가 쉽지 않다. </p><p>하지만 C#에도 고성능 IO를 위한 새로운 API가 추가되었다. <a href="https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines">Pipeline</a> 이다.</p><span id="more"></span><h2 id="System-IO-Pipeline-소개"><a href="#System-IO-Pipeline-소개" class="headerlink" title="System.IO.Pipeline 소개."></a>System.IO.Pipeline 소개.</h2><p>pipeline을 처음 들었을 때는 IOCP의 뒤를 잇는 새로운 소켓 API인줄 알았다. C++의 RIO가 iocp를 완전히 대체할 수 있는 것처럼.</p><p>RIO는 가장 핵심 요소인 <code>등록된 버퍼(registered buffer)</code> 외에, IO 요청 및 완료 통지 방식도 함께 제공하기 때문에 iocp를 완전히 드러내고 대신 사용할 수 있다. 반면 Pipeline은 RIO보다는 커버하는 범위가 좁아서, IOCP를 완전히 대체하는 물건이 될 수는 없다. 이벤트 통지는 기존의 방법들을 이용하면서, 메모리 버퍼의 운용만을 담당하는 라이브러리 이기 때문에 IOCP와 반드시 함께 사용해야 한다.</p><p>Pipeline이라는 이름을 굉장히 잘 지었다. 이름처럼 <strong>메모리 버퍼를 끝없이 연결된 긴 파이프라인처럼 쓸 수 있게 해주는 라이브러리</strong> 이기 때문이다. 단위길이 만큼의 버퍼를 계속 이어붙여서 무한하게 이어진 가상의 버퍼를 만드는데, 이걸 너네가 만들면 시간도 오래 걸리고 버그도 넘나 많을테니 우리가 미리 만들었어. 그냥 가져다 쓰렴. 하고 내놓은 것이 Pipeline이다.</p><img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/01.png" class=""><p>(이미지 출처 : <a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">devblogs.microsoft.com</a>)</p><p>이미지의 초록색 부분은 <code>class Pipe</code> 의 내부 구조를 도식화한다. 일정한 크기의 작은 버퍼들이 링크드 리스트로 연결 되어있다. 내부 구조는 안에 숨겨져있고 외부로는 <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.readonlysequence-1?view=net-5.0">ReadOnlySequence<T></a> 타입을 이용해 버퍼간 이음매가 드러나지 않는 seamless한 인터페이스만을 제공한다. 이것이 Pipeline의 핵심이다.</p><p>이 외의 디테일한 부분은 Pipeline을 이해하기 쉽게 잘 설명한 <a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">MS 블로그의 포스팅</a>이 있어 이것으로 대신한다.</p><h2 id="장점-불필요한-메모리-복사를-없앤다"><a href="#장점-불필요한-메모리-복사를-없앤다" class="headerlink" title="장점 : 불필요한 메모리 복사를 없앤다."></a>장점 : 불필요한 메모리 복사를 없앤다.</h2><p>고성능 소켓 IO 구현에 관심이 있는 C++ 프로그래머라면 google protobuf의 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.zero_copy_stream">ZeroCopyStream</a> 을 이미 접해봤을지 모른다. 그렇다면 Pipeline의 중요한 장점을 쉽게 이해할 것이다. Pipeline의 버퍼 운용 아이디어는 프로토콜 버퍼의 ZeroCopyStream과 유사하기 때문이다. 소켓으로 데이터를 주고 받는 과정에서 발생하는 불필요한 버퍼간 메모리 복사를 최소한으로 줄여주어 성능향상을 꾀한다는 점에서 두 라이브러리가 추구하는 방향은 동일하다. </p><p>프로그래밍에 미숙한 개발자가 만든 서버일수록 버퍼간 복사 발생이 빈번하게 발생한다. 커널모드 아래에서 일어나는 소켓버퍼와 NIC 버퍼간의 복사까지는 일단 관두더라도, 최소한 유저모드 위에서의 불필요한 버퍼 복사는 없어야 한다. </p><p> 전송할 데이터 타입을 버퍼로 직렬화 하면서 한 번 복사하고, 이걸 소켓에다가 send 요청을 하자니 OVERLAPPED에 연결된 버퍼에다가 넣어줘야 해서 추가로 또 복사하고… send 완료 통지 받고 나면 transferred bytes 뒤에 줄서있을 미전송 데이터들을 다시 앞으로 당겨주느라 또 한번 복사가 발생하기 쉽다. recv 받은 뒤에도 메시지 단위 하나 분량 만큼만 읽어 fetching하고 나면 뒤에 남은 데이터들을 버퍼 맨 앞으로 당겨와야겠으니… 여기서 또 한 번 추가복사 하게 될것이다.</p><p>서버가 감당할 통신량이 많아질수록 불필요한 복사들이 누적되어 쓸데없이 cpu power를 낭비하게 될텐데, Pipeline의 도입은 이런 부분을 쉽게 해결해 준다. msdn 블로그에서는 Pipeline을 사용하면 복잡한 버퍼 운용 구현을 대신 해결해주니까 프로그래머가 비즈니스 로직의 구현에 좀 더 집중할 수 있게 도와준다고 <del>약을 팔고</del> 설명하고 있다.</p><h2 id="장점-네트워크-버퍼의-고정길이-제약을-없애준다"><a href="#장점-네트워크-버퍼의-고정길이-제약을-없애준다" class="headerlink" title="장점 : 네트워크 버퍼의 고정길이 제약을 없애준다."></a>장점 : 네트워크 버퍼의 고정길이 제약을 없애준다.</h2><p>가장 단순하게 소켓 레이어를 구현하면 송&#x2F;수신용 고정 사이즈 <code>byte[]</code> 버퍼를 각각 하나씩 붙여서 만들게 될 것이다. 대략 구현중인 게임이 어느 정도 사이즈의 패킷을 주고 받는지를 <strong>귀납적</strong>으로 파악해서 (주로 게임 서버는 작은 사이즈 패킷을 많이 받고, 큰 사이즈 패킷을 많이 보낸다. 로그인할때, 캐릭터 선택할 때 보내는 패킷이 통상 제일 크다) 버퍼의 크기를 눈치껏 결정해서 <code>상수로 고정한다</code>. 버퍼를 거거익선으로 크게크게 잡으면 좋겠지만 대량의 동접을 처리해야 할때 메모리 사용량이 높아져서 부담이 된다. 그러니 적당히 오가는 패킷 사이즈를 봐서 터지지만 않을 정도의 고정길이 버퍼를 걸어두는 식으로 만들게 된다.</p><p>이렇게 만들면 불안하다. 컨텐츠를 점점 추가하다가 언젠가 한 두번은 네트워크 버퍼 overflow가 발생해 버퍼 크기를 늘려잡고 다시 빌드해야 하기 일쑤다. 아니면 버퍼를 넘치게 만든 문제 패킷의 구조를 변경하거나 두 개의 패킷으로 쪼개는 등 다이어트를 시켜서 해결할 수도 있겠다. 어느쪽이든 고성능 서버의 네트워크 레이어 구현으로는 적당하지 않은 솔루션이다. 메모리를 더 써서 해결하거나, 개발에 제약(패킷의 최대 크기)을 두어 해결하거나. 모두 석연치 않다.</p><p>Pipeline과 ZeroCopyStream 의 무한버퍼 컨셉은 이러한 고정길이 버퍼의 단점을 해결해준다. 처음엔 작은 크기의 버퍼만 가지고 있다가, 공간이 모자라면 추가로 더 할당받아 링크드 리스트 뒤에 붙이기만 하면 된다. 각각의 peer(&#x3D; single socket)가 실제 사용하는 메모리 공간은 주고받는 데이터의 크기에 따라서 늘어나거나 줄어드는 유연성이 생긴다. 메모리를 효율적으로 사용하면서도 단일 메시지의 사이즈 제약도 없어진다.</p><h2 id="단점-너무-많은-Task를-생성한다"><a href="#단점-너무-많은-Task를-생성한다" class="headerlink" title="단점 : 너무 많은 Task를 생성한다."></a>단점 : 너무 많은 Task를 생성한다.</h2><p>위의 두가지 장점만으로 Pipeline의 도입을 시도해볼 가치는 충분했다. 그래서 우리는 게임서버의 수신 버퍼를 Pipeline으로 대체하고, MS Azure 에서 F8s 급 인스턴스 수십대를 동원해 10만 동접 스트레스 테스트를 진행해 보았다. </p><p>결과는 기대와 완전히 달랐는데.. <strong>Pipeline 도입 전보다 영 더 못한 성능을 보여줬다</strong>. 이건 뭐… cpu 사용량이 높고 낮아지는 것이 문제가 아니라, 동접이 일정수치 이상 오르면 서버가 아무 일도 처리하지 않고 멈춰버렸다. 반응없는 프로세스에서 덤프를 떠서 디버거로 살펴보면… 대기상태인 스레드가 잔뜩 생겨있고, 일해야 할 스레드가 부족해서 추가 스레드를 계속해서 만들어내고 있는 것처럼 보였다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msdn 블로그에 소개된 코드 일부 발췌. Pipe를 하나 만들면 읽기/쓰기 Task를 2개 만든다.</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">ProcessLinesAsync</span>(<span class="params">Socket socket</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pipe = <span class="keyword">new</span> Pipe();</span><br><span class="line">    Task writing = FillPipeAsync(socket, pipe.Writer);</span><br><span class="line">    Task reading = ReadPipeAsync(pipe.Reader);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Task.WhenAll(reading, writing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원인은 Pipeline과 함께 사용하는 task (System.Threading.Tasks.Task) 들이었다.  <code>class Pipe</code> 인스턴스 하나를 쓸 때마다 파이프라인에 ‘읽기’와 ‘쓰기’를 담당하는 <code>class Task</code> 객체 두 개를 사용하게 된다. 수신버퍼에만 Pipe를 달면 소켓의 2배, 송수신 버퍼에 모두 달면 소켓의 4배수 만큼의 task가 생성 되어야 하기 때문이다. 게임서버 프로세스당 5,000 명의 동접을 받는다고 하면 최대 20,000개의 task가 생성되고, 이 중 상당수는 waiting 상태로 IO 이벤트를 기다리게 된다.</p><p>task가 아무리 가볍다고 해도 네트워크 레이어에만 몇 만개의 task를 만드는 것은 그리 효율적이지 않다. TPL에 대한 이야기를 시작하면 해야 할 말이 아주 많기 때문에 별도의 포스팅으로 분리해야 할 것이다. 과감히 한 줄로 정리해보면, task는 상대적으로 OS의 커널오브젝트인 스레드보다 가볍다는 것이지 수천 수만개를 만들만큼 깃털같은 물건은 아닌 것이다.</p><p>스레드가 코드를 한 단계씩 수행하다가 아직 완료되지 않은 task를 await 하는 구문을 만나면 호출 스택을 한 단계씩 거꾸로 올라가면서 동기 로직의 수행을 재개한다. 하지만 완료되지 않은 task를 만났다고 해서 그 즉시 task의 완료 및 반환값 획득을 포기하고 호출스택을 거슬러 올라가는 것은 아니다. 혹시 금방 task가 완료되지 않을까 하는 기대감으로 조금 대기하다가 완료될 기미가 보이지 않으면 그 제서야 태세를 전환하게 된다. 이 전략은 task가 동시성을 매끄럽게 처리하기 위해서는 바람직한 모습이지만, 아주 많은 개수의 task를 장시간(게임서버에서 다음 패킷을 받을 때까지의 평균 시간) 동안 대기시켜야 하는 네트워크 모델에 사용하기에는 적합하지 않다. 스레드들은 각 pipeline의 write task가 RecvComplete 통지를 받고 깨어나기를 기다리면서 수십만 cpu clock을 낭비하게 된다.</p><h2 id="의문-Kestrel은-Pipeline-때문에-엄청-빨라졌는데"><a href="#의문-Kestrel은-Pipeline-때문에-엄청-빨라졌는데" class="headerlink" title="의문 : Kestrel은 Pipeline 때문에 엄청 빨라졌는데?"></a>의문 : Kestrel은 Pipeline 때문에 엄청 빨라졌는데?</h2><img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/02.png" class=""><p>(이미지 출처 : <a href="https://stackoverflow.com/questions/34440649/iis-vs-kestrel-performance-comparison">stackoverflow.com</a>)</p><p>ASP.NET Core는 Pipeline으로 구현한 kestrel 웹서버에서 실행할 때 기존의 iis 기반보다 훨씬 더 향상된 퍼포먼스를 보여준다. Pipeline의 버퍼 운용 효율성으로 인한 이득을 제대로 누리고 있는 것이다. kestrel의 뛰어난 성능 결과를 보여주는 여러 벤치마크 결과들 덕분에 나도 기대를 가득 안고 서둘러 Pipeline을 도입하고 테스트 해보았으나.. 결과는 좋지 않았다.</p><p>그럼 우리 게임서버에 도입한 테스트 결과는 왜 이리 처참한 것인가? ms 형들이 잘못 만들었을 리는 없으니 내가 가져다 붙이는 과정에 문제가 있었던 것인가? </p><p>차이가 생기는 원인은 <strong>Kestrel은 http 통신을 하는 웹서버이고, 우리의 게임서버는 연결을 유지하고 있는 TCP 서버이기 때문</strong>이다. Kestrel은 통신량의 거의 전부가 socket이 열린 채로 길게 대기할 필요가 없기 때문에, task을 소켓의 2배수나 4배수만큼 오래도록 유지하고 있을 이유 자체가 없다. 그래서 단점으로 지적한 waiting task가 kestrel에서는 발생하지 않는다. 상술했던 단점을 다시 표현해 보자면 <strong>Pipeline의 사용시 기본적으로 task 대기가 발생하는 것을 성능 하락의 원인으로 볼 수 있지만, 이 task들의 수명 혹은 대기시간이 상당히 길다는 점과 함께 만나면 성능을 더욱 악화시키는 원인이 된다</strong>. Kestrel의 단명하는(?) 소켓들과 task들은 Pipeline와 함께 사용되면서 충분히 좋은 성능을 가져다 줄 것이다. 수많은 벤치마킹 결과들이 증명하듯이.</p><h2 id="대안-불필요한-복사가-없는-가변버퍼를-직접-만들자"><a href="#대안-불필요한-복사가-없는-가변버퍼를-직접-만들자" class="headerlink" title="대안 : 불필요한 복사가 없는 가변버퍼를 직접 만들자."></a>대안 : 불필요한 복사가 없는 가변버퍼를 직접 만들자.</h2><p>우리는 게임서버에서 Pipeline을 다시 드러냈다. http와 유사하게 single pair request&#x2F;response 통신 후 소켓을 닫아도 되는 경우가 아니면 Pipeline으로 성능상의 혜택을 보기는 힘들다고 판단했기 때문이다. 그래도 불필요한 메모리복사는 만들고 싶지 않으니 메모리 버퍼 운용하는 부분만 직접 구현해 사용하기로 했다.</p><img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/03.png" class=""><p>클래스 이름이 Pipeline과 protobuf를 모두 가져다 섞어놓은 느낌이 들겠지만 착각일 뿐이다. 두 api를 모두 사용해본 경험의 영향을 받긴 했지만… *Stream.cs 클래스들은 실제로 <code>System.IO.Stream</code>을 상속받아서 이름이 좀 비슷해졌다. 이 Stream 구현들이 단위버퍼들간의 연결을 seamless하게 쓸 수 있게해주는 역할을 한다. 주요 구현을 담고 있으나 사용계층에 노출될 필요는 없기 때문에 Detail 아래로 숨겨두었다. 사용자는 부모타입인 Stream 추상 클래스만 보게 된다.</p><p>인터페이스로 <code>ReadOnlySequence&lt;T&gt;</code>를 사용하지 않은 이유는 이 구현을 Unity3D로 만든 클라이언트에서도 똑같이 사용하기 위해서였다. 현시점 유니티의 mono framework가 지원하는 C# 문법 버전이 낮아서 <code>ReadOnlySequence&lt;T&gt;</code>를 지원하지 않기 때문이다. 그런데 Stream 을 이용해도 어렵지 않게 seamless 를 구현할 수 있었고, 실제 사용하기에도 스트림 형태가 훨씬 익숙하고 편해서 결과적으로는 더 만족스러운 선택이었다. <code>ReadOnlySequence&lt;T&gt;</code> 가 뭔지 모르는 프로그래머도 Stream은 알고 있을 것이다.</p><p>실제 사용 계층으로 노출하는 클래스는 아래의 세 클래스 만으로 정리했다. </p><ul><li><code>MemoryPipe</code> : 소켓 수신버퍼 처리 전용. System.IO.Pipeline과 유사하다.</li><li><code>SendBuffer</code> : 소켓 송신버퍼 처리 전용. </li><li><code>ZeroCopyBuffer</code> : 네트워크 버퍼가 아닌 범용적인 용도의 인터페이스.</li></ul><p>패킷을 보낼때는 데이터 타입을 버퍼로 직렬화 한 후, 이 버퍼를 메모리 복사 없이 소켓에 그대로 연결해주기 위한 추가 처리가 있어야 하는데, 이건 송신 버퍼에만 필요한 동작이라서 클래스를 별도로 나누었다. 각 용도에 특화된 메서드가 추가 구현 되어있을 뿐 코어는 모두 비슷하다. 모두 단위 버퍼를 줄줄이 비엔나처럼 연결해 들고 있는 역할을 한다.</p><p>이들 중에 가장 기본이 되는 ZeroCopyBuffer 를 조금 보면 아래와 같다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.ServerEngine.Network.Buffer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ZeroCopyBuffer</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Queue&lt;LohSegment&gt; segments = <span class="keyword">new</span> Queue&lt;LohSegment&gt;();</span><br><span class="line">    <span class="keyword">private</span> LohSegment last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SegmentCount =&gt; <span class="keyword">this</span>.segments.Count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CalcTotalSize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> data <span class="keyword">in</span> <span class="keyword">this</span>.segments)</span><br><span class="line">      &#123;</span><br><span class="line">        result += data.DataSize;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryWriter <span class="title">GetWriter</span>()</span> =&gt; <span class="keyword">new</span> BinaryWriter(<span class="keyword">new</span> ZeroCopyOutputStream(<span class="keyword">this</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryReader <span class="title">GetReader</span>()</span> =&gt; <span class="keyword">new</span> BinaryReader(<span class="keyword">new</span> ZeroCopyInputStream(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params"><span class="built_in">byte</span>[] buffer, <span class="built_in">int</span> offset, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.last == <span class="literal">null</span> || <span class="keyword">this</span>.last.IsFull)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">this</span>.last = LohSegment.Create(LohPool.SegmentSize.Size4k);</span><br><span class="line">          <span class="keyword">this</span>.segments.Enqueue(<span class="keyword">this</span>.last);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> copied = <span class="keyword">this</span>.last.AddData(buffer, offset, count);</span><br><span class="line"></span><br><span class="line">        offset += copied;</span><br><span class="line">        count -= copied;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> LohSegment[] <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">this</span>.segments.ToArray();</span><br><span class="line">      <span class="keyword">this</span>.segments.Clear();</span><br><span class="line">      <span class="keyword">this</span>.last = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> LohSegment <span class="title">Peek</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.segments.Peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">PopHeadSegment</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> segment = <span class="keyword">this</span>.segments.Dequeue();</span><br><span class="line">      segment.ToRecycleBin();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.segments.Count == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>본 주제와 관련한 인터페이스만 몇 개 간추려 보았다. <code>Queue&lt;LogSegment&gt;</code> 가 Pipeline 안에 있는 단위버퍼의 링크드 리스트 역할을 한다. Write()와 Move()는 메모리 복사 없이 데이터를 쓰는 인터페이스가 되고, Peek(), PopHeadSegment()는 데이터를 읽는 인터페이스가 되는데, internal 접근자니까 실제 사용계층에는 노출하지 않는다. Detail 하위의 *Stream 클래스를 위한 메서드들이다.</p><p>조각난 버퍼를 하나의 가상버퍼처럼 추상화해주는 로직은 *Stream들이 담고있다. System.IO.Stream을 상속했기 때문에 사용 계층에서는 보통의 파일스트림, 메모리 스트림을 다루던 방식과 똑같이 값을 읽고 쓰면 된다. 사용한 segment들을 새지 않게 잘 pooling하고, 버퍼 오프셋 계산할때 오차없이 더하기 빼기 잘해주는 코드가 전부인지라 굳이 옮겨붙이지는 않는다. </p><p>이렇게 하니 <code>ZeroCopyBuffer</code>는 가상의 무한 버퍼 역할을 하고, 사용 계층에는 Stream 형식의 인터페이스를 제공하는 <code>System.IO.Pipeline</code>의 유사품이 되었다. 제공되는 메서드 중에는 <code>async method</code> 가 하나도 없으니 cpu clock을 불필요하게 낭비할 일도 없다. 이렇게 디자인 하는것이 기존의 iocp 기반 소켓 구현에 익숙한 프로그래머에겐 더 친숙한 모델이면서, 성능상으로도 Pipeline보다 훨씬 낫고(tcp 기반 게임서버 한정), Unity3D처럼 최신의 Memory api가 지원 안되는 환경에서도 문제없이 사용할 수 있다.</p><h2 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h2><p><code>System.IO.Pipeline</code>은 ASP.NET Core의 성능을 크게 끌어올린 네트워크 버퍼 운용 라이브러리다. 이를 적용하면 네트워크 버퍼구현의 여러가지 문제점들과 boilerplate한 구현들을 손쉽게 해결할 수 있으나, 최소 2 tasks&#x2F;peer를 소켓의 수명만큼 열어두어야 하기 때문에 소켓을 긴 시간 유지하는 타입의 TCP서버라면 도입 전에 신중한 성능 테스트를 거쳐야 한다. </p><p>사이즈가 무한인 가상의 버퍼라는 컨셉만을 가져와 직접 만들어 사용중인 <code>ZeroCopyBuffer</code> 모듈의 인터페이스도 간단하게 소개해 보았다. Unity3D 클라이언트 네트워크 모듈에도 함께 사용하기 위해 <code>ReadOnlySequence&lt;T&gt;</code> 대신 System.IO.Stream으로 추상화한 인터페이스를 제공했는데, 이렇게 하니 요구사항을 충분히 만족하면서도 사용 계층에게는 더 익숙한 형태의 인터페이스를 제공할 수 있어서 만족스러웠다.</p><p>본 포스팅에는 단위버퍼로 이용한 구현체인 <code>LohSegment</code>에 대한 소개가 없었다. 글 분량 조절에 실패하여 일부로 언급하지 않았는데, 다음에 가비지 컬렉터를 주제로 포스팅하면서 추가로 다뤄볼 예정이다. </p><p>참고:</p><ul><li><a href="https://www.slideshare.net/sm9kr/windows-registered-io-rio">https://www.slideshare.net/sm9kr/windows-registered-io-rio</a></li><li><a href="https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines">https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines</a></li><li><a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Network/">Network</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Socket/">Socket</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Pipeline/">Pipeline</category>
      
      
      <comments>http://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - __FILE__, __LINE__ 대체제</title>
      <link>http://leafbird.github.io/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/</link>
      <guid>http://leafbird.github.io/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/</guid>
      <pubDate>Sat, 26 Dec 2020 02:11:05 GMT</pubDate>
      
      <description>&lt;p&gt;C++에서 가장 기본적으로 사용했던 &lt;code&gt;__FILE__, __LINE__, __FUNCTION__&lt;/code&gt; 등의 매크로와 유사한 효과를 내는 방법에 대해 적어본다. 이와 함께 나에게는 생소했던 string interning 개념에 대해서도 살짝 소개해본다. 자바 같은 managed 언어를 깊이 다뤄본 적이 없는 네이티브 개발자에게는 생소한 개념일 것이다.&lt;br&gt;UI가 없는 서버에서 동작의 내용을 확인하는 가장 기본적인 방법은 file로 남기는 log다. 정상 동작이나 오류상황에 대한 상세한 로그가 남아야 문제가 생겼을 때 파악하기가 쉽기 때문에, 간단한 동작이지만 아주 빈번하게 호출되는 부분이다. 로그 출력에서 성능을 많이 빼앗기지 않도록 기반을 다져놓으면 비즈니스 로직 구현을 위해 더 많은 H&amp;#x2F;W 리소스를 배분할 수 있다.&lt;/p&gt;
&lt;p&gt;성능을 굳이 신경쓰지 않는다면 아래 있는 내용을 끝까지 모두 적용할 필요는 없다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>C++에서 가장 기본적으로 사용했던 <code>__FILE__, __LINE__, __FUNCTION__</code> 등의 매크로와 유사한 효과를 내는 방법에 대해 적어본다. 이와 함께 나에게는 생소했던 string interning 개념에 대해서도 살짝 소개해본다. 자바 같은 managed 언어를 깊이 다뤄본 적이 없는 네이티브 개발자에게는 생소한 개념일 것이다.<br>UI가 없는 서버에서 동작의 내용을 확인하는 가장 기본적인 방법은 file로 남기는 log다. 정상 동작이나 오류상황에 대한 상세한 로그가 남아야 문제가 생겼을 때 파악하기가 쉽기 때문에, 간단한 동작이지만 아주 빈번하게 호출되는 부분이다. 로그 출력에서 성능을 많이 빼앗기지 않도록 기반을 다져놓으면 비즈니스 로직 구현을 위해 더 많은 H&#x2F;W 리소스를 배분할 수 있다.</p><p>성능을 굳이 신경쓰지 않는다면 아래 있는 내용을 끝까지 모두 적용할 필요는 없다. </p><span id="more"></span><h2 id="콜스택을-얻어와서-가장-마지막-함수를-찍는-방법"><a href="#콜스택을-얻어와서-가장-마지막-함수를-찍는-방법" class="headerlink" title="콜스택을 얻어와서 가장 마지막 함수를 찍는 방법"></a>콜스택을 얻어와서 가장 마지막 함수를 찍는 방법</h2><p>현재 스레드 컨텍스트에서의 <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.diagnostics.stackframe?redirectedfrom=MSDN&view=net-5.0">StackFrame</a> 정보를 얻어온 후, 프레임 데이터의 가장 마지막 부분을 읽어 호출자의 정보를 얻어낼 수 있다. C#으로 함수 호출 위치를 얻어올 때 가장 많이 쓰이는 방법이다. 가장 태초부터 있었던 방법이기 때문이다. 다음에 설명할 CompilerServices attribute는 .Net Framework 4.5부터 사용이 가능해졌기 때문에, 초창기 C#에서는 콜스택에서 읽어내는 방법 말고는 딱히 다른 선택지도 없었다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StackTrace st = <span class="keyword">new</span> StackTrace(<span class="keyword">new</span> StackFrame(<span class="literal">true</span>)); </span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Stack trace for current level: &#123;0&#125;&quot;</span>, st.ToString()); </span><br><span class="line"></span><br><span class="line">StackFrame sf = st.GetFrame(<span class="number">0</span>); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; File: &#123;0&#125;&quot;</span>, sf.GetFileName()); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; Method: &#123;0&#125;&quot;</span>, sf.GetMethod().Name); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; Line Number: &#123;0&#125;&quot;</span>, sf.GetFileLineNumber()); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; Column Number: &#123;0&#125;&quot;</span>, sf.GetFileColumnNumber()); </span><br></pre></td></tr></table></figure><p>C#에서 흔하게 사용하는 로깅 라이브러리인 <a href="https://logging.apache.org/log4net/">Log4Net</a>, <a href="https://nlog-project.org/">NLog</a> 등에서도 이 방법을 사용한다. </p><h4 id="콜스택-기반-장점-가장-범용적이다-프레임워크-호환성이-가장-좋음"><a href="#콜스택-기반-장점-가장-범용적이다-프레임워크-호환성이-가장-좋음" class="headerlink" title="콜스택 기반 장점 : 가장 범용적이다. 프레임워크 호환성이 가장 좋음"></a>콜스택 기반 장점 : 가장 범용적이다. 프레임워크 호환성이 가장 좋음</h4><p>.Net Framework의 태초부터 있었던 방식이므로 가장 범용적이다. 오래된 버전의 닷넷 프레임워크나 mono 프레임워크 등을 지원해야 하는 상황이라면 이 방법 말고는 마땅한 대안이 없다. 그래서 Log4Net, NLog 등의 유명한 라이브러리도 이 방법을 사용하고 있다. 이들은 불특정 다수의 환경에서 실행되어야 할 범용성이 중요한 모듈이기 때문이다. </p><h4 id="콜스택-기반-단점-말해서-무엇하랴-비용이-비싸고-느리다"><a href="#콜스택-기반-단점-말해서-무엇하랴-비용이-비싸고-느리다" class="headerlink" title="콜스택 기반 단점 : 말해서 무엇하랴. 비용이 비싸고 느리다."></a>콜스택 기반 단점 : 말해서 무엇하랴. 비용이 비싸고 느리다.</h4><p>지금 회사에서 사용하는 게임서버 엔진은 처음에 Log4Net을 쓰다가, 나중에 NLog로 바꾸었다가, 현재는 자체 구현한 파일로그 모듈을 쓰고 있다. 외부 모듈로는 내가 만족하는 성능을 얻지 못했기 때문이다. </p><p>Log4Net, NLog 모두 아주 좋은 로그 모듈인 것은 분명하다. Log4Net은 apache 소프트웨어 재단의 모듈인 만큼 아주 많은 곳에서 쓰이고 있을것이다. 두 모듈 모두 설정 문서만 읽어봐도 정말 기능이 많다. 로그파일을 사이즈나 시간에 맞춰 새 파일로 나눠주는 것은 물론이고, 메일로 로그를 전송할 수도 있고, 로그 레벨 설정도 자유롭고, 파일 생성 정책도 디테일하게 조절할 수 있고… 아무튼 아주 많다. </p><p>내가 이 두 모듈을 떠나서 직접 만들어 사용하는 가장 큰 이유는 <code>성능</code> 때문이다. 나에게는 굳이 내가 사용도 하지 않을 것 같은 다수의 편의기능들보다도 딱 내가 필요한 동작만 가지고 있더라도 가볍고 빠른 로그 모듈이 필요했다. Log4Net은 오래되서 잘 기억이 나지 않지만 NLog같은 경우 모듈 자체에서 스레드도 제법 많이 만들어서 운용하는걸 디버깅하다 본 기억이 있는데, 이런 내부 구조도 고성능 엔진을 만든다는 측면에서 부담스러웠다. (고성능을 위한 File IO 전략은 이 글의 주제에서 벗어나니까 다음 기회에 별도의 포스트로 다뤄보겠다.)</p><p>범용적인 로그 모듈들은 성능 또한 일반적이다. 크게 좋지도 않고 아주 나쁘지도 않는 수준을 보여준다. NLog를 사용할 때 설정에서 파일 이름과 라인 위치를 출력하는 동작을 끈 채로 사용해도 성능에는 별반 차이가 없었는데, 아마도 파일로 출력만 하지 않을 뿐  내부에서는 동일하게 <code>StacFrame</code> 을 얻어오는 동작이 실행되고 있을거라고 추측했다. 혹은 StackFrame 때문이 아닌, 다른 많은 부수 기능들 때문일 수도 있을 텐데, 아무튼 나의 기대치에는 맞지 않았다.</p><h2 id="System-Runtime-CompilerServices"><a href="#System-Runtime-CompilerServices" class="headerlink" title="System.Runtime.CompilerServices"></a>System.Runtime.CompilerServices</h2><p>.NET Framework 4.5부터 새로운 방식으로 함수 호출자의 정보를 가져올 수 있게 되었다. 요즘 .NET 6에 대한 뉴스도 돌고 있는 현시점에서 보면 충분히 오래된 방식이다. 만들어야 하는 프로그램의 런타임을 특정 프레임워크만 사용하도록 한정할 수 있다면 이 방식을 사용하는 것을 추천한다. 게임서버는 런타임 환경을 단 하나의 프레임워크로 고정할 수 있으니, 크게 문제될 것이 없다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TraceMessage(<span class="string">&quot;Something happened.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TraceMessage</span>(<span class="params"><span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">    [CallerMemberName] <span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    [CallerFilePath] <span class="built_in">string</span> sourceFilePath = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    [CallerLineNumber] <span class="built_in">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;message: &quot;</span> + message);</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;member name: &quot;</span> + memberName);</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;source file path: &quot;</span> + sourceFilePath);</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;source line number: &quot;</span> + sourceLineNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 인자에 기본값이 있기 때문에 작업자가 함수를 호출할 때 값을 전달하지는 않지만, 그래도 보이지 않게 뒤쪽 인자를 통해 호출자의 파일명, 라인수 등이 넘어가는 방식이다. 인자에 붙어있는 attribute로 인해 함수 호출 위치에 맞는 값들이 <code>런타임에</code> 채워진다.</p><p>과거의 오래된 프레임워크를 지원할 수 없다는 점이 거꾸로 단점이 될텐데, 사실 NLog같이 누구나 어디서나 사용해야할 로그모듈을 만들게 아니고, 게임서버처럼 특정 비즈니스 프로젝트로 사용처를 한정한다면 오래된 프레임워크 미지원은 그렇게 큰 단점은 아니다. </p><h4 id="CompilerServices-장점-가볍고-빠르다"><a href="#CompilerServices-장점-가볍고-빠르다" class="headerlink" title="CompilerServices 장점 : 가볍고 빠르다."></a>CompilerServices 장점 : 가볍고 빠르다.</h4><p>위에서 언급했던 StackFramek 클래스를 사용하는 방식보다 훨씬 빠르다. C++의 <code>__FILE__, __LINE__</code> 은 매크로니까 이미 컴파일 타임에 문자열과 숫자로 치환되어 코드에 포함된다. CompilerServices 사용 방식은 런타임에 함수의 인자로 넘어가는 방식이니까 이것만큼 optimal할 수는 없지만, 콜스택을 긁어오는 것보다는 훨씬 빠르다.</p><h4 id="CompilerService-단점-가변인자-인터페이스-사용이-불가능-해진다"><a href="#CompilerService-단점-가변인자-인터페이스-사용이-불가능-해진다" class="headerlink" title="CompilerService 단점 : 가변인자 인터페이스 사용이 불가능 해진다."></a>CompilerService 단점 : 가변인자 인터페이스 사용이 불가능 해진다.</h4> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  WriteLog(<span class="string">&quot;invalid value:&#123;0&#125;&quot;</span>, <span class="keyword">value</span>); <span class="comment">// 불가능합니다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteLog</span>(<span class="params"><span class="built_in">string</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">params</span> <span class="built_in">object</span>[] list,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerFilePath] <span class="built_in">string</span> sourceFilePath = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerLineNumber] <span class="built_in">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수의 뒷부분 인자를 사용하게 되니까, 위와 같은 사용이 불가능하다. 예시처럼 formatting이 될 문자열을 처음에 받고 두번째부터 가변 인자를 받는 방법은  C++에서 로그 인터페이스를 만드는 가장 익숙한 방식이다. </p><p>하지만 C#은 나름대로의 해결법이 있다. <a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/tokens/interpolated">보간 문자열</a>을 이용해 문자열을 포매팅하면 된다. .NET Framework 4.6 과 함께 C# 문법이 6.0으로 올라갔고 이 때부터 보간 문자열이 사용 가능해졌다. 최신의 C#에서는 String.Format보다 보간 문자열의 사용이 더 권장된다. - Effective C#, 빌 와그너. Chapter 1.4 <code>string.Format()을 보간 문자열로 대체하라</code> </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// WriteLog(&quot;invalid value:&#123;0&#125;&quot;, value); // C++스러워 보이지만, 촌스러운 방식이예요.</span></span><br><span class="line">  WriteLog(<span class="string">$&quot;invalid value:<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>); <span class="comment">// 가능합니다. 권장됩니다. Effective C# 읽어보세요.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteLog</span>(<span class="params"><span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerFilePath] <span class="built_in">string</span> sourceFilePath = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerLineNumber] <span class="built_in">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#이 5.0이었을 시점만 해도 이건 큰 단점이었다. 하지만 현 시점에서 이것도 그리 문제될 것이 없다.</p><h2 id="C-은-코드영역을-사용하지만-C-은-힙을-사용한다"><a href="#C-은-코드영역을-사용하지만-C-은-힙을-사용한다" class="headerlink" title="C++은 코드영역을 사용하지만, C#은 힙을 사용한다."></a>C++은 코드영역을 사용하지만, C#은 힙을 사용한다.</h2><p>좀 더 성능에 집착해보자(?).</p><p>윗부분에서 잠시 언급했듯이, C++의 <code>__FILE__, __LINE__</code> 은 컴파일 시점에 이미 실제 값으로 변환을 완료하는 preprocessing 이다. 런타임에 함수 호출자 정보를 얻기 위해 추가로 들이는 비용이 거의 없다.</p><img src="/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/00.jpg" class=""><p>(이미지 출처 : <a href="https://en.wikipedia.org/wiki/Data_segment">wikipedia</a>)</p><p>이미지에서 text로 표현된 부분이 코드영역이다. 이 공간은 고정적인 읽기 전용의 공간이다. C++의 <code>__FILE__</code> 매크로를 다르게 표현하면 결국 이 코드영역의 특정 위치를 가르키는 char*로 변환될 뿐이다. 추가적인 객체 할당은 없다.</p><p>하지만 C#은 코드영역을 사용하지 않는다. <code>[CallerFilepath] string filePath</code> 는 <strong>함수 호출이 일어날 때마다 heap 영역에 스트링 객체를 할당한다</strong>. 디버그를 위해 상세하게 로그를 달면 달 수록 heap에는 동일한 텍스트가 반복적으로 할당되어 메모리에 압력을 가하게 된다. </p><p>C#에서는 C++처럼 코드영역을 참조하는 문자열을 만드는 방법이 없다. 모든 참조형식의 객체는 heap이 아닌 공간을 사용할 수 없기 때문으로 추측이 된다. value type을 object 형식으로 가리키면 굳이 비싼 비용을 들이면서까지 heap에 추가할당을 만드는 boxing을 하는 이유와 같을 것이다. </p><p>반복적으로 사용하는 똑같은 문자열인데도, 매번 함수가 불릴 때마다 이걸 heap에 재할당을 할까? 하고 나도 처음엔 그렇게 생각했다. C++을 하면서 생긴 사고의 관성일 것이다. C#의 string은 참조 타입이고, immutable해서 한 번 할당하면 변경도 불가한 성격을 갖고 있기 때문에 충분히 착각할 만한 상황이기도 하다 - 라고 자기 합리화를 해본다.  하지만 windbg를 이용해 heap을 디버깅 하던 중 무수히 많은 파일 경로 텍스트가 중복으로 잔뜩 들어있는걸 보고 나서야 아닌 것을 깨달았다. </p><h2 id="Interned-String"><a href="#Interned-String" class="headerlink" title="Interned String"></a>Interned String</h2><p>완전하게 내용이 같은 string을 pooling하여 heap에 한 번만 할당하고 돌려쓰는 방법이 없는 것은 아니다. 이렇게 언어 자체적으로 문자열을 풀링하는 처리를 Java와 C#에서는 모두 Interning이라고 부른다. </p><ul><li>Java - <a href="https://www.javatpoint.com/java-string-intern">String Intern()</a></li><li>C# - <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.string.intern?view=net-5.0">String Intern()</a></li></ul><p>사용법은 간단하다. 풀링하고 싶은 문자열을 사용할 때 <code>string.Intern()</code> 메소드를 한 번 더 감싸주면 된다. 현재 회사에서 실제 사용중인 모듈의 인터페이스 부분만 보면 아래처럼 되어있다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Log</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Debug</span>(<span class="params"><span class="built_in">string</span> message, [CallerFilePath] <span class="built_in">string</span> <span class="keyword">file</span> = <span class="string">&quot;&quot;</span>, [CallerLineNumber] <span class="built_in">int</span> line = <span class="number">0</span></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ... 중략...</span></span><br><span class="line">    provider.Debug(<span class="string">$&quot;<span class="subst">&#123;message&#125;</span> (<span class="subst">&#123;BuildTag(<span class="keyword">file</span>, line)&#125;</span>)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">BuildTag</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">file</span>, <span class="built_in">int</span> line</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Intern(<span class="string">$&quot;<span class="subst">&#123;Path.GetFileName(<span class="keyword">file</span>)&#125;</span>:<span class="subst">&#123;line.ToString()&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전달받은 파일명을 바로 사용하지 않고 string.Intern()으로 한 번 감싸서 사용한다. 로그를 출력하면 아래처럼 찍힌다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-12-21 12:08:02.144 [Debug] [ConnectionMonitor] add uid:1 #connection:1 (ConnectionMonitor.cs:32)</span><br><span class="line">2020-12-21 12:08:02.145 [Info] [Send] [20017] kREGISTER_GAME_SERVER_REQ actionId:3 (SerializableExt.cs:92)</span><br><span class="line">2020-12-21 12:08:02.205 [Info] db connection Initialized. type:Auth server:localhost count:16 (DbPool.cs:40)</span><br><span class="line">2020-12-21 12:08:02.221 [Info] db connection Initialized. type:Contents server:localhost count:16 (DbPool.cs:40)</span><br><span class="line">2020-12-21 12:08:02.238 [Info] db connection Initialized. type:Game server:localhost count:16 (DbPool.cs:40)</span><br></pre></td></tr></table></figure><p>interning은 입구만 있고, 출구는 없는 string pool이다. 풀에 등록은 할 수 있지만 해제할 수는 없다. 한 번 쓰고 마는 동적인 문자열은 당연히 interning해서는 안된다. 반복적으로 사용하더라도 빈도가 낮아서, heap의 할당과 해제에 큰 압력을 주지 않는다면 이것도 굳이 interning할 필요는 없다. 이런 문자열들을 interning하면 장시간 떠있어야 하는 서버 프로그램의 경우 오히려 더 악영향을 끼칠 수 있다. 용도에 맞게 적절하게 적용해야 한다. </p><p>C#에서 코드에 함께 적혀있는 literl text들은 기본적으로 interning된다. C++처럼 code segment를 직접 가르키지는 않지만, 비슷한 효과를 내기 위함이다. 그 외에 프로그램이 사용하는 나머지 문자열에 대해서는 어떤 것을 interning할지 직접 판단하고 선별 적용해야 한다. 로그 메세지에 반복적으로 찍히는 소스코드 파일명은 interning하기에 적합한 대상이다. </p><h2 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h2><p>로그파일에서 로그 출력 위치를 남기는 방식에 관련해 성능 위주의 고려사항을 정리해 보았다. </p><ul><li>함수 호출자 정보를 얻고 싶을 땐 StackFrame 사용 보다 CompileServices 하위 어트리뷰트를 쓰는게 낫다. </li><li>C#은 모든 문자열을 항상 heap에 할당한다. 심지어 literal text같은 상수 문자열을 사용한다 하더라도 메모리 코드영역의 직접 참조가 불가능하다. </li><li>로그를 찍을 때마다 heap에 불필요한 객체 할당이 발생하는 것을 줄이고 싶다면 문자열을 Interning하면 된다.</li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC/">메모리</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/string-interning/">string interning</category>
      
      
      <comments>http://leafbird.github.io/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>테크니컬 리더십: 시작하기</title>
      <link>http://leafbird.github.io/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Mon, 12 Nov 2018 14:05:29 GMT</pubDate>
      
      <description>&lt;p&gt;예전에 트위터 하다가 읽었던 글인데, 개인적으로 마음에 들어서 부족하게나마 번역해 보았습니다.&lt;br&gt;원문은 슬랙 개발 블로그의 &lt;a href=&quot;https://slack.engineering/technical-leadership-getting-started-e5161b1bf85c&quot;&gt;Technical Leadership: Getting Started&lt;/a&gt;라는 글입니다.&lt;br&gt;번역에 크게 자신이 없으니 부담이 없으신 분들은 원문을 보셔요. &lt;/p&gt;
&lt;img src=&quot;/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/00.png&quot; class=&quot;&quot; title=&quot;개발 실무자의 리더십은 스스로를 리딩하는 것에서 시작한다&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>예전에 트위터 하다가 읽었던 글인데, 개인적으로 마음에 들어서 부족하게나마 번역해 보았습니다.<br>원문은 슬랙 개발 블로그의 <a href="https://slack.engineering/technical-leadership-getting-started-e5161b1bf85c">Technical Leadership: Getting Started</a>라는 글입니다.<br>번역에 크게 자신이 없으니 부담이 없으신 분들은 원문을 보셔요. </p><img src="/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/00.png" class="" title="개발 실무자의 리더십은 스스로를 리딩하는 것에서 시작한다"><span id="more"></span><h2 id="테크니컬-리더십-시작하기"><a href="#테크니컬-리더십-시작하기" class="headerlink" title="테크니컬 리더십: 시작하기"></a>테크니컬 리더십: 시작하기</h2><p>내가 소프트웨어 엔지니어가 되기 전에는 이 직업에서 가장 중요한 점은 코딩이라고 생각했다. 그것은 잘못된 생각이었고, 소프트웨어 공학의 가장 중요한(그리고 가장 어려운)점은 다른 사람들과 원만하게 잘 협력하는 것이다. </p><p>나는 “관리자는 되지 않을거야!”라고 스스로에게 말해왔고, “그렇게 하면, 내 모든 에너지를 개발에만 집중시킬 수 있을거야!” 라고 생각했다. 내 이후의 경력도 기술 지향적인 실무자 위주로만 관리해 간다면 이 어려운 대인관계를 어느 정도 무시할 수 있을 거라고 생각했다. </p><blockquote><p>빨리 가려거든 혼자 가고, 멀리 가려거든 함께 가라.</p></blockquote><p>내가 업무에서 대인관계를 소홀히 여기던 때 의아하게 생각했던 점은 “왜 사람들은 나의 의견을 들어주지 않지?” 하는 점이었다. 이는 슬랙(Slack)의 플랫폼 팀에서 처음 작업을 시작했을 때 특히 그러했다. 나는 슬랙의 API가 토큰을 사용하고 있는 점을 변경하여 보안을 강화하고, 제품 개발팀 전체에 걸쳐 일관된 개발 과정을 유지하도록 개선하고 싶었다. 그러나 몇 달 동안, 나의 제안이 많은 이들의 시간을 보다 가치있게 활용할 수 있는 방법이라고 PM이나 팀원들을 설득하는 것은 불가능했다.</p><p>이후로도 몇 차례 나의 의견은 받아들여지지 않고, 같은 팀 수석 엔지니어들의 의견이 채택되는 것을 지켜보면서 내게 무언가 빠진 요소가 있다는 것을 알게 되었는데, 그것은 바로 ‘리더십’이었다. 나는 매일같이 키보드에만 코를 박고 있으면 안되는 것이었다. 내가 성장하기를 원한다면, 다른 사람들이 나와 동등한 수준으로 기여할 수 있도록 도움을 주어야 했던 것이다. 나는 리더십을 통해 나의 영향력을 키워야 할 필요가 있었다. </p><p>이 글을 통해 필자 스스로가 리더십에 대해 배운 점과, 개발자 리더십의 절차(Path)에 대해 이야기해 보고자 한다. </p><h2 id="자기-자신을-리딩하기"><a href="#자기-자신을-리딩하기" class="headerlink" title="자기 자신을 리딩하기"></a>자기 자신을 리딩하기</h2><p>슬랙의 엔지니어로 지내면서, 나는 관리(management)와 리더십(leadership)이 어떻게 다른지 이해하게 되었다. </p><p>관리자(manager)는 자신의 보고서에 대한 책임이 있다. 관리자들은 코칭과 구조화를 통해 좋은 팀을 구축하는 것에 중점을 둔다. 또한 팀의 성장을 위해 성과를 관리한다. </p><p>관리자(manager)는 종종 리더(leader)를 겸임하지만, 리딩은 사실 다른 누구라도 할 수 있는 별개의 것이다. 리딩은 권위에 의존하는 무언가가 아니라, 다른 사람에게 미치는 영향력에 대한 것이다. 리딩은 비전에 대해 소통하고, 비전을 실현하기 위해 다른 이들에게 힘을 실어주는 것이다.</p><p>당신은 다른 이들을 리드하기 전에, 먼저 당신 자신을 리드할 수 있어야 한다. 자신을 리딩하는 것은 타인을 리드하거나, 조직을 리드하기 전에 반드시 먼저 선행되어야 한다. 자신을 리딩한다는 개념은 다양한 분야와 기업에서 정리한 여러 리더십의 정의들에서 찾아볼 수 있다. </p><p>자기 자신을 리딩하는 것은 그 사람의 우수한 역량과 밀접한 관련이 있다. 모범적인 자세를 통해 드러나는 리더십은 타인에게 자극을 주는 가장 강력한 방법이기 때문이다. 자신을 리딩한다는 말은 늘 최선을 다해서 개인의 업무를 수행하고, 스스로가 만들어내는 결과물의 품질에 대해 책임을 지는 것을 의미한다. </p><p>자기 자신에게 성공적인 리더십을 발휘하기 위한 다섯하기 요소는 방향 맞추기, 전문가 되기, 공유하기, 일관되게 실행하기, 효과적인 의사소통하기 이다. </p><h2 id="방향-맞추기-Finding-Alignment"><a href="#방향-맞추기-Finding-Alignment" class="headerlink" title="방향 맞추기(Finding Alignment)"></a>방향 맞추기(Finding Alignment)</h2><img src="/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/01.jpg" class="" title="“Surya Namaskara” by Indian Navy licensed under Creative Commons."><p>직장에서 우수함을 나타내려면 먼저, 팀을 이해해야 하고, 회사를 이해해야 한다. </p><p>‘원칙’이란 어떤 행동이 바람직한지, 혹은 바람직하지 않은지를 안내하는 회사의 규범을 말한다. 대개는 이런 원칙들이 명확하게 규정되지 않은 경우도 많은데, 이런 숨은 원칙을 잘 찾아내는 것 역시 개인의 몫이다. 이 원칙들은 당신의 나침반과도 같다. 원칙들은 당신이 회사의 목표와 가치에 맞는 결정을 내리는데 큰 도움을 줄 것이다. </p><p>슬랙에서의 예를 들어보면, 우리는 슬랙의 사용자들에게 매우 뛰어난 사용 경험을 제공하고 있다는 믿음이 있다. 어떤 고객이 슬랙의 핵심 기능 중의 하나가 망가졌다는 제보를 한다면, 나에게는 그 즉시 내가 하고 있던 일을 모두 멈추고 현상을 확인해 즉시 문제를 해결하는 것이 가장 중요하다. 하지만 다른 회사에서는 내가 하던 일을 내팽개치는 것이 완전히 잘못된 판단이 될 수도 있는 것이다. </p><p>대부분의 결정은 여러가지 가치를 두고 다각도로 고민하면서 내려져야 한다. 오늘은 그동안 쌓아둔 기술 부채를 해결하는데 시간을 쓸 것인가? 아니면 좀 더 미루고 내일의 작업을 위한 기반작업을 할 것인가? 버그를 잡는 것, 툴을 만드는 것, 새로운 기능을 개발하는 것이 더 중요하진 않은가? 직장에서 할애할 수 있는 총 시간과 에너지의 양은 제한되어 있다. 회사가 중요하게 생각하는 것과 개인이 노력을 기울이는 방향을 동일하게 맞출 때 당신의 기여도는 가장 최대의 효율을 발휘할 것이다. </p><p>방향성 맞추기는 단지 회사가 당신에게 바라는 일을 수행하는 것만을 뜻하지 않는다. 여러분들은 리더로서 여러가지 문제를 직면하고, 이를 해결하기 위한 (숨어있는) 솔루션을 제시할 숱한 기회들을 마주하게 될 것이다. 하지만 그 때마다 다른 동료들에게 이것이 왜 문제이며, 왜 이를 해결하기 위해 에너지를 써야 하는가를 납득시키기 위해서는 먼저 회사가 무엇을 중요하게 생각하는지를 이해하고 다른사람에게 잘 설명할 수 있어야 한다. </p><h2 id="전문가-되기-Become-an-Expert"><a href="#전문가-되기-Become-an-Expert" class="headerlink" title="전문가 되기(Become an Expert)"></a>전문가 되기(Become an Expert)</h2><p>전문가가 되는 것은 개인 스킬을 연마하는 것에 관한 이야기다. 잠재력을 가진 상태라는 것이 하나의 좋은 자질일 순 있겠지만, 그걸로는 충분하지 않다. 리더는 실제로 뛰어난 전문가(export)여야 한다. 콜로라도 대학의 앤더스 에릭슨 교수에 따르면, 전문가가 되기 위해서는 평균 10년 이상 <a href="https://hbr.org/2007/07/the-making-of-an-expert">높은 수준의 의식적인 노력을 10,000시간 이상 기울여야 한다</a>고 말한다.</p><p>사람들은 종종 내가 오페라를 불렀던 경험이 소프트웨어 공학 경력에 도움이 되는지를 묻곤한다. 맞다! 음악을 통해서 나는 스스로의 마음가짐을 발전시킬 수 있었다. 아리아를 연습할 때면 가장 자신 없는 파트를 제일 자신있는 파트만큼의 자연 스러운 소리가 나올 때까지 몇시간이고 반복해서 연습했다. 소프트웨어 공학도 이것과 똑같다. 우리는 자신이 취약한 부분을 개발하는데 더욱 많은 시간을 투자해야 한다.</p><p>숙련을 쌓는 방법에 지름길이란 없다. 다만 꾸준하고 의식적인 노력으로 개발시키는 것 뿐이다. 내 자신에게(그리고 당신 주변의 사람들에게) 질문을 던져보자: 내가 가장 크게 성장할 수 있는 분야는 무엇인가? 전문가가 되기 위해서 나는 어떤 스킬을 개발해야 하는가?</p><p>당신이 개발하기 원하는 많은 스킬들이 있을 수 있지만, 노력을 기울이기 전에 먼저 다음의 질문을 던져보기를 권장한다: 그 스킬은 회사가 추구하는 방향에 부합하는가? 그 스킬은 나의 개인적인 목표에도 부합하는가?</p><p>‘아직 아무것도 이룬 것이 없다’는 생각만 하고 있을 게 아니라 매일 꾸준히 지식과 스킬을 체득하고자 노력하는 과정이 필요하다. 누구나 태어날 때부터 전문가였던 사람은 없다. </p><h2 id="공유하기-Share"><a href="#공유하기-Share" class="headerlink" title="공유하기(Share)"></a>공유하기(Share)</h2><p>자기 자신을 리딩하는 과정이 지나면, 다른 사람을 리드할 기회가 주어지고, 당신의 동료들이 최고의 성과를 내도록 역할을 부여하게 된다. 이를 성공적으로 수행하기 위해서는 먼저 지식을 공유해야 한다. </p><p>스킬을 습득하기 위해 많은 개인 시간을 소비한 후라면 선뜻 지식을 공유하는 것이 쉽지 않을 수도 있다. 특별한 전문성을 혼자만 “소유”하고 싶은 것은 본능적인 생각이다. 전문 지식은 체득 과정의 노력이 보이지 않을 땐 마치 마술처럼 느껴질 수도 있다. 당신은 혼자만의 마법을 비밀 상자에 숨겨놓고 외딴 곳에 보관하고 있다가 필요할 때만 꺼내서 사용하고 싶어할 수 있다. 다른 사람들은 그걸 어떻게 하는지 모르기 때문에, 당신만의 전문성은 여전히 마법을 유지하게 될 것이다. </p><p>하지만 바로 이 부분이 핵심이다. 당신의 노하우를 혼자만 알고 있으면 동료들은 당신에게 의존하게 되고, 결국 동료들의 성장을 방해하는 셈이 된다. 당신 스스로도 새로운 일을 배우는 것을 불안하다고 여기게 되어, 자신의 성장마저 방해하는 셈이 된다. 당신은 동료들이 팀에 기여하는 것을 막고 있으며, 팀을 아주 적극적으로 망치고 있는 셈이다. </p><p>나도 내가 가진 정보를 혼자만 유지하곤 했는데, 일부러 숨기고자 해서 그랬다기 보다는 이것이 유익한 정보인지 깨닫지 못했던 경우였다. 예를 들어, 나의 프로젝트에서는 업무의 진행을 방해하는 일반적인 문제점들에 대해 탐구하고 정리해왔다: 킥오프, 최종 마일스톤, 회귀 없는 릴리즈 같은 것들(역주: 예시의 내용들이 무엇을 말하는지는 잘 모르겠습니다). 나는 주위 동료들도 함께 성공했으면 하는 마음에 내가 유지하던 정보들 중 다른 팀들과 공유할 수 있는 기술들을 분류하기 시작했다. 사실 내 프로젝트만 잘 돌아가면 상관 없는 일이었지만.. 그것은 추가 확장이 없는 x1배의 영향력이다. 허나 이런 정보들은 모든 팀들에게 적용 가능한 것들이었고, 이것은 xN 배의 영향력을 발휘하게 된다.</p><p>지식을 숨기는 대신 공유하라. 멘토링이나 페어 프로그래밍 같은 1:1 방식도 좋고, 프레젠테이션이나 문서화 같은 1:N 방식도 좋다. 당신이 배운 사실을 다른 사람들에게도 가르쳐라. 그럼 다른 사람들은 다시 그 다음 사람들을 가르칠 것이다. 당신은 다시 배우고자 하는 그 다음 스킬로 자유롭게 이동할 수 있다. 지식이란 마르지 않는 샘이다. 아무리 배워도 항상 더 많이 남아있다. </p><img src="/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/02.jpeg" class="" title="by Nguyen Hung Vu licensed under Creative Commons."><h2 id="일관되게-실행하기-Execute-Consistently"><a href="#일관되게-실행하기-Execute-Consistently" class="headerlink" title="일관되게 실행하기(Execute Consistently)"></a>일관되게 실행하기(Execute Consistently)</h2><p>일전에 나의 관리자와 나눴던 대화가 기억난다. 나는 관리자에게 최근의 프로젝트에서 내가 매우 뛰어난 성과를 기록했다고 말하고, 내가 언제쯤 승진할 수 있느냐고 질문했다. 그는 현명하게 대답했다: “당신은 이번과 같은 좋은 성과를 일관되고 꾸준하게 달성할 수 있음을 증명해야 합니다.”</p><p>일관성. 그것은 일시적인 운과 리더십의 차이를 말해준다.</p><p>당신이 어느 한가지 일을 딱 한 번 잘해냈다는 것은 별로 중요하지 않다. 정말 중요한 것은 당신이 그 일을 다시, 또 다시, 그리고 또 다시 잘 해낼 수 있는가 하는 것이다. </p><p>일관성 있는 실행력을 갖기 위해서는, 다양한 규모와 유형의 여러가지 프로젝트를 해봐야 할 것이다. 작은 규모, 큰 규모, 복합적인 기능, 사용자 친화적 UX, 백엔드 솔루션 등등. 이러한 경험들에서 당신은 다양한 도전 과제를 마주하고 해결 방안들을 개발하게 된다. 당신의 약점이 무엇인지를 드러내주고 당신이 스킬을 연마하도록 도울것이다.</p><p>당신의 관리자에게, 당신이 익히려고 하는 기술들을 미리 공유하라. 앞으로 맡게 될 프로젝트를 주시하고 그 중에 자신이 흥미가 가는 부분이 무엇이며 왜 그렇게 생각하는지를 관리자에게 미리 알려라. 당신이 지금 프로젝트를 진행중이라면, 작업하는 동안 나는 어떤 스킬을 선정해 발전시켜갈 것인가에 대해 생각하라. 이것은 직장에서의 시간을 최대의 효율로 활용하는데 큰 도움을 줄 것이다. </p><p>때로는 당신이 크게 열정을 느끼지 못하지만 팀의 임무에는 중요한(mission-critical)일에 배정이 될 때도 있다. 당신은 이 또한 잘 해낼 수 있음을 증명해야 한다. </p><p>일관되게 실행하는 것은 개인의 브랜드를 개발시키고 동료들에게 신뢰를 쌓을 수 있는 방법이다. 신뢰감을 형성하고 키우는 데에는 많은 시간과 경험이 필요하다. 하룻밤 만에 만들어지지 않는다. 한 번 신뢰를 얻었다 하더라도 지속적인 노력이 뒤따라야만 이를 오래도록 유지할 수 있다. </p><h2 id="효과적인-의사소통하기-Communicate-Effectively"><a href="#효과적인-의사소통하기-Communicate-Effectively" class="headerlink" title="효과적인 의사소통하기(Communicate Effectively)"></a>효과적인 의사소통하기(Communicate Effectively)</h2><p>“왜 사람들이 내 말을 들어주지 않는거야?” 하고 궁금해 한 적이 있는가?</p><p>나는 신입일 때 여러 차례 위와 같은 질문을 하곤 했다. 그러던 어느날 문득 내가 성장의 준비가 되었을 즈음에, 사장님이 중요한 단서를 주었다: 나는 동료들에게 부정적인 성향으로 인식되고 있었다는 점이다. 처음엔 그 피드백을 듣고 기분이 상했다. 하지만 이것이 나의 경력에서 중요한 전환점이 되었다. 그 후로 나는 ‘목소리’ 코치와 함께 일하게 되었고, 효과적인 커뮤니케이션의 중요한 비밀을 깨닫게 되었다. 그것은 경청(listening)이다.</p><p>경청이란 단순히 정보를 받아들이는 것이 아니다. 경청은 정보와 함께 그것의 맥락을 모두 합쳐 하나의 덩어리로 합성하는 것이다. 경청은 상대방의 의견이 어디에서 왔는지를 이해하고, 더 깊은 이해를 얻기 위해 명확한 질문을 던지는 것을 말한다. 이 합성의 듣기는 효과적인 커뮤니케이션의 가장 기본임과 동시에, 당신이 말하고자 하는 아이디어에도 엄청난 힘을 실어준다 - 믿거나 말거나.</p><div class="twitter-wrapper"><blockquote class="twitter-tweet"><a href="https://twitter.com/sarahmei/status/862584755849539584"></a></blockquote></div><script async defer src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote><p>레벨이 올라감에 따라 관리자 트랙과 엔지니어 트랙에게는 모두 동일한 의사소통 기술이 요구됩니다. 각 트랙의 진정한 능력자들이 서로 다른 트랙의 능력자를 존재할 수 있게 만듭니다. - Sarah Mei</p></blockquote><p>효과적인 의사소통의 또 다른 측면은 적절한 맥락으로 반복하는 것이다. 사람들이 왜 내 말에 귀기울이지 않는지 몰랐을 때의 나는 했던 말을 다시 반복해야 할 때면 화를 내면서 말했다. </p><p>나중에서야 효과적인 의사소통의 고수들을 관찰하기 시작했다. 그들은 다방면으로 정보를 노출한다. 적절한 시간 간격을 두고 반복적으로 정보를 전달하고, 듣는 사람이 누군가에 따라 그에 맞는 다양한 세부 정보들을 제공한다.</p><p>정보를 듣고 종합하고, 효과적으로 공유하는 방법을 익히는 것은 직급에서 오는 권위에 의존하지 않고 사람들에게 영향을 미치는 기본적 기술이다. 모두가 하나의 비전을 바라하도록 사람들을 모으기 위해서는 이러한 영향력이 필요하다.</p><p>. . . </p><p>소프트웨어 엔지니어로 일을 시작할 때, 왜 나의 아이디어가 회사에서-그리고 업계에서-잘 받아들여지지 않는 것인가를 궁금해했다. 그러던 중 컴퓨터만 골똘히 들여다보던 시선을 잠시 벗어나, 주변의 훌륭한 동료들을 만나보게 되면서 깨달았다. 내가 생각하는 방향성을 다른 사람들이 함께 공감하고, 실현하기 위해 같이 노력하도록 동기부여할 수 있다면 훨씬 더 큰 영향력을 미칠 수 있다는 것을.</p><p>리더십에 관해서는 배워야 할 것이 많고, 필자 개인적으로는 더 많은 것들을 배워야 한다. 리더급 개발자가 되고자 한다면, 먼저 자기 자신을 리딩하는 것부터 시작하기를 권한다. 이 외에 당신이 찾아낸 리더십에 대해 내게도 알려주길 바란다!</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/%EB%A6%AC%EB%8D%94%EC%8B%AD/">리더십</category>
      
      
      <comments>http://leafbird.github.io/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>

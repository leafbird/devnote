<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>leafbird/devnote</title>
    <link>http://leafbird.github.io/devnote/</link>
    
    <atom:link href="http://leafbird.github.io/devnote/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 21 Sep 2025 12:59:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>요즘의 취미 - 터미널?</title>
      <link>http://leafbird.github.io/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/</link>
      <guid>http://leafbird.github.io/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/</guid>
      <pubDate>Mon, 03 Mar 2025 06:34:59 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/screenshot.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;아니, 정말로요. 빈 말이 아니고요. &lt;/p&gt;
&lt;p&gt;만약에 요즘에 누군가와 사교적인 말하기를 하다가 취미가 무엇이냐는 질문을 받는다면, &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;요즘 터미널 꾸미는 것에 빠져있어요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;라고 대답할 것 같아요.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/screenshot.png" class=""><p>아니, 정말로요. 빈 말이 아니고요. </p><p>만약에 요즘에 누군가와 사교적인 말하기를 하다가 취미가 무엇이냐는 질문을 받는다면, </p><blockquote><p>요즘 터미널 꾸미는 것에 빠져있어요.</p></blockquote><p>라고 대답할 것 같아요.</p><span id="more"></span><h3 id="터미널이요-…-버스터미널"><a href="#터미널이요-…-버스터미널" class="headerlink" title="터미널이요? … 버스터미널?"></a>터미널이요? … 버스터미널?</h3><p>여기서부터.. 너무 개발자스러운 주제가 되어버리겠죠. 근데 정말로 요즘은 시간만 나면 터미널을 열고 한참을 집중하고 있습니다. </p><p>연초에 회사 프로젝트에서 docker와 k8s 도입이 논의되면서부터 리눅스와 터미널 환경을 찾아보게 되었습니다.</p><p>그 때부터 UI가 없는 터미널 환경에 좀 익숙해져야 겠다는 생각으로 정보를 찾아보기 시작했습니다. </p><p>그러다 neovim을 설정하게 되고… fzf, yazi, lazygit, lazydocker 같은 TUI(Terminal User Interface) 도구를 접하게 되고 한참을 빠져들고 있습니다.</p><h3 id="요즘은-알아보다-막히는-건-AI가-다-해결해줍니다"><a href="#요즘은-알아보다-막히는-건-AI가-다-해결해줍니다" class="headerlink" title="요즘은 알아보다 막히는 건 AI가 다 해결해줍니다."></a>요즘은 알아보다 막히는 건 AI가 다 해결해줍니다.</h3><p>낮선 환경을 처음 접하면 아주 사소한 것을 몰라 한참을 삽질하는 경우를 많이 겪게 됩니다. </p><p>하지만 요즘은 대 AI의 시대. 에러가 왜 발생했고 어떻게 해결해야 하는지 ai agent들이 너무 잘 알려줍니다. </p><p>심지어 <a href="https://www.warp.dev/">warp</a>같은 터미널의 사용 경험은 말할 것도 없이 놀랍습니다. </p><img src="/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/warp.png" class=""><p>warp는 ai agent가 내장된 터미널입니다. 한동안 mac, linux에서만 사용 가능했지만 얼마전에 windows 버전도 출시되었습니다.</p><p>이런 세상이 된 덕분에 터미널 환경을 익혀가는 것이 좀 더 수월하고 재미있게 느껴집니다. </p><h3 id="neovim에-깃허브-코파일럿도-정식으로-지원됩니다"><a href="#neovim에-깃허브-코파일럿도-정식으로-지원됩니다" class="headerlink" title="neovim에 깃허브 코파일럿도 정식으로 지원됩니다."></a>neovim에 깃허브 코파일럿도 정식으로 지원됩니다.</h3><img src="/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/github-copilot.png" class=""><p>깃헙 코파일럿이 <code>neovim</code> 도 공식적으로 지원하는 것을 알고 있었나요?</p><p>GUI 환경에서면 그렇겠거니 싶은데, 터미널에서 copilot이 동작하는 것을 보고 있으면 정말로 놀랍습니다.</p><p>그 옛날 대학고 시스템 프로그래밍 수업 시절에 만져봤던 터미널 환경과 지금은 엄청난 차이가 있습니다. </p><p>유튜브에 자료도 충분하고, 깃허브에 공유되는 설정도 충분하고. ai agent도 너무 든든하게 도와주고. </p><p>세상이 많이 변했습니다. </p><p>오늘도 터미널 설정하러 갑니다. </p><h3 id="see-also"><a href="#see-also" class="headerlink" title="see also"></a>see also</h3><ul><li><a href="https://www.youtube.com/watch?v=KpudmVmMWx4">https://www.youtube.com/watch?v=KpudmVmMWx4</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/terminal/">terminal</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/powershell/">powershell</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/zsh/">zsh</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/neovim/">neovim</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/03/03/%EC%9A%94%EC%A6%98%EC%9D%98-%EC%B7%A8%EB%AF%B8-%ED%84%B0%EB%AF%B8%EB%84%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[slackbot] 빌드머신 점검하다가 문득 봇을 짜보았다</title>
      <link>http://leafbird.github.io/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/</guid>
      <pubDate>Sun, 02 Feb 2025 05:24:14 GMT</pubDate>
      
      <description>&lt;p&gt;회사에서 빌드머신으로 사용중인 맥미니 장비들은 주기적으로 몇가지 관리가 필요하다.&lt;/p&gt;
&lt;p&gt;최근에 유니티6로 엔진 업데이트한 이후 빌드머신에 갖가지 이슈들이 생기면서 디스크 용량 체크를 해보던 중이었다.&lt;/p&gt;
&lt;img src=&quot;/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_00.png&quot; class=&quot;&quot; width=&quot;500&quot;&gt;

&lt;p&gt;&lt;code&gt;이거 코드 작업 조금만 하면 만들 수 있겠다&lt;/code&gt;는 생각이 들었고, 미루면 아마 영영 실천으로 옮기지 않게 될 것 같아 생각난 김에 바로 만들었다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>회사에서 빌드머신으로 사용중인 맥미니 장비들은 주기적으로 몇가지 관리가 필요하다.</p><p>최근에 유니티6로 엔진 업데이트한 이후 빌드머신에 갖가지 이슈들이 생기면서 디스크 용량 체크를 해보던 중이었다.</p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_00.png" class="" width="500"><p><code>이거 코드 작업 조금만 하면 만들 수 있겠다</code>는 생각이 들었고, 미루면 아마 영영 실천으로 옮기지 않게 될 것 같아 생각난 김에 바로 만들었다.</p><span id="more"></span><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><p>처음엔 ssh 연결로 커맨드를 실행해서 장비마다 <code>df -h</code> 결과를 받아오고 있었다. 그러다 세 대 쯤하다보니, 서버 주소만 다르고 동일한 커맨드를 반복 실행하고 있길래, 파워쉘에서 loop를 돌아 output을 수집하도록 스크립트를 작성해 돌렸다. </p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_01.png" class=""><p>그리고는 내가 이걸 눈으로 읽어서 엑셀에 수작업으로 정리해 팀원들에게 공유했다.<br>다음에 동일한 작업을 해야 할 때, 파워쉘 스크립트를 재사용할 수 있도록 정리해서 vcs에 올렸다. </p><p>근데 만약 다음에 디스크 공간 확인을 해야 할 때, 다른 멤버가 이 스크립트를 사용하려면 ssh 키 설정도 되어 있어야 하고, 스크립트 실행 환경도 잘 맞아야 하고. 혹시 제대로 실행되지 않으면 디버깅도 해야 할거고.. 뭔가 매끄럽지 않을 것 같은 생각이 들었다. 그리고 프로그래머가 아니면 애초에 엄두도 못 낼 일이다. 그래서 그냥 누구나 확인할 수 있게 팀 내 메신저로 쓰는 슬랙에 기능으로 만들어 붙이면 좋겠다고 생각했다.</p><h2 id="slackbot"><a href="#slackbot" class="headerlink" title="slackbot"></a>slackbot</h2><p>slack bot은 이슈트래커 연동 등 이미 다른 용도로 만들어 사용중인 실행파일이 있다. 새로운 기능 추가도 용이하도록 어느정도 준비도 되어 있다. <code>필요한 건 의지 뿐이다. 지금 마음 먹었을 때 바로 해야 한다.</code> 오늘이 지나기 전에 기능을 완성해서 릴리즈 하고 싶었다. </p><p>슬랙봇이 떠있는 장비에서 ssh 키를 생성해 모든 빌드머신에 등록해주었다. 슬랙봇은 윈도우 2019에서 실행중인데, 이번에 여기에도 openssh 서버를 열고 ssh로 접속해서 설정을 진행했다. 나중엔 슬랙봇 실행 os 자체도 linux로 변경하면 좋겠다. </p><p>ssh 명령으로 <code>df -h | grep -e ....</code>를 실행하고 결과를 파싱하는 건 어렵지 않게 진행됐다. C# 참 좋은 언어인데, 사람들이 많이 모르는 것 같다. </p><p>그리고 markup? 출력은 몇 번의 삽질 끝에, 최종의 형태로 다듬었다. 이런 작업도 참 재미있다. 나는 서버 말고 클라이언트 개발을 했어도 참 잘했을거야. 아무도 칭찬 해주지 않으니까 이럴 때 내가 실컷 칭찬해준다. 잘한다 아주.</p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_02.png" class="" width="500"><p>최종 형태도 조금 아쉽긴 하다. 오와 열이 딱 맞지 않아. slack api의 block kit에서 테이블 형태 레이아웃을 지원해주면 좋을텐데 그런게 없다.<br>나름대로 지금 표현할 수 있는 수준에서 최선을 다해 보았다.<br>머신별로 서로 다른 디스크의 전체 크기가 눈으로 쉽게 들어오게 하고 싶었고, 용량 대비 사용량이 어느 정도인지도 한 눈에 들어오게 하고 싶었다.</p><p>다시 한 번 감상해보는 최종 결과물. </p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_00.png" class="" width="500"><h2 id="ansible을-쓰면-좀-더-좋았을까"><a href="#ansible을-쓰면-좀-더-좋았을까" class="headerlink" title="ansible을 쓰면 좀 더 좋았을까?"></a>ansible을 쓰면 좀 더 좋았을까?</h2><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/ansible_logo.png" class="" width="500"><p>최근데 linux 진영의 생태계를 뒤늦게 살펴보고 있다. 이런 식으로 여러 장비에 수행하는 공통 작업은 주로 ansible을 통해 처리하는 듯 하다. ansible은 알게 된지 얼마 되지 않아 조만간 좀 더 깊이 공부할 생각이다. </p><p>ansible을 썼다면 결과물이 좀 더 좋았을까. </p><p>아니라는 생각이 들어서 슬랙봇으로 작업을 했다. ansible이 정확히 어디까지 지원해줄 수 있을지는 모르지만, 프로그래머가 아닌 직군의 팀원들도 명령을 수행하고 결과를 확인하기에는 슬랙봇으로 붙여두는 것보다 더 좋을 수 없다고 생각했다. 혹여나 ansibble 공부해보고 개선될만한 여지가 있다면 그 때 다시 수정하는 것도 나쁘지 않겠다. </p><h2 id="Know-how"><a href="#Know-how" class="headerlink" title="Know-how"></a>Know-how</h2><p>요즘은 기능을 구현하는 방법을 알아내는 것은 아주 쉬운 일이 되었다. 유튜브도 GPT도 원하는 질문의 대답을 너무 빠르게 친절하게 알려준다. </p><p><code>어떻게 하면 만들 수 있지?</code>하는 호기심은 실천의 원동력을 제공해준다. 모르는 것을 알고 싶다는 마음이 의지를 만들고, 그 때문에 책과 자료를 찾으며 공부를 하게 된다. </p><p>하지만 요즘은 그 해답에 너무나 빠르게 접근한다. 방법을 알아내는 동안 얻게되는 부수적인 지식도 없고, 이 산인지 저 산인지 몰라 일단 헤딩해보는 여러가지 다른 삽질들도 없다. GPT는 (거의) 정확한 정답을 알려주고, 질문만 잘하면 거의 바로 쓸 수 있는 코드도 작성해준다. </p><p>방법을 알아내고 나면 동기가 갑자기 떨어진다. <code>아~ 나 그거 할 줄 알아. 요래요래 하는거지?</code> 그럼 더이상 뭔가를 알고 싶다는 흥미는 급격히 떨어지고, 다시 유튜브와 인스타를 열고 무한 도파민의 세상으로 다이브 하게된다. 여기가 프로그래머 성장을 막는 중요한 고비라는 생각이 든다. </p><p>머리에서 원리를 깨우친 것과, 실제로 손끝에서 코드를 만들어 결과물을 내는 것에는 엄청난 차이가 있다. 막상 해보고 나서야 현실과 생각이 다르다는 것을 깨닫는 경우도 많이 있다. 돌아가는 코드를 직접 만들어 보기 전에는 내 생각을 완벽히 검증할 방법이 달리 있을까. </p><img src="/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/bot_03.png" class=""><p>그래서 만들었다. 오늘이 지나기 전에 만들어야 한다고 생각했다. 아무도 시키는 사람 없었지만 해야 한다고 생각했다. 하루가 넘긴 했지만 (완성 스샷을 보면 시간이 12:34…) 그래도 만들었다.</p><p>눈에 띄는 변화는 없을지 모르지만. 나는 오늘 다시 조금 성장했다고 생각한다. </p><p>잘했다. 아주.<br>You did a great job.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/slackbot/">slackbot</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/ssh/">ssh</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/02/02/slackbot-%EB%B9%8C%EB%93%9C%EB%A8%B8%EC%8B%A0-%EC%A0%90%EA%B2%80%ED%95%98%EB%8B%A4%EA%B0%80-%EB%AC%B8%EB%93%9D-%EB%B4%87%EC%9D%84-%EC%A7%9C%EB%B3%B4%EC%95%98%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[pwsh] PsFzf가 프로필 로딩을 너무 느리게 만든다</title>
      <link>http://leafbird.github.io/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/</guid>
      <pubDate>Sat, 01 Feb 2025 04:45:31 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/psfzf_00.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;매번 터미널을 열 때마다 2 ~ 3초가 걸리는 것은 부담스럽다. &lt;/p&gt;
&lt;p&gt;방법을 찾아야 한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/psfzf_00.png" class=""><p>매번 터미널을 열 때마다 2 ~ 3초가 걸리는 것은 부담스럽다. </p><p>방법을 찾아야 한다.</p><span id="more"></span><p>기존에 사용하던 프로필은 아래와 같다. </p><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> init pwsh <span class="literal">--config</span> <span class="string">&quot;<span class="variable">$env:POSH_THEMES_PATH</span>\atomic.omp.json&quot;</span> | <span class="built_in">Invoke-Expression</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행시간이 너무 길어서 제거</span></span><br><span class="line"><span class="comment"># neofetch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure posh-git module is installed and loaded</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> PsFzf)) &#123;</span><br><span class="line">    <span class="built_in">Install-Module</span> <span class="literal">-Name</span> PsFzf <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">Invoke-FzfTabCompletion</span> &#125;</span><br><span class="line"><span class="built_in">Set-PsFzfOption</span> <span class="literal">-TabExpansion</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># replace &#x27;Ctrl+t&#x27; and &#x27;Ctrl+r&#x27; with your preferred bindings:</span></span><br><span class="line"><span class="built_in">Set-PsFzfOption</span> <span class="literal">-PSReadlineChordProvider</span> <span class="string">&#x27;Ctrl+t&#x27;</span> <span class="literal">-PSReadlineChordReverseHistory</span> <span class="string">&#x27;Ctrl+r&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ensure posh-git module is installed and loaded</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> posh<span class="literal">-git</span>)) &#123;</span><br><span class="line">    <span class="built_in">Install-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Import-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span></span><br></pre></td></tr></table></figure><p>기존에도 이미 간지를 위해 호출하던 <code>neofetch</code>를 시간이 너무 오래 걸리는 문제 때문에 포기하고 있었는데</p><p>이제 다른 처리만 해도 너무 답답한 로딩시간이 되었다. </p><h3 id="원인-확인"><a href="#원인-확인" class="headerlink" title="원인 확인"></a>원인 확인</h3><p>우선은 각 줄마다 <code>Write-Host</code> 찍으면서 수행시간을 확인해보았다. Import-Module이나 Get-Module이 오래 걸리는게 아닐까 생각했는데</p><p>가장 오래 걸리는 것은 line 11, <code>Set-PSReadLineKeyHandler -Key Tab -ScriptBlock &#123; Invoke-FzfTabCompletion &#125;</code> 이었다.</p><p>PsFzf는 명시적으로 <code>Import-Module</code>하지 않더라도, fzf관련 기능이 처음 호출되는 순간 자동으로 모듈이 로드된다. </p><p>line 11이 그 자체로 오래 걸리는 것이 아니라, 가장 처음 수행하는 fzf 설정이기 때문에 implicit하게 모듈을 임포트하는 시간이 발생했기 때문이다. 실제로 앞에서 미리 명시적으로 <code>Import-Module</code>을 수행하면 로딩시간이 줄어든다.</p><h3 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h3><p>해결이라기 보단 타협에 가까운데, 매번 초기화 하지 않는 대신 필요한 경우 쉽게 초기화할 수 있게 준비만 해두는 식으로 처리했다.</p><ul><li>매번 터미널이 뜰 때마다 모듈을 임포트하지 않게 한다. </li><li>대신 필요한 경우 설정 함수를 불러 간단하게 셋업되도록 한다.</li></ul><p>변경된 스크립트는 아래와 같다. </p><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> init pwsh <span class="literal">--config</span> <span class="string">&quot;<span class="variable">$env:POSH_THEMES_PATH</span>\atomic.omp.json&quot;</span> | <span class="built_in">Invoke-Expression</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$script:enableFzf</span> = <span class="variable">$false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Enable-Fzf</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$script:enableFzf</span>) &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;Fzf가 이미 활성화되어 있습니다.&quot;</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$script:enableFzf</span> = <span class="variable">$true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$script:stopwatch</span> = [<span class="type">System.Diagnostics.Stopwatch</span>]::StartNew()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> PsFzf)) &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;PsFzf 모듈을 설치합니다...&quot;</span></span><br><span class="line">        <span class="built_in">Install-Module</span> <span class="literal">-Name</span> PsFzf <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;탭 완성을 위한 설정을 추가합니다...&quot;</span></span><br><span class="line">    <span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">Invoke-FzfTabCompletion</span> &#125;</span><br><span class="line">    <span class="built_in">Set-PsFzfOption</span> <span class="literal">-TabExpansion</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Ctrl+t / Ctrl+r 키 입력을 설정합니다...&quot;</span></span><br><span class="line">    <span class="built_in">Set-PsFzfOption</span> <span class="literal">-PSReadlineChordProvider</span> <span class="string">&#x27;Ctrl+t&#x27;</span> <span class="literal">-PSReadlineChordReverseHistory</span> <span class="string">&#x27;Ctrl+r&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure posh-git module is installed and loaded</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Get-Module</span> <span class="literal">-ListAvailable</span> <span class="literal">-Name</span> posh<span class="literal">-git</span>)) &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="string">&quot;posh-git 모듈을 설치합니다...&quot;</span></span><br><span class="line">        <span class="built_in">Install-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;posh-git 모듈을 로드합니다...&quot;</span></span><br><span class="line">    <span class="built_in">Import-Module</span> <span class="literal">-Name</span> posh<span class="literal">-git</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Fzf 활성화가 완료되었습니다.&quot;</span></span><br><span class="line">    <span class="variable">$script:stopwatch</span>.Stop()</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;소요 시간: <span class="variable">$</span>(<span class="variable">$script:stopwatch</span>.ElapsedMilliseconds)ms&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oh-my-posh 초기화 외에는 모두 함수로 묶어두기만 했다. </p><p>터미널 사용 도중 fzf 기능이 필요한 경우는 <code>Enable-Fzf</code> 함수를 호출한다. history에 들어 있으므로 <code>ena + →</code>만 입력해도 호출 가능하다. </p><p>file scope의 변수를 추가해서 여러 번 초기화 함수를 부를 땐 중복 실행하지 않게 막았다.</p><img src="/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/psfzf_01.png" class=""><p>짠. 이제 새 터미널 창 여는 시간이 쾌적해졌다 :)</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/powershell/">powershell</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/fzf/">fzf</category>
      
      
      <comments>http://leafbird.github.io/devnote/2025/02/01/pwsh-PsFzf%EA%B0%80-%ED%94%84%EB%A1%9C%ED%95%84-%EB%A1%9C%EB%94%A9%EC%9D%84-%EB%84%88%EB%AC%B4-%EB%8A%90%EB%A6%AC%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# in 키워드 정리</title>
      <link>http://leafbird.github.io/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/</link>
      <guid>http://leafbird.github.io/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/</guid>
      <pubDate>Tue, 01 Oct 2024 07:45:38 GMT</pubDate>
      
      <description>&lt;p&gt;C#에서 메서드를 정의할 때 &lt;code&gt;in&lt;/code&gt; 키워드를 사용하면 call by value 가 아닌 call by reference로 동작하게 만들어줍니다. 그래서 주로 구조체(value type)를 복사 없이 참조로 넘길 때 유용하지요. &lt;/p&gt;
&lt;p&gt;참조 타입의 매개변수에 in 키워드를 쓰는 건 어떤 효과가 있을까요? generic parameter를 정의할 때도 in 키워드가 붙는 경우도 있던데 어떤 의미일까요?&lt;br&gt;이참에 한 번 정리해 보겠습니다. &lt;/p&gt;
&lt;img src=&quot;/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/image.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>C#에서 메서드를 정의할 때 <code>in</code> 키워드를 사용하면 call by value 가 아닌 call by reference로 동작하게 만들어줍니다. 그래서 주로 구조체(value type)를 복사 없이 참조로 넘길 때 유용하지요. </p><p>참조 타입의 매개변수에 in 키워드를 쓰는 건 어떤 효과가 있을까요? generic parameter를 정의할 때도 in 키워드가 붙는 경우도 있던데 어떤 의미일까요?<br>이참에 한 번 정리해 보겠습니다. </p><img src="/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/image.png" class=""><span id="more"></span><p>위쪽에 스샷으로 붙인 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in">learn.microsoft.com의 문서</a>에는 다섯 가지 쓰임새를 소개합니다.</p><ol><li>제네릭 타입 매개변수에서 사용</li><li>메서드 매개변수에서 값 대신 참조를 전달하도록 지정</li><li>foreach 문에서 사용</li><li>linq의 from 절에서 사용</li><li>linq의 in 절에서 사용</li></ol><p>이 중에서 3, 4, 5는 이번 포스팅의 관심사가 아닙니다. 2번을 먼저 정리하고, 그 다음 1번도 살펴보겠습니다. </p><h2 id="구조체를-인자로-넘길-때-in-사용"><a href="#구조체를-인자로-넘길-때-in-사용" class="headerlink" title="구조체를 인자로 넘길 때 in 사용"></a>구조체를 인자로 넘길 때 in 사용</h2><p><code>in</code> 키워드를 사용하여 전달받은 매개변수는 수정이 불가한 읽기 전용 참조입니다. 사이즈가 큰 구조체를 readonly로 전달할 때 사용하면 성능상의 이득을 볼 수 있습니다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> Point point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// point.X = 10; // 컴파일 에러. 값을 수정할 수 없습니다.</span></span><br><span class="line">    Console.WriteLine(point.X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point point = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">Print(point);</span><br></pre></td></tr></table></figure><p>value type 모두에 해당하는 이야기 이지만, 8byte를 넘지 않는 premitive type이나 작은 구조체인 경우에는 성능상의 이득은 없습니다.</p><h2 id="참조-타입에-in을-붙였을-때-차이점"><a href="#참조-타입에-in을-붙였을-때-차이점" class="headerlink" title="참조 타입에 in을 붙였을 때 차이점"></a>참조 타입에 in을 붙였을 때 차이점</h2><p>매개변수가 참조타입일 때 in 키워드를 사용하는 것은 어떤 효과가 있을까요? </p><h3 id="1-참조-변수가-readonly-입니다"><a href="#1-참조-변수가-readonly-입니다" class="headerlink" title="1. 참조 변수가 readonly 입니다."></a>1. 참조 변수가 readonly 입니다.</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> List&lt;<span class="built_in">int</span>&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    list.Add(<span class="number">10</span>); <span class="comment">// 컨테이너에 값을 넣을 수는 있습니다.</span></span><br><span class="line">    list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(); <span class="comment">// CS8331: 변수에 새로운 객체를 할당할 수는 없습니다.</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(list.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 C++의 <code>std::vector&lt;int&gt;</code>로 비유할 때, <code>list</code>가 <code>const std::vector&lt;int&gt;&amp;</code>와 같은 의미일 거라고 생각하는 것이 흔히 하는 실수입니다.<br>하지만 <code>std::vector&lt;int&gt; const *</code>와 같이 동작합니다. <code>list</code>컨테이너에 값을 넣을 수는 있지만, <code>list</code> 변수 자체를 다른 객체로 바꿀 수는 없습니다.</p><p>그러니 C#과 꼭 어울리는 표현은 아니지만, 참조형 매개변수에 in 키워드를 쓰는 것은 <code>포인터 변수를 const로 만들어주는 효과가 있다</code>고 말할 수 있습니다.<br>실전에선 이게 그렇게 의미있게 쓰이는 일이 많지는 않을 듯 합니다.</p><h3 id="2-호출하는-곳에서-암시적-변환이-발생하지-않도록-합니다"><a href="#2-호출하는-곳에서-암시적-변환이-발생하지-않도록-합니다" class="headerlink" title="2. 호출하는 곳에서 암시적 변환이 발생하지 않도록 합니다."></a>2. 호출하는 곳에서 암시적 변환이 발생하지 않도록 합니다.</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> IList&lt;<span class="built_in">int</span>&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(list.Count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Print(list); <span class="comment">// ok</span></span><br><span class="line">Print(<span class="keyword">in</span> list); <span class="comment">// error CS1503: 1 인수: &#x27;in System.Collections.Generic.List&lt;int&gt;&#x27;에서 &#x27;in System.Collections.Generic.IList&lt;int&gt;&#x27;(으)로 변환할 수 없습니다.</span></span><br><span class="line">Print(<span class="keyword">in</span> list <span class="keyword">as</span> IList&lt;<span class="built_in">int</span>&gt;); <span class="comment">// error CS8156: 식은 참조로 전달되거나 반환될 수 없으므로 이 컨텍스트에서 사용할 수 없습니다.</span></span><br></pre></td></tr></table></figure><p>호출하는 곳에서 <code>in</code>을 적지 않으면 문제가 없는데, <code>in</code>을 적으면 컴파일 에러가 발생합니다.<br>이는 <code>List&lt;int&gt;</code>가 <code>IList&lt;int&gt;</code>로 암시적 변환이 가능하지만, <code>in</code> 키워드를 사용하면 암시적 변환이 일어나지 않기 때문입니다.<br>이걸 암시적 변환(implicit casting)이라고 봐야 할지 모르겠습니다. <code>List&lt;int&gt;</code>는 <code>IList&lt;int&gt;</code> 인터페이스를 구현했기 때문에, upcasting인 셈이지만, in 키워드를 사용하면 이것도 불가능해집니다.<br><code>as</code> 키워드를 써서 명시적으로 변환해 주어도 에러를 피할 수 없습니다. 이 땐 ref, out 키워드에 expression을 참조로 전달할 수 없는 것과 같은 이유로 컴파일 에러가 발생합니다.<br>아예 다른 타입으로 변환하는 ‘찐’ 암시적 변환을 막아주는 예제는 아래와 같습니다. 아래 것은 좀 더 그럴싸 하지요. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">in</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">short</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">Print(<span class="keyword">value</span>); <span class="comment">// ok</span></span><br><span class="line">Print(<span class="keyword">in</span> <span class="keyword">value</span>); <span class="comment">// error CS1503: 1 인수: &#x27;in short&#x27;에서 &#x27;in int&#x27;(으)로 변환할 수 없습니다. </span></span><br></pre></td></tr></table></figure><h2 id="제네릭-타입-매개변수에서-사용"><a href="#제네릭-타입-매개변수에서-사용" class="headerlink" title="제네릭 타입 매개변수에서 사용"></a>제네릭 타입 매개변수에서 사용</h2><p>약간은 벗어나는 이야기 일 수도 있지만, in 키워드에 대해 정리하는 김에 같이 적어봅니다.</p><p>C#에서 제네릭 타입 매개변수에 in 키워드를 사용하는 것은 공변성(covariance)과 반공변성(contravariance)의 개념과 관련이 있습니다. in 키워드는 반공변성을 나타내며, 이는 특정 타입 매개변수가 제네릭 타입의 입력으로만 사용될 수 있음을 의미합니다.</p><h3 id="공변성-covariance-vs-반공변성-contravariance"><a href="#공변성-covariance-vs-반공변성-contravariance" class="headerlink" title="공변성(covariance) vs 반공변성(contravariance)"></a>공변성(covariance) vs 반공변성(contravariance)</h3><ul><li>공변성: 제네릭 타입에서 반환되는 값의 타입을 더 구체적인 하위 타입으로 사용할 수 있게 하는 것. out 키워드로 표현됩니다.</li><li>반공변성: 제네릭 타입에서 파라미터로 전달하는 값을 더 일반적인 상위 타입으로 사용할 수 있게 하는 것. in 키워드로 표현됩니다.</li></ul><h3 id="in-키워드의-효과"><a href="#in-키워드의-효과" class="headerlink" title="in 키워드의 효과"></a><code>in</code> 키워드의 효과</h3><p>in 키워드를 사용하면 제네릭 타입 매개변수가 반공변성을 가지게 됩니다. 즉, 더 일반적인 타입의 객체를 사용할 수 있습니다. 이때 해당 타입 매개변수는 입력으로만 사용되며, 반환값으로는 사용할 수 없습니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComparer</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">T x, T y</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnimalComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">Animal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">Animal x, Animal y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 단순 비교</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IComparer&lt;Dog&gt; dogComparer = <span class="keyword">new</span> AnimalComparer(); <span class="comment">// 허용됨 (반공변성)</span></span><br></pre></td></tr></table></figure><p>위 코드에서 <code>IComparer&lt;in T&gt;</code> 인터페이스는 <code>T</code> 타입 매개변수를 입력으로만 사용하므로, <code>IComparer&lt;Animal&gt;</code>을 <code>IComparer&lt;Dog&gt;</code>에 할당할 수 있게 됩니다.<br>간단하게 여기까지만. 공변성과 반공변성에 대한 이야기는 다음에 기회가 되면 다른 포스팅에서 정리해보죠.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li><code>in</code> 키워드는 주로 크기가 큰 값 타입의 매개변수를 읽기 전용 참조로 전달할 때 사용합니다.</li><li>참조 타입의 매개변수에 <code>in</code> 키워드를 사용하면 변수의 값을 readonly로 만들어줍니다.</li><li>호출하는 곳에서 <code>in</code> 키워드를 사용하면 암시적 변환이 발생하지 않습니다.</li><li>제네릭 타입 매개변수에 <code>in</code> 키워드를 사용하면 반공변성을 가지게 됩니다.</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/in-parameter-modifier">in (C# 참조)</a></li><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-7-2#in-parameters">C# 7.2의 in 매개 변수</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/C/">C#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/NET/">.NET</category>
      
      
      <comments>http://leafbird.github.io/devnote/2024/10/01/C-in-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>한 번 더 나에게 질풍같은 용기를</title>
      <link>http://leafbird.github.io/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/</link>
      <guid>http://leafbird.github.io/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/</guid>
      <pubDate>Sat, 21 Sep 2024 10:17:16 GMT</pubDate>
      
      <description>&lt;p&gt;23년 9월부터 24년 5월까지, 8개월 정도 열심히 커밋을 남겼습니다.&lt;br&gt;그러고는 한참 손을 놓고 있었는데, 다시 한 번 시작해보려고 합니다. &lt;/p&gt;
&lt;img src=&quot;/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/github_streak.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>23년 9월부터 24년 5월까지, 8개월 정도 열심히 커밋을 남겼습니다.<br>그러고는 한참 손을 놓고 있었는데, 다시 한 번 시작해보려고 합니다. </p><img src="/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/github_streak.png" class=""><span id="more"></span><h3 id="수단이-목적이-되지-않게"><a href="#수단이-목적이-되지-않게" class="headerlink" title="수단이 목적이 되지 않게"></a>수단이 목적이 되지 않게</h3><p>꼭 커밋이 아니어도 말이죠. 무언가를 습관화 하기 위해 꾸준히 수행한다는 것이 그리 쉬운 일은 아닙니다. 토이 프로젝트를 처음 시작하면서 열정이 가득할 때에는 그래도 힘들다는 느낌이 덜한데, 프로젝트의 마지막까지 그 열정을 계속 유지하기도 쉽지 않고요. </p><p>5개월.. 6개월.. 제법 시간이 지나고 나니 버거운 느낌을 받는 날이 많았습니다. streak를 끊고 싶지 않아서, 단지 commit을 위한 commit을 올리는 날도 생겼습니다. 그래도 이 목표 덕분에 하루에 한 번은 IDE를 열게 되니, 아예 안 하는 것보단 낫다는 생각으로 진행했습니다만.. 회사 업무가 바빠지면서 어느 순간 놓아버리고 말았네요. </p><blockquote><p>특정한 행동을 추적하는 것의 문제는 우리가 본래의 목적이 아니라 숫자에 휘둘리게 된다는 점이다. 성공을 분기별 수입으로 측정한다면 판매, 수익, 신용거래 같은 수치를 활용할 것이다. 속성 다이어트, 해독 주스, 지방 감소 약물 등을 이용할 때 몸무게가 줄어드는 것으로 성공을 측정한다면 ‘낮은 숫자’를 추구하게 된다. 인간의 마음은 하고 있는 게임이 무엇이든지 ‘이기고’ 싶어 하기 때문이다. 이런 위험은 우리 삶에서 자주 나타난다. 우리는 의미 있는 일을 해낸 것보다 얼마나 오랜 시간 일했는지에 초점을 맞춘다. 얼마나 건강해졌느냐보다는 1,000보 걸었느냐를 더 신경쓴다. 배움, 호기심, 비판적인 사고를 강조하기보다는 규격화된 시험을 위한 교육을 한다. 우리는 측정할 수 있는 것을 믿는다. 문제는 잘못된 측정 도구를 선택했을 때 잘못된 행동을 하게 된다는 점이다. </p><p>제임스 클리어, &lt;아주 작은 습관의 힘&gt;</p></blockquote><h3 id="숫자-보다는-성장에-초점을-맞추기"><a href="#숫자-보다는-성장에-초점을-맞추기" class="headerlink" title="숫자 보다는 성장에 초점을 맞추기"></a>숫자 보다는 성장에 초점을 맞추기</h3><p>이번에는 streak count가 주는 동기부여는 굳이 받지 않아도 좋으니, 지난번처럼 숫자에 휘둘리지 말아야 겠다고 생각하고 있습니다. 회사 업무가 바쁘거나, 개인적으로 일이 생기면 한 두 번 놓칠 수도 있죠. 그보다 중요한 것은 <code>내가 꾸준하게 개발에 관심을 두고, 배우고, 습득하는 시간 자체를 내 삶의 일부로 만들고자 노력하는 것</code>입니다. 좋은 프로그래머가 되기 위해 노력을 쏟는 것은 꼭 commit이 아닐 수 있습니다. 다른 사람의 코드를 리뷰하는 것일 수도, 책이나 인터넷의 자료를 읽고 깨우치는 것일 수도, 문제의 해결을 위해 골똘히 생각하는 시간이 될 수도 있죠.<br>자신의 성장에 유익한 시간을 쌓아가고 있는지는 본인 스스로가 알고 있습니다. 거기에 측정 가능한 수치는 단지, 거들 뿐입니다. </p><h3 id="지난번엔-macOS-이번엔-windows"><a href="#지난번엔-macOS-이번엔-windows" class="headerlink" title="지난번엔 macOS, 이번엔 windows"></a>지난번엔 macOS, 이번엔 windows</h3><p>지난번에는 macOS와 vscode를 이용하는 환경을 우선적으로 선정했습니다. 맥북을 좀 더 활용해 보고 싶었고, vs가 아닌 IDE도 한 번 익숙해져 보려고 한 선택입니다.<br>이번에는 완전한 홈 구장, windows + vs2022 환경에서 개발을 진행합니다. 무거운 납주머니를 차고 있다 벗어던진 느낌이네요. 개발을 지속하기에도 한결 수월할 것으로 예상합니다. vscode는 LOC가 많지 않은 가벼운 로직은 상관 없는데… 점점 코드 양이 많아질 수록 디버깅 환경이 아쉬웠습니다. 이게 참.. vs2022를 쉽게 벗어날 수 없는 이유입니다. </p><p>요번에 다시 개인 공부를 진행하면서 배우는 내용들이 정리가 좀 된다면… 여기 블로그에 포스팅도 좀 할 수 있으면 좋겠네요. 개발자 블로그라고 만들어두고는 너무 글을 올리지 못해 민망하군요. 호호.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/daily-commit/">daily commit</category>
      
      
      <comments>http://leafbird.github.io/devnote/2024/09/21/%ED%95%9C-%EB%B2%88-%EB%8D%94-%EB%82%98%EC%97%90%EA%B2%8C-%EC%A7%88%ED%92%8D%EA%B0%99%EC%9D%80-%EC%9A%A9%EA%B8%B0%EB%A5%BC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo에 PR을 보냈습니다</title>
      <link>http://leafbird.github.io/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/</link>
      <guid>http://leafbird.github.io/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/</guid>
      <pubDate>Thu, 02 May 2024 04:34:55 GMT</pubDate>
      
      <description>&lt;p&gt;그리고 이번 &lt;a href=&quot;https://github.com/hexojs/hexo/releases/tag/v7.2.0&quot;&gt;7.2.0 릴리즈&lt;/a&gt;에 제가 보낸 수정사항도 반영 되었습니다&lt;/p&gt;
&lt;img src=&quot;/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/screenshot0.png&quot; class=&quot;&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>그리고 이번 <a href="https://github.com/hexojs/hexo/releases/tag/v7.2.0">7.2.0 릴리즈</a>에 제가 보낸 수정사항도 반영 되었습니다</p><img src="/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/screenshot0.png" class=""><span id="more"></span><p>이제, hexo의 새 컨트리뷰터가 되었네요 :) </p><img src="/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/screenshot1.png" class=""><p>외부 모듈에 PR을 보낸게.. 10년 만이네요. 오픈 소스에 기여하시는 분들이 새삼스레 존경스러워 집니다.</p><h3 id="수정한-내용-자체는-간단했습니다"><a href="#수정한-내용-자체는-간단했습니다" class="headerlink" title="수정한 내용 자체는 간단했습니다."></a>수정한 내용 자체는 간단했습니다.</h3><p>저는 hexo를 이용해 <a href="https://leafbird.github.io/devnote">개발용 블로그</a>와 <a href="https://leafbird.github.io/blog">개인용 블로그</a> 2개를 운용하고 있습니다. </p><p>일반적으로 1개의 블로그를 운영할 때에는 gh pages 주소가 https:&#x2F;&#x2F;개인아이디.github.io 같은 형식이 될텐데요.<br>저는 두 블로그를 나누기 위해서 <a href="https://leafbird.github.io/devnote">https://leafbird.github.io/devnote</a> , <a href="https://leafbird.github.io/blog">https://leafbird.github.io/blog</a> 처럼 서브 디렉토리가 추가로 덧붙은 url을 가지고 있어요. </p><p>근데 url이 이렇게 되면.. post_link라고, 블로그의 다른 포스팅을 링크하는 기능을 쓸 때 url을 제대로 만들어주지 못하더라고요. 그래서 간단히 문자열 처리를 보완하는 기능을 덧붙였습니다.</p><h3 id="십-년-전보다-많이-체계화된-PULL-MERGE-절차"><a href="#십-년-전보다-많이-체계화된-PULL-MERGE-절차" class="headerlink" title="십 년 전보다.. 많이 체계화된 PULL - MERGE 절차"></a>십 년 전보다.. 많이 체계화된 PULL - MERGE 절차</h3><p>십년 전에는 깃헙 액션도 없던 때입니다. 다른 사람에게서 pr이 날아오면 메인테이너가 그냥 눈으로 좀 읽고 merge 해주는 식이었지요. </p><p>이번에 PR 보낼 때보니 많은 것이 자동화 되어 있었습니다. </p><ul><li>일단 프로젝트의 지정 코딩 스타일에 맞도록 lint 자동 테스트를 통과해야 하고,</li><li>당연한 이야기지만 빌드가 가능해야 하고,</li><li>제가 추가한 기능을 테스트하는 단위 테스트 로직도 함께 추가를 해주어야 합니다.</li></ul><p>hexo는 ts로 되어있는데… ts를 다뤄본 적이 없어서 코드를 아주 능숙하게 쓰지는 못했네요 @.@…</p><p>직접 사용하다보니 불편한 점이 보여서 뜻하게 않게 PR까지 해보게 됐습니다.<br>요즘 깃허브의 시스템들 조금씩 접하게 되면서 부족한 식견을 넓히고 있습니다.<br>아직 업무에서는 vcs로 git을 사용해본 적이 없어서.. 항상 얉게만 사용하고 있거든요.</p><p>요번에 덕분에 좋은 경험을 했습니다 :) </p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/contributor/">contributor</category>
      
      
      <comments>http://leafbird.github.io/devnote/2024/05/02/hexo%EC%97%90-PR%EC%9D%84-%EB%B3%B4%EB%83%88%EC%8A%B5%EB%8B%88%EB%8B%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>처음으로 접한 깃헙 액션</title>
      <link>http://leafbird.github.io/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/</link>
      <guid>http://leafbird.github.io/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/</guid>
      <pubDate>Thu, 09 Nov 2023 04:38:49 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/actions-graph.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;github actions 그거 뭐 별거냐고 대수롭지 않게 생각했었다.&lt;br&gt;근데 조금 들여다보니 자유도가 꽤나 높아서, 사람들이 정말 다양하게 활용하고 있다는 것을 알고는 흥미가 생겼다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/actions-graph.png" class=""><p>github actions 그거 뭐 별거냐고 대수롭지 않게 생각했었다.<br>근데 조금 들여다보니 자유도가 꽤나 높아서, 사람들이 정말 다양하게 활용하고 있다는 것을 알고는 흥미가 생겼다.</p><span id="more"></span><h2 id="MS-Developer-Korea에서-정리해둔-actions-소개-영상을-추천"><a href="#MS-Developer-Korea에서-정리해둔-actions-소개-영상을-추천" class="headerlink" title="MS Developer Korea에서 정리해둔 actions 소개 영상을 추천"></a>MS Developer Korea에서 정리해둔 actions 소개 영상을 추천</h2><blockquote><p>CI&#x2F;CD 그거 알지. 나도 해봤어. 울 회사에도 있어. </p></blockquote><p>actions를 제대로 알아보기 전의 내가 딱 이 정도 생각이었다. 그냥 <code>깃헙이 원래 코드 저장소를 제공하니까, 코드 올려둔 김에 빌드도 같이 돌리라고 추가기능 제공하는구나</code> 하는 느낌. 지금 일단 업무적으로는 버전 관리를 git으로 하고 있지 않기 때문에 딱히 관심이 크지 않기도 했다.</p><p>최근에 토이 프로젝트를 다시 시작하면서 actions도 조금 알아보고 있다. 한국 ms에서 만든 youtube 영상에 기본 개념 설명이 아주 잘 되어있다. actions를 처음 알아보려는 사람이라면 정주행을 권한다. 영상을 보고 나면 <code>workflow</code>, <code>job</code>, <code>step</code>, <code>action</code> 각 단계별 구성을 빠르게 잡을 수 있고, 시리즈 후반부에는 actions를 빌드나 배포가 아닌 다른 용도로 활용하는 예제 2가지를 소개하고 있다.</p><p><a href="https://www.youtube.com/watch?v=MhGpFunlmMQ&list=PLDZRZwFT9Wkt19Ox35Ir2A7CyNIWG96Nm">MS Developer Korea : Github Actions로 개발 주기 자동화</a></p><img src="/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/intro.png" class=""><p>이 영상을 보고 나면</p><ul><li>main branch는 직접 commit하지 못하게 막아둔 채로 여러 사람이 협업할 때 github을 활용하는 방법을 볼 수 있다. </li><li>pull-request를 제출한 후, 다른 사람이 리뷰를 마치고 승인했을 때, actions를 이용해서 PR에 라벨을 붙이는 예제를 볼 수 있다. (4-2)</li><li>이슈가 많이 쌓여서 관리가 필요할 때, actions를 이용해서 (라벨을 붙이면) 댓글을 달고 이슈를 닫는 예제를 볼 수 있다. (4-3)</li></ul><p>첫 번째 bullet에 적은 것처럼 main branch에는 보호 정책을 걸어두고 <code>PR - review - Merge</code>하는 흐름으로 협업하는 과정을 볼 수 있는 것도 흥미로웠다. git은 주로 개인 작업할 때 혼자서만 작업하다 보니까, commit하고 push하는거 말고는 다른 기능을 사용할 기회가 거의 없다. rebase, cherry-pick도 사용할 필요가 없어. 이 영상을 보고 branch protection rule을 어떻게 쓰는 건지 감을 잡았다.</p><h2 id="workflow를-처음-적용하면서-헤맸던-삽질들"><a href="#workflow를-처음-적용하면서-헤맸던-삽질들" class="headerlink" title="workflow를 처음 적용하면서 헤맸던 삽질들"></a>workflow를 처음 적용하면서 헤맸던 삽질들</h2><p>workflow의 문법이나 개념을 소개하기에는 이미 잘 정리된 자료들이 많이 있어서 굳이 여기에 반복할 필요는 없어 보인다. 이번에 nuget 패키지를 만들어 배포하는 workflow를 만들면서 뻘짓했던 요소들 간단히 몇가지만 정리해본다. </p><h4 id="repository가-개인-계정의-것이-아니라-organization의-소유인-경우"><a href="#repository가-개인-계정의-것이-아니라-organization의-소유인-경우" class="headerlink" title="repository가 개인 계정의 것이 아니라 organization의 소유인 경우"></a>repository가 개인 계정의 것이 아니라 organization의 소유인 경우</h4><p>packages에 파일을 올리려면 접근 권한이 필요하다. 개인 계정의 repo라면 <code>developers settings &gt; personal access tokens &gt; tokens(classic)</code>에서 발급하는 토큰을 이용하면 되는데, organization의 구성원들이 같이 공유할 수 있는 토큰 같은 개념은 없는 것 같다. 그냥 해당 repo에 접근 권한이 있는 개인이 발급한 personal token을 secret으로 등록해두고 같이 사용하게 하면 workflow를 실행하는 데에는 문제가 없다.</p><h4 id="release를-만들려면-token-외에도-권한-지정이-필요하다"><a href="#release를-만들려면-token-외에도-권한-지정이-필요하다" class="headerlink" title="release를 만들려면 token 외에도 권한 지정이 필요하다"></a>release를 만들려면 token 외에도 권한 지정이 필요하다</h4><p><a href="https://github.com/marketplace?type=actions">마켓플레이스</a>에서 검색해보면 <code>create release</code>해주는 actions가 많이 있다. 내가 사용한 것은 <a href="https://github.com/ncipollo/release-action">ncipollo&#x2F;release-action</a>이고 readme의 예시에도 설명된 내용이긴 한데, job 레벨에서 권한 지정을 해주어야 한다. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span> <span class="comment"># 이거 빼먹지 마세요... ㅜㅠ</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">ncipollo/release-action@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">artifacts:</span> <span class="string">&quot;release.tar.gz,foo/*.txt&quot;</span></span><br><span class="line">        <span class="attr">bodyFile:</span> <span class="string">&quot;body.md&quot;</span></span><br></pre></td></tr></table></figure><p>검색하다보면 permissions 설정이 없는 yml 예시도 많이 있는데, 왠지 권한 지정 문법은 나중에 추가된 것이 아닌가 싶다. 그 전에 만들어진 workflow들은 권한 지정 없이도 실행이 됐던 것 같고. 이거 빼먹고 issue 게시판에 글 올리는 사람이 나 말고도 많음.. </p><h2 id="추가로-공부할-것"><a href="#추가로-공부할-것" class="headerlink" title="추가로 공부할 것"></a>추가로 공부할 것</h2><p>지금은 <a href="https://github.com/StudioBside/Cs.Logging/blob/main/.github/workflows/nuget.yml">기본적인 nuget 패키지 배포</a> 정도 구성해봤는데, 좀 더 익숙해지려면 다른 활용을 몇가지 더 만들어봐야 할 듯 하다. actions를 미리 알았으면 지난달에 만들었던 <a href="https://github.com/leafbird/GameRankReader">모바일 게임 랭킹 순위 크롤러</a>도 깃헙에서 바로 실행&#x2F;저장하게 만들었을텐데, 그걸 몰랐네. 이거 수정하면서 좀 더 다루어봐야겠다.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://github.com/stjeong/XmlCodeGenerator/blob/master/.github/workflows/git-releases.yml">https://github.com/stjeong/XmlCodeGenerator/blob/master/.github/workflows/git-releases.yml</a> - 정성태님 repo에 있는 workflow 많이 참고했습니다. </li><li><a href="https://github.com/korea-dev-list/korea-dev-list.github.io/blob/main/.github/workflows/runner.yml">https://github.com/korea-dev-list/korea-dev-list.github.io/blob/main/.github/workflows/runner.yml</a> - workflow 활용하는 다른 예시. 정해진 시각에 실행되어 개발 블로그들의 새 글을 수집해 repo에 commit하고, github pages에 반영한다.</li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/github/">github</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/workflow/">workflow</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/actions/">actions</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/11/09/%EC%B2%98%EC%9D%8C%EC%9C%BC%EB%A1%9C-%EC%A0%91%ED%95%9C-%EA%B9%83%ED%97%99-%EC%95%A1%EC%85%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>oh-my-posh로 파워쉘 꾸미기</title>
      <link>http://leafbird.github.io/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</guid>
      <pubDate>Wed, 18 Oct 2023 23:54:03 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/win_terminal.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;지난번에 &lt;a href=&quot;/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/&quot; title=&quot;iTerm2 없이 맥 기본 터미널 꾸미기&quot;&gt;zsh을 꾸미고 나니&lt;/a&gt;, pwsh이 너무 허접해 보였다. 이런 것을 역체감이라고 하나.&lt;br&gt;어쩔 수 없지. 파워쉘도 꾸며줄 수 밖에.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/win_terminal.png" class=""><p>지난번에 <a href="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/" title="iTerm2 없이 맥 기본 터미널 꾸미기">zsh을 꾸미고 나니</a>, pwsh이 너무 허접해 보였다. 이런 것을 역체감이라고 하나.<br>어쩔 수 없지. 파워쉘도 꾸며줄 수 밖에.</p><span id="more"></span><h2 id="oh-my-posh-설치"><a href="#oh-my-posh-설치" class="headerlink" title="oh-my-posh 설치"></a>oh-my-posh 설치</h2><p>설치 자체는 어렵지 않고, 관련 정보도 검색으로 쉽게 찾을 수 있다. mac은 brew를 통해서, windows에서는 winget, choco, scoop등을 통해서 설치한다.<br>파워쉘 설정의 위치가 window와 macos가 서로 다르기 때문에 설치 스크립트에 약간 신경써줄 필요가 있음. 파워쉘의 <code>$PROFILE</code> 변수가 위치가 들어있으니까 파워쉘로 설치 동작을 작성해야 양쪽 os에 대응하기가 수월하다. </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dotfiles repository의 프로필 파일로 심볼릭 링크를 설정합니다.</span></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="variable">$profile</span> <span class="literal">-ItemType</span> SymbolicLink <span class="literal">-Value</span> <span class="variable">$sourcePath</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><p>전체 스크립트 파일은 <a href="https://github.com/leafbird/dotfiles">dotfiles</a>에 올려두었다.</p><p>동일한 테마를 사용해 mac에서 설정해 주었는데도, 프롬프트의 모양이 다르다. os별로 각각 디자인이 되어 있는 듯. 지금 사용하는 테마는 <a href="https://github.com/JanDeDobbeleer/oh-my-posh/blob/main/themes/atomic.omp.json">atomic</a>이다.</p><img src="/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/pwsh_in_macos.png" class=""><p>이미지에서 처음 프롬프트는 <code>agnoster</code> 테마를 쓰는 oh-my-zsh, 아래가 <code>atomic</code> mac 버전의 oh-my-posh이다.</p><h2 id="윈도우-로고-출력하기"><a href="#윈도우-로고-출력하기" class="headerlink" title="윈도우 로고 출력하기"></a>윈도우 로고 출력하기</h2><p>스크린샷에 있는 os 로고와 하드웨어 스펙 정보 출력을 위해 <code>neofetch</code>를 설치해 실행한다. 윈도우에서는 버전이 몇가지가 되는 듯 하고 각자 윈도우 로고 출력 모양이 다르다. 그 중에 scoop에서 설치하는 버전이 로고가 가장 예뻐서 이것으로 선택했다. 하지만 부팅 시간이 너무 오래 걸려서 평상시엔 비활성 해두었다. </p><h2 id="윈도우-터미널에-폰트-지정"><a href="#윈도우-터미널에-폰트-지정" class="headerlink" title="윈도우 터미널에 폰트 지정"></a>윈도우 터미널에 폰트 지정</h2><img src="/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/wt_font_broken.png" class=""><p>240406: 알리 세일 기간에 저렴한 윈도우 미니 PC를 구매해서 세팅. dotfiles 적용하면 폰트 깨짐. <code>Hack</code> 폰트 사용하게 지정해줘도 복구되지 않음. <code>Hack Nerd Font</code>를 사용해야 한다. 설정에 지정할 때 폰트 이름이 <code>Hack Nerd Font</code> 까지 모두 포함인 것도 주의 필요.</p><ul><li>hack nerd font download : <a href="https://www.nerdfonts.com/font-downloads">https://www.nerdfonts.com/font-downloads</a></li></ul><p>설정은 터미널 설정장에서 먼저 프로필 중에 <code>pwsh</code> 를 선택한 후, 모양 &gt; 글꼴 &gt; <code>Hack Nerd Font</code></p><img src="/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/wt_font_fine.png" class=""><h3 id="윈도우에서-vscode-폰트-설정"><a href="#윈도우에서-vscode-폰트-설정" class="headerlink" title="윈도우에서 vscode 폰트 설정"></a>윈도우에서 vscode 폰트 설정</h3><p>설정창 검색에서 <code>font family</code> 키워드로 필터링하고, Terminal &gt; Intergrated: Font Family 항목에 폰트명 지정</p><img src="/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/windows_vscode_font.png" class="">]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/pwsh/">pwsh</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/oh-my-posh/">oh-my-posh</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/10/18/oh-my-posh%EB%A1%9C-%ED%8C%8C%EC%9B%8C%EC%89%98-%EA%BE%B8%EB%AF%B8%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>웹페이지 반응형 디자인하기</title>
      <link>http://leafbird.github.io/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Thu, 12 Oct 2023 04:19:34 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/before_after.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;모바일에서 볼 때 왼쪽같이 보이던 페이지를 오른쪽처럼 변경했다. 지금은 블록 여백 등도 조금 더 정리해서 일단락 지었다. 실제 페이지는 &lt;a href=&quot;https://leafbird.github.io/&quot;&gt;https://leafbird.github.io&lt;/a&gt; 에서 확인 가능하다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/before_after.png" class=""><p>모바일에서 볼 때 왼쪽같이 보이던 페이지를 오른쪽처럼 변경했다. 지금은 블록 여백 등도 조금 더 정리해서 일단락 지었다. 실제 페이지는 <a href="https://leafbird.github.io/">https://leafbird.github.io</a> 에서 확인 가능하다. </p><span id="more"></span><p>수정한 문서는 오래전에 간단하게 만들어둔 프로필인데, 얼마전에 이걸 최신화 해야겠단 생각이 들어 다시 열었다. 디자인 수정을 마치고 확인하다 보니… 맥에서 작업할 때는 괜찮았는데, 폰으로 볼 때는 디자인이 그대로 축소되면서 사람의 시력으로 읽을 수 없는 상태가 되어버리고 있었다. 이 페이지를 처음 만들 때는 10년 전이었고 모바일이 지금만큼 많이 쓰이지는 않던 시절이었지만, 이제는 모바일이 주류가 되었으니 수정이 필요했다.</p><h2 id="meta-태그를-이용해-화면이-축소되지-않도록-붙잡아준다"><a href="#meta-태그를-이용해-화면이-축소되지-않도록-붙잡아준다" class="headerlink" title="meta 태그를 이용해 화면이 축소되지 않도록 붙잡아준다"></a>meta 태그를 이용해 화면이 축소되지 않도록 붙잡아준다</h2><p>너비가 줄어들 때 컨텐츠도 동일 비율로 작아져 버리는 현상만 놓고 보면 아래 meta 태그만 추가해주면 끝이다. 그럼 화면이 축소될 때 컨텐츠를 스케일하지 않고 기존의 크기를 유지해준다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>문제는 그 다음부터인데.. 요소들의 크기는 변하지 않으면서 페이지의 넓이만 좁아지면 레이아웃이 엉망이 된다. 테이블이 삐져나가고 사진 위로 글이 올라오고… 이 페이지를 처음 만들었을 때는 모바일 지원 같은 것에 별 뜻이 없었기 때문에 문서 폭을 620px로 고정해두고 절대값 수치들로 디자인을 해뒀었는데, 그렇게 해서는 대응이 어렵다.</p><h2 id="bootstrap의-grid를-이용하면-수월하다"><a href="#bootstrap의-grid를-이용하면-수월하다" class="headerlink" title="bootstrap의 grid를 이용하면 수월하다"></a>bootstrap의 grid를 이용하면 수월하다</h2><p>bootstrap은 2.x 버전 붙어있던 것을 5.3으로 변경했다. 그사이 부쩍 올라가있는 버전을 보니 세월이 많이 흘렀구나. 이전 버전에도 물론 grid 시스템은 존재하지만 이제는 2.x 버전 문서 억지로 찾아들어가 보기가 더 어렵다. 굳이 예전 버전을 유지할 이유도 없고. 사용법이 약간 달라지긴 했지만 워낙에 별 내용 없는 페이지라 수정할 것은 많지 않았다.</p><p><a href="https://getbootstrap.com/docs/5.3/layout/grid/">https://getbootstrap.com/docs/5.3/layout/grid/</a></p><img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/grid_table.png" class=""><p>예전부터 bootstrap 에 기웃거리긴 했지만 grid 시스템 어떻게 써먹는 것인지 이번에야 이해하게 되었다. <code>-sm-</code>, <code>-md-</code>, <code>-lg-</code> 이런거 바꿔 달아봐야 화면상에 변하는 것도 없고 뭐때문제 붙이는 건지 몰랐는데, 브라우저 너비마다 폭을 다르게 잡아주기 위해 쓰는 거였어. 가운데 블록은 화면이 넓을 때는 이미지와 테이블을 한 줄에 표현하고, 화면이 좁으면 두 줄로 나눠서 표현하는데, 아래처럼 처리했다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 이미지가 들어가는 블록 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 offset-lg-2 col-md-3 offset-md-1 col-sm-4 offset-sm-0&quot;</span>&gt;</span></span><br><span class="line">    .... 이미지 컨텐츠</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 내용 테이블 들어가는 블록 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-6 offset-lg-0 col-md-7 offset-md-0 col-sm-12 offset-sm-0&quot;</span>&gt;</span></span><br><span class="line">    .... 테이블 컨텐츠</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>브라우저 넓이가 sm, md, lg 영역에 해당할 때 컨텐츠 영역과 오프셋의 크기를 별도로 지정해준다. grid의 합이 12보다 작으면 한 줄에 출력하고, 넘으면 두 줄로 나누어 출력된다.</p><p>난 사실 frontend 쪽은 전문 분야가 아니라서 거의 취미 코더에 가깝다. bootstrap은 디자인 자유도가 떨어지고 제한적이라 pro들은 기피한다는 이야기를 들은 듯 하지만 나하곤 상관 없는 이야기다. 너무 좋아 bootstrap. 가끔씩 업무상 필요한 간단한 in-house tool을 만들 때에도 정말 큰 도움을 준다. </p><h2 id="media-태그를-이용해서-추가로-레이아웃을-다듬는다"><a href="#media-태그를-이용해서-추가로-레이아웃을-다듬는다" class="headerlink" title="@media 태그를 이용해서 추가로 레이아웃을 다듬는다"></a>@media 태그를 이용해서 추가로 레이아웃을 다듬는다</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media">https://developer.mozilla.org/en-US/docs/Web/CSS/@media</a></p><p>bootstrap의 grid도 사실은 <code>@media</code> 태그를 이용해 미리 정의된 디자인 세트일 뿐이다. viewport 사이즈에 따라 다른 디자인을 가능하게 만드는 핵심은 스타일 시트에서 <code>@media</code>를 이용해 각각 다른 디자인을 적용해 주는 것이다.</p><p>처음엔 <code>@media</code>로 별도 제어하는 디자인을 많이 정의했다가, grid를 제대로 붙이고 나니 거의 다 사라지게 되었고 내가 별도로 처리할 만한 것이 많이 없었다. viewport가 필요 이상으로 넓을 때 컨텐츠가 너무 넓게 퍼지지는 않도록 최대 폭을 제한해 준다거나, 레이아웃이 바뀌면서 어색해지는 서로간의 간격 정도만 다듬어준다.</p><p>media 태그 기능과 사용방법을 정리한 글은 구글링으로 아주 많이 찾을 수 있다. 내가 참고한 게 뭐였는지 다시 찾으려고 했는데 못찾을 많큼 많음. 나중에 필요하면 다시 구글링 하면서 써도 충분하기에 정리는 생략.</p><h2 id="최종-결과"><a href="#최종-결과" class="headerlink" title="최종 결과"></a>최종 결과</h2><ul><li>desktop에서 본 화면 (windows, chrome)</li></ul><img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/final_desktop.png" class=""><ul><li>내 폰에서 본 화면 (iPhone 13 mini)</li></ul><img src="/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/final_ios.png" class=""><h2 id="크롬에서-작업할-것을-추천"><a href="#크롬에서-작업할-것을-추천" class="headerlink" title="크롬에서 작업할 것을 추천"></a>크롬에서 작업할 것을 추천</h2><ul><li>크롬의 기본 개발자 기능이 반응형 디자인을 확인하기 좀 더 수월하다.</li><li>크롬 익스텐션 중에 반응형 웹디자인에 <a href="http://icunow.co.kr/chrome-extension5/">도움을 주는 툴들</a>이 많음. </li><li>사파리에도 <a href="https://developer.apple.com/documentation/safari-developer-tools/responsive-design-mode">Responsive Design Mode</a>라는 것이 있지만, 크롬이 더 나은 것 같애.</li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/bootstrap/">bootstrap</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/html/">html</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/responsive/">responsive</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/10/12/%EC%9B%B9%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>iTerm2 없이 맥 기본 터미널 꾸미기</title>
      <link>http://leafbird.github.io/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/</guid>
      <pubDate>Mon, 09 Oct 2023 11:14:20 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/mac_terminal.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;아,&lt;br&gt;사람들이 왜 터미널을 예쁘게 꾸미는지 이제야 알았다.&lt;br&gt;코딩 뽕이 막 차오르네. 뭐라도 막 만들고 싶어진다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/mac_terminal.png" class=""><p>아,<br>사람들이 왜 터미널을 예쁘게 꾸미는지 이제야 알았다.<br>코딩 뽕이 막 차오르네. 뭐라도 막 만들고 싶어진다.</p><span id="more"></span><h2 id="백업을-위한-설정-내용-간단-정리"><a href="#백업을-위한-설정-내용-간단-정리" class="headerlink" title="백업을 위한 설정 내용 간단 정리"></a>백업을 위한 설정 내용 간단 정리</h2><p>맥 터미널 꾸미기에 대한 자료는 이미 수도 없이 많지만 이번에 세팅해둔 설정을 백업하는 의미로 간단히 정리한다. 우선 나는 주로 아래의 포스팅을 보고 진행했다. </p><ul><li><a href="https://kdohyeon.tistory.com/m/122">터미널 꾸미기: Oh-my-zsh + iTerm2</a></li><li><a href="https://velog.io/@seona-jung/%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0-oh-my-zsh">iTerm2 없이 터미널 꾸미기</a></li></ul><p>본 포스팅에 기술할 변경 내용을 반영한 거의 모든 설정 파일은 <a href="https://github.com/leafbird/dotfiles.git">dotfiles</a>에 백업해 두었다.<br>거의 모든이라 함은.. <code>Hack</code> 폰트 설치 같은 것은 설정 파일 반영만으로 어려우니, 재설정이 필요할 때 이 부분은 별도 진행 해야 한다.</p><h3 id="oh-my-zsh의-테마-변경"><a href="#oh-my-zsh의-테마-변경" class="headerlink" title="oh-my-zsh의 테마 변경"></a>oh-my-zsh의 테마 변경</h3><p>두 글 다 테마로 <code>agnoster</code>를 사용한다. 다른 포스팅에서도 이 테마가 자주 언급되는 걸 보니 꽤나 인기 테마인듯 하다. 하지만 git 상태 알려주는 부분 폰트가 깨지기 때문에 <a href="https://sourcefoundry.org/hack/">Hack</a> 폰트를 따로 설치해 주어야 한다.</p><h3 id="터미널-컬러-테마-변경"><a href="#터미널-컬러-테마-변경" class="headerlink" title="터미널 컬러 테마 변경"></a>터미널 컬러 테마 변경</h3><p>터미널의 color theme를 <a href="https://github.com/sindresorhus/terminal-snazzy">snazzy</a>로 변경해준다. 터미널의 윈도우 사이즈도 같이 바뀌니까 적당히 조절해주고, 모니터 크기에 맞춰 폰트 사이즈도 조절한다 (나는 맥미니와 맥북의 폰트 사이즈를 다르게 설정해둠.) 한가지 중요한 점이 커서 모양인데, 터미널에서 사각박스 모양의 커서를 사용해야 vim에서 normal&#x2F;insert 모드 인식이 쉽기 때문에 이 설정을 다시 사각박스로 되돌려준다. </p><img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/cursor_setting.png" class=""><h3 id="zsh-플러그인-설치"><a href="#zsh-플러그인-설치" class="headerlink" title="zsh 플러그인 설치"></a>zsh 플러그인 설치</h3><p>나중엔 다른 걸 더 쓰게 될지 모르겠지만 지금은 우선 <code>zsh-syntax-highlighting</code>만 설치.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h3 id="agnoster-테마파일을-열어서-터미널-입력-위치에-개행-추가"><a href="#agnoster-테마파일을-열어서-터미널-입력-위치에-개행-추가" class="headerlink" title="agnoster 테마파일을 열어서 터미널 입력 위치에 개행 추가"></a>agnoster 테마파일을 열어서 터미널 입력 위치에 개행 추가</h3><p>이건 참고한 포스팅에서 텍스트 대신에 스크린샷을 올려두셔서… 보고 따라치느라 애먹음;; 스크립트 중간에 문자열 안의 줄바꿈을 그대로 인식하는 식이라서, 예쁘게 적는다로 한 줄로 적으면 제대로 개행되지 않는다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">## Main prompt</span><br><span class="line">build_prompt() &#123;</span><br><span class="line">  RETVAL=$?</span><br><span class="line">  prompt_status</span><br><span class="line">  prompt_virtualenv</span><br><span class="line">  prompt_aws</span><br><span class="line">  prompt_context</span><br><span class="line">  prompt_dir</span><br><span class="line">  prompt_git</span><br><span class="line">  prompt_bzr</span><br><span class="line">  prompt_hg</span><br><span class="line">  prompt_newline // 이 부분을 추가. 꼭 순서 지켜서.</span><br><span class="line">  prompt_end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROMPT=&#x27;%&#123;%f%b%k%&#125;$(build_prompt) &#x27;</span><br><span class="line"></span><br><span class="line">prompt_newline() &#123;</span><br><span class="line">  if [[ -n $CURRENT_BG ]]; then</span><br><span class="line">    echo -n &quot;%&#123;%k%F&#123;$CURRENT_BG&#125;%&#125;$SEGMENT_SEPARATOR</span><br><span class="line">%&#123;%k%F&#123;blue&#125;%&#125;$SEGMENT_SEPARATOR&quot;</span><br><span class="line">  else</span><br><span class="line">    echo -n &quot;%&#123;%k%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  echo -n &quot;%&#123;%f%&#125;&quot;</span><br><span class="line">  CURRENT_BG=&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vscode-에-hack-폰트-지정"><a href="#vscode-에-hack-폰트-지정" class="headerlink" title="vscode 에 hack 폰트 지정"></a>vscode 에 hack 폰트 지정</h3><p>기본 순정 터미널을 설정했기 때문에 vscode에서 별다른 것 해주지 않아도 알아서 변경사항이 반영된다. 새로 설치한 font만 추가 지정해주면 끝.</p><img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/vscode_setting.png" class=""><img src="/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/vscode.png" class="">]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/iTerm2/">iTerm2</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/terminal/">terminal</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/osx/">osx</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/agnoster/">agnoster</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/vscode/">vscode</category>
      
      
      <comments>http://leafbird.github.io/devnote/2023/10/09/iTerm2-%EC%97%86%EC%9D%B4-%EB%A7%A5-%EA%B8%B0%EB%B3%B8-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%BE%B8%EB%AF%B8%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - 메모리 단편화</title>
      <link>http://leafbird.github.io/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/</link>
      <guid>http://leafbird.github.io/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/</guid>
      <pubDate>Sun, 08 Aug 2021 12:44:20 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/00.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;이제 닷넷의 GC는 꽤나 쓸만하게 발전하여, 웬만한 경우는 프로그래머가 메모리 관리를 굳이 신경쓰지 않고 코딩할 수 있게 도와준다. 그리고 그것이 C++ 대신 C#을 선택하는 큰 이유이기도 하다. 하지만 C# 게임서버로도 성능에 욕심을 내고자 한다면, 짧은 순간 대량의 TPS를 낼 수 있는 네트워크 IO를 구현하려고 한다면 어느정도 메모리 운용에 대한 이해가 필요하다.&lt;/p&gt;
&lt;p&gt;이번 포스팅에서는 네트워크 IO의 부하가 가중될 때 겪을 수 있는 메모리 단편화 현상에 대해서 정리해본다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/00.jpg" class=""><p>이제 닷넷의 GC는 꽤나 쓸만하게 발전하여, 웬만한 경우는 프로그래머가 메모리 관리를 굳이 신경쓰지 않고 코딩할 수 있게 도와준다. 그리고 그것이 C++ 대신 C#을 선택하는 큰 이유이기도 하다. 하지만 C# 게임서버로도 성능에 욕심을 내고자 한다면, 짧은 순간 대량의 TPS를 낼 수 있는 네트워크 IO를 구현하려고 한다면 어느정도 메모리 운용에 대한 이해가 필요하다.</p><p>이번 포스팅에서는 네트워크 IO의 부하가 가중될 때 겪을 수 있는 메모리 단편화 현상에 대해서 정리해본다. </p><span id="more"></span><h2 id="기본-용어-및-개념-정리"><a href="#기본-용어-및-개념-정리" class="headerlink" title="기본 용어 및 개념 정리"></a>기본 용어 및 개념 정리</h2><h3 id="SOH-LOH-POH"><a href="#SOH-LOH-POH" class="headerlink" title="SOH &#x2F; LOH &#x2F; POH"></a>SOH &#x2F; LOH &#x2F; POH</h3><p>가장 먼저 <code>관리 힙(managed heap)</code>의 구분부터 이야기 해야한다. 관리힙은 사용 메모리의 크기와 용도 등에 따라 <code>SOH</code>, <code>LOH</code>, <code>POH</code>로 나뉜다.</p><ul><li><code>SOH</code>는 Small Object Heap으로, 85kb보다 작은 사이즈의 메모리를 할당한다. 경우에 따라 차이는 있겠지만 대다수의 객체들이 주로 할당&#x2F;해제 되는 공간이다. </li><li><code>LOH</code>는 Large Object Heap으로, 85kb보다 큰 사이즈의 메모리를 할당한다. </li><li><code>POH</code>는 Pinned Object Heap으로, pinning할 메모리를 위해 .Net 5부터 새롭게 추가된 공간이다.</li></ul><p>POH는 사실 다짜고자 단편화의 해법에 가까운 존재이긴하나.. 분류상 미리 언급되었다. 이후에 다시 추가적으로 설명한다.</p><h3 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h3><p><code>SOH</code>의 메모리는 객체가 얼마나 오래 살았느냐에 따라 0세대부터 2세대까지 세대를 구분한다. GC가 한 번 실행될 때 사용이 끝난 메모리는 해제되고, 아직 사용중인 메모리는 다음 세대로 승격한다. 이 때 살아남은 메모리들은 <code>압축(Compression)</code>의 과정을 거친다. 압축이란 메모리 단편화를 줄이기 위해, 살아남은 메모리들을 사이사이 공백이 없도록 한 공간으로 몰아서 재배치하는 동작을 말한다. 실제로 관리 힙 내부에서 객체들은 세대별로 모아두어야 하기 때문에, 메모리 해제 및 승격을 거친 후에는 세대별 구획에 맞춰 메모리를 재정렬하는 과정이 반드시 필요하다.</p><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/01.png" class=""><p>오.. 이거 처음에 너무 신기했다. 네이티브 언어로 만들어진 코드에서는 불가능한 동작이다. C++로 짠 코드라면 프로그래머가 직접 작성한 비즈니스 로직 상에서 이미 무수히 많은 포인터들이 가상 메모리의 주소값 자체를 가르키고 있기 때문이다. C#의 참조타입 변수들도 C++ 포인터와 유사하다고 볼 순 있지만 직접적으로 메모리 주소가 노출되어 있지는 않기 때문에 가능한 일이다. 객체의 메모리상 주소가 바뀌더라도 모든 참조들을 새로운 주소값으로 알아서 갱신해 주어서, 매니지드 레벨의 코드상에서는 마치 아무 일도 없었다는 듯이 시치미를 떼는 신박한 동작이다. </p><h3 id="Pinned-Memory"><a href="#Pinned-Memory" class="headerlink" title="Pinned Memory"></a>Pinned Memory</h3><p>하지만 메모리 압축이 이미 할당된 모든 객체들의 위치를 제멋대로 바꿀 수 있는 것은 아니며, 모든 법칙에 항상 예외는 존재한다. 매니지드 레벨은 결국 네이티브 레벨 위에서 돈다. 네이티브 영역과의 상호참조가 필요한 매니지드 메모리는 함부로 값을 옮겨다닐 수가 없다. 위에서 언급한 <code>C++로 만든 코드였다면 불가능</code>하다고 말한 이유와 크게 다르지 않은 상황이다.<br>네이티브 영역에서 매니지드 영역의 메모리를 참조할 일이 있을 때는 메모리를 이동이 발생하지 않는 안전한 공간에 복사(copying)하거나, 이동할 수 없도록 고정(pinning)해둬야 한다. 매니지드 메모리가 다른 주소로 이동하지 않도록 고정하는 것을 <code>Memory Pinning</code>, 이렇게 고정된 메모리를 <code>Pinned Memory</code>라고 부른다.</p><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/02.gif" class=""><p>데이터 마샬링(매니지트&#x2F;네이티브 상호통신)의 입장에서 보면 pinning은 불필요한 복사를 줄여주는 효율적인 동작이다. 하지만 가비지 컬렉터 입장에서 보자면 엄청난 방해꾼임이 분명하다. pinned memory 는 gc의 압축 동작을 방해하기 때문이다</p><blockquote><p>고정(Pinning)은 데이터를 현재 메모리 위치상에 임시로 잠그기 때문에, CLR의 가비지 수집기에 의한 재배치를 막아줍니다.<br>Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime’s garbage collector.<br>(<a href="https://docs.microsoft.com/en-us/dotnet/framework/interop/copying-and-pinning">https://docs.microsoft.com/en-us/dotnet/framework/interop/copying-and-pinning</a>)</p></blockquote><blockquote><p>고정(Pinning)은 메모리의 단편화를 유발하고, 일반적으로 객체 압축 과정을 복잡하게 만들기 때문에 자체적인 비용 부담을 가집니다.<br>Pinning has its own costs, because it introduces fragmentation (and in general complicates object compaction a lot).<br>(<a href="https://tooslowexception.com/pinned-object-heap-in-net-5/">https://tooslowexception.com/pinned-object-heap-in-net-5/</a>)</p></blockquote><h2 id="단편화-발생의-원인"><a href="#단편화-발생의-원인" class="headerlink" title="단편화 발생의 원인"></a>단편화 발생의 원인</h2><p>성능좀 끌어올려보겠다고 다짐한 C# 게임서버의 메모리 단편화는 어디서 발생하는가. </p><p>핵심부터 말하자면 소켓의 send &#x2F; receive에 걸어주는 바이트 배열 버퍼가 pinning되기 때문에, 가비지 컬렉터의 압축과정을 많이 방해하게 되면서 메모리 단편화를 유발한다. 이 부분이 메모리 단편화의 가장 주된 요인이다. 그런데다가 높은 TPS를 처리해내는 고성능 게임서버를 만들려고 한다면.. 소켓 IO의 수가 많아짐에 따라 네트워크 버퍼의 개수와 사용 빈도도 당연히 높아질 수밖에 없다. 때문에 대량의 네트워크 통신을 견딜 수 있도록 만드려면 네트워크 버퍼를 어떻게 운용할 것인지가 중요하다.</p><p>DB와 통신하기 위한 DBMS 클라이언트도 많은 수의 pinned handle을 만들어낸다. 현재 우리 프로젝트는 <code>System.Data.SqlClient</code> 네임스페이스 하위의 클래스들을 이용해 Azure SQL과 통신하고 있는데, 생각해보면 db client도 DBMS에 연결되어 쿼리와 데이터를 던지고 받는 통신모듈이니 당연한 이야기다. </p><p>코드상에서 임의의 객체를 약참조 하기 위해 사용하는 <code>System.WeakReference</code>도 pinning handle을 사용하고 있어, 단편화 유발의 원인이 된다. 이건 참 아이러니한 일이다. 참조하는 대상이 쉽게 메모리 해제될 수 있도록 약참조하는 기능을 하지만, <code>WeakReference</code> 자신은 고정된 메모리를 만들면서 메모리 단편화를 가속시킨다. 처음 서버 기반을 만들 땐 <code>WeakReference</code>가 GC를 방해한다는 사실을 모르고 엄청시리 쓰고 있었는데, 비교적 근래에 실 서비스에서 메모리 문제들을 겪으면서 디버깅 하던 중 메모리가 고정되고 있음을 알게됐다. 현재는 약참조 사용이 꼭 필요한 일부를 제외하고는 모두 제거하였고, 가능하면 <code>WeakReference</code> 의 사용을 자제하고 있다.</p><p>메모리 상의 고정된 핸들에 대한 정보는 windbg로 힙을 뒤져보면 알 수 있다. <code>sos.dll</code> 로딩된 상태에서 <code>!gchandles</code> 명령 쳐보면 현재 어떤 객체가 pinning되어있고, 몇개나 존재하는지 확인할 수 있다.</p><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/memory_01.png" class=""><img src="/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/memory_00.png" class=""><h2 id="단편화-해결-솔루션"><a href="#단편화-해결-솔루션" class="headerlink" title="단편화 해결 솔루션"></a>단편화 해결 솔루션</h2><p>상술한 원인들 중 가장 명백한 원인제공자는 네트워크 버퍼다. 빈번히 쓰이는 네트워크 버퍼를 잘 운용하는 것이 단편화 해결의 핵심이다.</p><p>네트워크 버퍼용 <code>byte[]</code> 객체를 <code>ArrayPool&lt;T&gt;</code> 을 이용해 풀링하는 것은 그다지 개선의 효과가 없었다. <code>ArrayPool&lt;T&gt;</code>클래스는 효율적으로 객체의 할당과 해제 빈도를 완화하고 관리해주지만, 어쨌거나 <code>SOH</code> 공간에서 할당을 받기 때문에, 이글에서 말하고 있는 pinning 이나 단편화 현상 해결 등과는 크게 상관이 없다. </p><p>메모리 압축은 <code>SOH</code>에서만 발생한다. 따라서 pinned memory가 GC성능 저하 및 메모리 단편화를 일으키는 것도 <code>SOH</code>에만 해당하는 이야기다. 그러니 네트워크 버퍼는 그냥 <code>SOH</code>에 잡지 않는 것이 좋겠다.</p><h3 id="솔루션-1-네트워크-버퍼를-POH에-할당하기"><a href="#솔루션-1-네트워크-버퍼를-POH에-할당하기" class="headerlink" title="솔루션 1. 네트워크 버퍼를 POH에 할당하기"></a>솔루션 1. 네트워크 버퍼를 POH에 할당하기</h3><p>MS 형들도 역시 성능상에서 이런 문제가 있음을 분명히 알고 있다. <code>.NET 5</code>부터는 고정된 메모리로 사용할 객체를 할당하는 별도의 힙 공간인 <code>POH</code>가 새로 생겼다. 현재 회사에서 만든 게임 서버는 프레임워크 버전이 낮아서 아직 사용해 보지는 못했다. (우리 프로젝트는 .NET Framework 4.7.2로 개발을 시작해서 현재 .NET Core 3.1을 사용중이다). <a href="https://tooslowexception.com/pinned-object-heap-in-net-5/">이 글</a>에서 <code>POH</code>에 대한 기본적인 설명을 확인할 수 있다. 아직 서비스하기 전이거나, 사용중인 프레임워크가 <code>.NET 5</code> 이상이라면 <code>POH</code>의 도입을 검토해 볼 만 하다.<br>링크된 글에서 설명하는 것처럼 <code>POH</code>는 그 존재 목적상, blittable 형식만을 할당할 수 있도록 제한되어있다. 네이티브 코드와 통신하기 위한 데이터를 할당하는 전용의 공간이므로, 기술적인 한계가 아닌 설계상의 의도로 제한을 걸어두었다.</p><h3 id="솔루션-2-네트워크-버퍼를-LOH에-할당하기"><a href="#솔루션-2-네트워크-버퍼를-LOH에-할당하기" class="headerlink" title="솔루션 2. 네트워크 버퍼를 LOH에 할당하기"></a>솔루션 2. 네트워크 버퍼를 LOH에 할당하기</h3><p><code>LOH</code>의 객체들은 메모리 압축으로 인한 재배치를 진행하지 않으며, 세대가 구분되어있지도 않다. 2세대 GC가 수행될 때만 <code>LOH</code>상의 메모리 해제가 진행되므로, 모두 2세대 객체라고 부르기도 한다. 세대 구분이 없으니 메모리 공간상에서 꼭 재배치(Compression) 해주어야 할 필요도 없다.<br><code>LOH</code>의 객체는 기본설정상 가상 메모리 주소공간에 한 번 할당되면 위치가 이동되지 않는다. 그러니 빈번하게 할당과 해제를 반복하는 메모리를 <code>LOH</code>에 많이 만들면 금방 조각나버릴 공간이다. 이런 경우라면 <code>LOH</code>에서도 압축을 하도록 설정을 조정할 수는 있지만.. 이렇게 사용하는 것은 그다지 취지(?)에 맞지 않는 기분이 든다. <code>LOH</code>에는 오래도록 유지하거나, 아예 해제할 계획이 없는 덩치큰 메모리들을 위치시키는 것이 용도상 더 적절하다.<br>우리는 게임 런칭 전 10만 동접을 시뮬레이션하는 부하테스트를 진행했다. 당시 메모리 단편화 이슈로 한참을 고생하던 중, <a href="https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation">이 글의 해결 사례</a>를 보고나서 네트워크 버퍼 할당을 LOH로 옮겨 보기로 했다.</p><p>네트워크 버퍼를 <code>LOH</code>로 옮긴 이후 메모리 단편화 문제는 말끔해 해결되었다. 한 번에 100Mb 단위의 커다란 메모리 청크를 <code>LOH</code>에 잡아두고, 이를 다시 <code>ArraySegment&lt;byte&gt;</code>로 잘게 나누어 풀링하면서 사용하는 방식이다. C++에서 고전적으로 메모리 풀링을 구현할 때 접근하는 방식과 유사하다. </p><p>C#에서는 버퍼의 조각을 <code>byte[]</code>로 표현할 수 없다. C++에서 <code>byte[]</code>는 개념상 가르키는 대상이 고정인 포인터 (<code>byte * const</code>)와 유사하다(물론 문법상 차이는 있다). 그러므로 커다란 바이트 배열도 포인터, 여러개의 작은 배열들도 포인터로 가르키는 셈이니까 모두 <code>byte[]</code>로 표현되는게 아무 문제가 없다. 하지만 C#에서는 <code>byte[]</code>도 하나의 독립된 매니지드 객체이므로 C++과는 차이가 있다. 큰 배열의 단위조각을 표현할 때 <code>ArraySegment&lt;byte&gt;</code>를 사용해야 하는 이유다.</p><p>조금은 다른 이야기지만 처음 <code>ArrayPool&lt;T&gt;</code> 가 BCL에 들어왔을때 아주 당연하게 착각한것이, 이놈으로 <code>byte[]</code>를 풀링하면 내부적으로 큰 청크를 한 번만 할당해서 이걸 조각내서 쓸것으로 생각했다. 메모리 관리라 하면 으레 이 방식이 익숙해서였다. 하지만 조금만 생각해보면, C#에서는 불가능한 이야기다. 덩치큰 <code>byte[]</code>를 여러개의 작은 <code>byte[]</code>로 표현할 수가 없다. <code>ArrayPool&lt;T&gt;</code> 코드를 보면 할당 자체는 <code>SOH</code>상에서 단일객체 단위로 발생하나, 그 외 나머지 기법들을 이용해 최적화를 진행함을 알 수 있다. 코드를 보면 2세대 GC가 불릴 때 콜백을 얻어와 현재 메모리 압력을 진단하고, 선택적으로 메모리를 해제하는 등의 테크닉을 볼 수 있다. 이런건 나중에 메모리 로우레벨을 제어해야 할 경우 참고하여 응용하면 좋을듯 하다.</p><ul><li><a href="https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/ArrayPool.cs">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/ArrayPool.cs</a></li><li><a href="https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/shared/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs</a></li></ul><p>이전 포스팅 <a href="https://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/">C# 고성능 서버 - System.IO.Pipeline 도입 후기</a>에서 여러개의 단위버퍼를 이어붙여 가상의 스트림처럼 운용하는 <code>ZeroCopyBuffer</code>의 구현에 대해 간단히 소개했었다. 이 때 등장했던 단위버퍼 <code>LohSegment</code> 클래스가 바로 <code>LOH</code>에 할당한 커다란 청크의 일부분에 해당한다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.ServerEngine.Netork.Buffer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ZeroCopyBuffer</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Queue&lt;LohSegment&gt; segments = <span class="keyword">new</span> Queue&lt;LohSegment&gt;();</span><br><span class="line">    <span class="keyword">private</span> LohSegment last;</span><br><span class="line">    <span class="comment">//       ^ 여기 얘네들이예요. </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>LohSegment</code>를 생성, 풀링하고 관리하는 구현은 크게 대단할 것은 없다. 어차피 할당 크기가 85kb보다 크기만 하면 알아서 <code>LOH</code>에 할당될 것이고.. 청크를 다시 잘 쪼개서 <code>ConcurrentQueue&lt;&gt;</code>에 넣어뒀다가 잘 빌려주고 반납하고 관리만 해주면 된다.<br>조금 더 신경을 쓴다면 서비스 도중 메모리 청크를 추가할당 할 때의 처리 정도가 있겠다. Pool에 남아있는 버퍼의 개수가 좀 모자란다 싶을 때는 CAS 연산으로 소유권을 선점한 스레드 하나만 청크를 할당하게 만든다. 메모리는 추가만 할 뿐 해제는 하지 않을거니까 이렇게 하면 lock을 안 걸어도 되고, pool의 사용도 중단되지 않게 만들 수 있다. 해당 구현체의 멤버변수들만 붙여보면 아래와 같다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.Memory</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">LohPool</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSizeMb = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> LowSegmentNumberLimit = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> segmentSizeKb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> segmentSizeBytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;<span class="built_in">byte</span>[]&gt; chunks = <span class="keyword">new</span> List&lt;<span class="built_in">byte</span>[]&gt;(capacity: <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentQueue&lt;ArraySegment&lt;<span class="built_in">byte</span>&gt;&gt; segments = <span class="keyword">new</span> ConcurrentQueue&lt;ArraySegment&lt;<span class="built_in">byte</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> AtomicFlag producerLock = <span class="keyword">new</span> AtomicFlag(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> totalSegmentCount;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>C++로만 만들던 게임서버를 C#으로 만든다고 했을 때 가장 신경쓰였던 것이 메모리 부분이었다. 초기구현과 서비스를 거치면서 메모리 누수, 관리힙 사이즈 증가등 많은 메모리 문제를 겪었다. 그 중에서 가장 크게 문제를 겪었던 단편화에 대해 정리해 보았다.<br>우리가 겪었던 메모리 단편화 가장 주된 요인은 네트워크 IO용 바이트 버퍼의 pinning 때문이었다. 적당한 수준의 부하로는 별 문제 없는데.. 부하를 세게 걸면 점유 메모리가 계속 증가하고 가라않질 않았다. 이건 C++도 마찬가지지만 외형적으로만 관측하면 메모리 누수처럼 보이기 때문에, 단편화가 원인일 것이라는 의심을 하기까지도 많은 검증의 시간이 필요했다.</p><p><code>SOH</code>에서는 pinning되는 메모리가 많으면 GC 능력이 많이 저하되고 단편화가 심각해진다. 네트워크 버퍼로 사용할 객체들을 <code>LOH</code>에 할당하면 이런 문제를 해결할 수 있다.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="https://prodotnetmemory.com/data/netmemoryposter.pdf">https://prodotnetmemory.com/data/netmemoryposter.pdf</a></li><li><a href="https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation">https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation</a></li><li><a href="https://tooslowexception.com/pinned-object-heap-in-net-5/">https://tooslowexception.com/pinned-object-heap-in-net-5/</a></li><li><a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.arraypool-1?view=net-5.0">https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.arraypool-1?view=net-5.0</a></li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.0">https://docs.microsoft.com/en-us/aspnet/core/performance/memory?view=aspnetcore-3.0</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance#Pinned">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance#Pinned</a></li><li><a href="https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation">https://ayende.com/blog/181761-C/the-curse-of-memory-fragmentation</a></li><li><a href="https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream">https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/ArrayPool/">ArrayPool</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Memory/">Memory</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Fragmentation/">Fragmentation</category>
      
      
      <comments>http://leafbird.github.io/devnote/2021/08/08/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - Thread Local Storage</title>
      <link>http://leafbird.github.io/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/</link>
      <guid>http://leafbird.github.io/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/</guid>
      <pubDate>Fri, 01 Jan 2021 07:00:49 GMT</pubDate>
      
      <description>&lt;p&gt;프로그래밍에서 각 스레드별로 고유한 상태를 설정할 수 있는 공간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread-local_storage&quot;&gt;Thread Local Storage&lt;/a&gt; (이하 TLS. transport layer security 아님) 라고 한다. VC++에서는 &lt;code&gt;__declspec(thread)&lt;/code&gt; 키워드를 이용해서 tls 변수를 선언할 수 있다. &lt;/p&gt;
&lt;p&gt;C#에도 &lt;code&gt;ThreadLocal&amp;lt;T&amp;gt;&lt;/code&gt; 라는 클래스를 이용해 tls를 사용할 수 있지만, 막상 실제로 사용해보면 C++에서는 존재하지 않았던 큰 차이점이 있다. C# 5.0부터 들어온 async &amp;#x2F; await 문법을 이용해 비동기 프로그래밍을 구현했다면, await 대기 시점 이전과 이후에 스레드가 달라지기 때문이다. &lt;/p&gt;
&lt;p&gt;이를 해결하는 방법과 주의해야 할 사항을 정리해본다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>프로그래밍에서 각 스레드별로 고유한 상태를 설정할 수 있는 공간을 <a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread Local Storage</a> (이하 TLS. transport layer security 아님) 라고 한다. VC++에서는 <code>__declspec(thread)</code> 키워드를 이용해서 tls 변수를 선언할 수 있다. </p><p>C#에도 <code>ThreadLocal&lt;T&gt;</code> 라는 클래스를 이용해 tls를 사용할 수 있지만, 막상 실제로 사용해보면 C++에서는 존재하지 않았던 큰 차이점이 있다. C# 5.0부터 들어온 async &#x2F; await 문법을 이용해 비동기 프로그래밍을 구현했다면, await 대기 시점 이전과 이후에 스레드가 달라지기 때문이다. </p><p>이를 해결하는 방법과 주의해야 할 사항을 정리해본다. </p><span id="more"></span><blockquote><p>알림 : 이 글을 처음 포스팅한 후 받은 피드백을 통해 보다 명확한 원인과 해결방법을 추가 확인하게 되어 내용을 수정&#x2F;보완 했습니다. 최초 버전의 글도 유지하려 했으나 글의 문맥이 복잡해지고 읽기가 어려워져 최종 버전만 남겼습니다.</p><p>수정한 내용 요약 : 새로 깨어난 스레드인데도 <code>AsyncLocal&lt;T&gt;</code>에 값이 남아있던 이유는, 기존의 값이 지워지지 않았기 때문이 아니라, 네트워크 이벤트 콜백으로 깨어난 스레드에도 <code>AsyncLocal&lt;T&gt;</code>의 값을 복사하고 있었기 때문이었습니다.</p></blockquote><h2 id="async-await-을-절대-가볍게-접근하면-안된다"><a href="#async-await-을-절대-가볍게-접근하면-안된다" class="headerlink" title="async &#x2F; await 을 절대 가볍게 접근하면 안된다"></a>async &#x2F; await 을 절대 가볍게 접근하면 안된다</h2><p>주제와 약간 벗어날 수 있지만 서두에 미리 한 번 짚고 넘어갈 부분이 있다. <strong>절대로 async &#x2F; await를 이용한 비동기 프로그래밍을 만만하게 보아서는 안된다</strong>는 것이다.</p><p>나도 그랬지만 누구든지 제일 처음 비동기 메서드를 접했을 땐 이해하기 쉽고 간단한 기능이라는 첫인상을 가지게 될 것이다. 개인적으로는 비동기 메서드를 적용하고 난 후의 코드가 동기 프로그래밍과 너무 비슷해져 버리는 점이 착각을 유발하는 큰 원인이라고 생각한다 (MS: 얘는 뭐 좋게 해줘도 불만이 많네..) </p><p>이전에 DB 쿼리나 네트워크 통신같은 IO 작업에서 비동기로 받는 결과값을 처리하기 위해서는 하나의 동일한 주제(single concern)를 위한 로직임에도 불구하고 비동기 요청 이전과 이후의 코드가 분절되어야 했다. 이를테면 비동기 요청 전의 코드와 응답 후의 코드를 서로 다른 메서드로 나누어서 짜야 했다는 뜻이다. 코드의 가독성에 대해 고민을 좀 해봤던 개발자라면 람다를 써서 어떻게든 읽기 좋고 관리하기 좋도록 애써 보았을 수도 있으나, 가독성에서 정도의 차이가 있을 뿐 명백하게 존재하는 코드상의 분절을 피할 수 없었다. </p><p>비동기 메서드의 등장으로 이런 상황은 옛날 이야기가 되었다. 안간힘을 써보아도 완전하게 붙이기 힘들었던 분절된 코드들은 이제 하나의 async 함수 안에서 seamless하게 구현할 수 있게 되었다. 작성한 코드를 읽을 때에도 (신경써서 읽지 않는다면) 어디가 동기 처리이고, 어디가 비동기 처리인지도 잘 모르고 넘어갈만큼 술술 읽어내려가게 되었다. 좋게 해석하자면 어플리케이션 개발자가 좀 더 로직에만 집중 할 수 있는 환경이 되었다.</p><p>이것은 호수에 떠있는 백조와 같다. 일단 겉으로 보기에는 아주 우아하게 비동기 코드를 표현했으나, 조금만 안을 들여다보면 비동기 요청을 기준으로 발생하는 여전한 로직의 분절, 그에 따른 <strong>실행 시점 시간차 및 실행 환경상의 차이</strong> 등은 당연게도 여전히 존재하고 있기 때문이다. 이로 인한 이슈들은 동시성(concurrency)이 있는 멀티스레드 환경에서 더 잘 드러난다. MS는 실제로 프로그래머들이 하부의 복잡한 메커니즘을 잘 모르더라도 쉽고 편하게 비동기 로직을 다룰 수 있는 유토피아를 꿈꾸었을지 모르겠다. 하지만 싱글 스레드로 간단한 툴 한두개 짜는거면 몰라도… C#이란 언어로 고성능 서버를 만들겠다고 한다면, 이에 대한 충분한 이해가 없이는 런타임에서 예상못한 오작동을 피할 수 없을 것이다.</p><p>이후 글에서 언급할 내용도 비동기 함수의 실행 시점차와 관련되어 있으므로, 비동기 메서드에 대한 어느 정도의 이해가 필요하다.</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>우선 잠깐 언급했던 <code>ThreadLocal&lt;T&gt;</code> 클래스를 간단히 알아보자. 이를 이용해 일반적인 tls 변수를 선언하고 사용할 수 있다. 이보다 전부터 있었던 <code>[ThreadStatic]</code> 어트리뷰트로도 똑같이 tls를 선언할 수 있지만, 변수의 초기화 처리에서 <code>ThreadLocal&lt;T&gt;</code> 가 좀 더 매끄러운 처리를 지원한다. 일반적인 tls가 필요할 때는 좀 더 최신의 방식인 <code>ThreadLocal&lt;T&gt;</code> 를 사용하면 된다.</p><p>모든 tls 변수에 동일한 값의 복제본을 저장해 두려는 경우가 있다. 예를들어 스레드가 3개 있으면, 메모리 공간상에 각 스레드를 위한 변수 3개가 있고, 이들 모두에 같은 의미를 가지는 인스턴스를 하나씩 생성해 할당하는 경우를 말한다. <strong>서로 다른 스레드끼리 공유해야 할 자원이 있을 때, 해당 자원에 lock이 없이 접근하고 싶다면</strong> tls를 이용해 각 스레드마다 자원을 따로 만들어 각자 자기 리소스를 쓰게 하면 된다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.Math</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RandomGenerator</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> maxValue</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> PerThreadRandom.Instance.Next(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 중략    </span></span><br><span class="line">    <span class="comment">// 사용 계층에 노출할 인터페이스를 이곳에 정의. 사용자는 tls에 대해 알지 못한다.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// System.Random 객체는 멀티스레드 사용에 안전하지 않으므로 각 스레드마다 개별 생성.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PerThreadRandom</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ThreadLocal&lt;Random&gt; Random = <span class="keyword">new</span> ThreadLocal&lt;Random&gt;(() =&gt; <span class="keyword">new</span> Random());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">internal</span> <span class="keyword">static</span> Random Instance =&gt; Random.Value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이런 경우는 비동기 메서드의 실행중 스레드의 교체가 발생하더라도 아무 문제가 되지 않는다. 어차피 어떤 스레드로 바뀌더라도 tls 변수가 하는 역할은 동일하기 때문이다. 0번 스레드가 불러다 쓰는 <code>Random</code> 객체가 어느순간 2번 스레드의 <code>Random</code> 객체로 바뀐다 해도 동작에 큰 영향이 없다. </p><h2 id="AsyncLocal"><a href="#AsyncLocal" class="headerlink" title="AsyncLocal"></a>AsyncLocal</h2><p>문제는 스레드별로 tls의 상태가 서로 달라야 할 때 발생한다. 0번 스레드에는 tls에 “철수”가, 2번 스레드에는 “영희”가 적혀있어야 하고, 이를 사용해 스레드마다 다른 동작을 해야 하는 경우. 그런데 거기다 async&#x2F;await를 이용한 비동기 프로그래밍을 함께 사용한 경우. 0번 철수 스레드가 코드 수행 도중 await 구문을 만나 task의 완료를 기다리고 있었지만, 대기가 풀렸을 때는 2번 스레드로 갈아타게 되면서 철수가 영희가 되버리는 경우다.</p><img src="/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/00.png" class=""><p>스레드별로 서로 다른 상태값을 사용해야 하는 예를 구승모 교수님의 <a href="https://github.com/zeliard/Dispatcher">Dispatcher</a> 구현에서 찾아볼 수 있다. (<a href="https://github.com/zeliard/Dispatcher/blob/master/JobDispatcher/ThreadLocal.h">ThreadLocal.h</a>) Dispatcher는 고성능 멀티스레드 로직 수행을 위한 Actor 패턴 구현체다. 스레드에 lock을 걸지 않으면서도 서로 다른 스레드간 간섭 없이 순차실행을 가능하게 하기 위해, 스레드는 현재 자신의 수행상태 일부를 tls에 기록해 두어야 한다. </p><p>친절한 ms 형들이 이런 경우를 위해 <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.asynclocal-1?view=net-5.0">AsyncLocal</a> 클래스도 미리 만들어 두었다. 생긴것도 서로 비슷해서  <code>ThreadLocal&lt;T&gt;</code> 를 사용했던 변수에 대신 <code>AsyncLocal&lt;T&gt;</code> 로 바꿔주면 위에서 말한 문제를 해결할 수 있다. 0번 스레드가 먼저 코드를 수행하다가 await 구문을 만나서 대기하고, 대기가 풀려날 때 2번 스레드로 변경이 되었더라도 <code>AsyncLocal&lt;T&gt;</code> 가 2번 스레드의 tls 값을 알아서 “영희” -&gt; “철수”로 바꿔주는 것이다. </p><img src="/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/02.png" class=""><h2 id="문제점-의도치-않게-값의-복사-발생"><a href="#문제점-의도치-않게-값의-복사-발생" class="headerlink" title="문제점 : 의도치 않게 값의 복사 발생"></a>문제점 : 의도치 않게 값의 복사 발생</h2><p>이러면 문제는 해결된 것 같지만, 또 다른 문제가 있다. 여기가 이 글의 핵심이다 집중해주기 바란다. <code>AsyncLocal&lt;T&gt;</code>는 <strong>ThreadPool이 다른 새 스레드를 추가로 깨우게 하는 특정 api들 중에 하나를 호출하는 경우, 기본적으로 호출자 스레드의 변수값을 새로운 스레드에게 복사해주는 기본 동작을 갖고 있다.</strong> 현재 스레드에서만 고유하게 유지하려고 기록해 둔 tls의 변수들이 요주의 api중 하나를 호출하는 순간 새로운 다른 스레드로 복사되는 것이다. 현재 우리 프로젝트 구현의 범위 기준에서, AsyncLocal의 값을 복사시키는 메서드들은 아래와 같다.</p><ol><li><p>Fire-and-forgot 으로 동작할 백그라운드 작업이 필요해서 직접 ThreadPool에 요청하는 메서드들 </p><ul><li>Task.Run()</li><li>ThreadPool.QueueUserWorkItem()</li></ul></li><li><p>비동기 소켓의 IO 완료통지를 포함해, 네트워크 이벤트 콜백을 유발하는 메서드들</p><ul><li>Socket.ConnectAsync() - ConnectEx() in win32</li><li>Socket.DisconnectAsync() - DisconnectEx() in win32</li><li>Socket.AcceptAsync() - AcceptEx() in win32</li><li>Socket.ReceiveAsync() - WSARecv() in win32</li><li>Socket.SendAsync() - WSASend() in win32</li></ul></li></ol><p>1번 백그라운드 작업 요청 메서드들은 스레드풀을 대상으로 하는 동작이니까 어느 정도 이해가 된다고 하지만, 2번 네트워크 콜백들은 tls를 복사한다는 점이 선뜻 연결이 잘 되지 않는다. managed 메서드의 이름이 낮설어 보일까 싶어 win32에 해당하는 함수명도 같이 적었는데, 그냥 OVERLAPPED 구조체를 이용해 IOCP에 통지를 요청하는 네트워크 api들 전체를 말한다. </p><p>0번 스레드가 게임 로직을 열심히 수행하다가 클라이언트로 동기화 패킷을 보낼 상황이 되었다. 그래서 패킷을 만들어 소켓에 SendAsync()를 한 번 걸어놓고, 다시 또 다른 로직을 열심히 수행한다. 근데 0번 스레드가 걸었던 send 요청이 완료되어 새롭게 2번 스레드가 OnSendCompleted 메서드를 실행하려고 깨어났는데, 이 때 0번 스레드가 <code>AsyncLocal&lt;T&gt;</code>에 저장해두었던 tls 값들을 2번 스레드가 고대로 복사받아서 수행을 시작하는 것이다.</p><p><code>AsyncLocal&lt;T&gt;</code>는 자신의 존재 목적과 취지에 충실하고자, 서로 다른 스레드들간에 조금이라도 관련이 있을라 치면 아주 얄짤없이 값을 복사해대는 것 같다. 하지만 win32에서 iocp에 비동기 작업의 완료 통지를 요청하고, 전혀 관련없는 다른 스레드로부터 이를 받아 처리해오던 고전적 처리방식에 익숙해서 그런지 이런 과도한 친절이 부담스럽다. 너 때문에 Dispatcher 동작이 다 깨지잖아. 조치가 필요하다.</p><h2 id="원치-않는-AsyncLocal-복사는-꺼준다"><a href="#원치-않는-AsyncLocal-복사는-꺼준다" class="headerlink" title="원치 않는 AsyncLocal 복사는 꺼준다."></a>원치 않는 AsyncLocal 복사는 꺼준다.</h2><p>다행히 이 동작은 ExecutionContext.SuppressFlow &#x2F; RestoreFlow 라는 메서드가 있어 쉽게 제어가 가능하다. 우선 스레드풀에 백그라운드 작업을 요청할 때는 <code>SuppressFlow()</code> 호출이 묶여있는 별도의 인터페이스를 만들고 이를 사용하게 한다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BackgroundJob</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">Action action</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> control = ExecutionContext.SuppressFlow();</span><br><span class="line">    ThreadPool.QueueUserWorkItem(_ =&gt; action());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 백그라운드 작업이 필요할 때. Wrapping한 인터페이스를 사용한다. </span></span><br><span class="line">    BackgroundJob.Execute(() =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">$&quot;a + b = <span class="subst">&#123;a+b&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>작업 요청 후에는 <code>RestoreFlow</code> 를 불러 복구해주면 되는데, <code>SuppressFlow</code> 메서드가 IDisposable인  <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.asyncflowcontrol?view=net-5.0">AsyncFlowControl</a> 객체를 반환하니까 예시처럼 using을 쓰면 좀 더 심플하게 처리할 수 있다.</p><p>네트워크 구현부에도 수정이 필요하다. <code>SocketAsyncEventArgs</code> 객체를 사용해 비동기 요청을 수행하는 모든 곳에도 <code>RestoreFlow</code> 를 불러준다. (<code>SocketAsyncEventArgs</code>는 win32의 <code>OVERLAPPED</code> 구조체를 거의 그대로 랩핑해둔 클래스다.) 예시로 하나만 옮겨보면 아래처럼 된다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ConnectionBase</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectAsync</span>(<span class="params">IPAddress ip, <span class="built_in">int</span> port</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">args</span> = <span class="keyword">new</span> SocketAsyncEventArgs();</span><br><span class="line">    <span class="keyword">args</span>.Completed += <span class="keyword">this</span>.OnConnectCompleted; <span class="comment">// 이 메서드가 새로운 스레드에서 불리게 될 것이다.</span></span><br><span class="line">    <span class="keyword">args</span>.RemoteEndPoint = <span class="keyword">new</span> IPEndPoint(ip, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> control = ExecutionContext.SuppressFlow(); <span class="comment">// 이걸 넣어주어야 콜백 스레드로 AsyncLocal을 복사하지 않는다.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.socket.ConnectAsync(<span class="keyword">args</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.OnConnectCompleted(<span class="keyword">this</span>.socket, <span class="keyword">args</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 SendAsync, RecvAsync 등도 다 막아주어야 일반적인 iocp 콜백 사용 방식과 동일해진다. 다른 코드상에서 아무데도 <code>AsyncLocal&lt;T&gt;</code>을 사용중이지 않다면 굳이 SuppressFlow 호출이 없어도 동작에는 문제가 없다. 그래도 어차피 사용하지도 않을 암묵적인 실행 컨텍스트간 연결 동작은 그냥 끊어두는 것이 성능상 조금이라도 이득일 듯한 기분이 든다. </p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>C#의 비동기 메서드는 코드상으로는 매끈하게 이어져 있는듯 보이지만 실은 비동기 요청 지점을 전후로 분리 실행되며, 실행 스레드가 서로 다를 수도 있다.</li><li>이로 인해 <code>ThreadLocal&lt;T&gt;</code> 로는 비대칭적(asymmetric)인 tls 데이터를 다루기가 어렵기 때문에 <code>AsyncLocal&lt;T&gt;</code>라는 클래스가 별도로 존재한다.</li><li><code>AsyncLocal&lt;T&gt;</code>는 스레드풀에서 새로운 다른 스레드를 깨어나게 할 때도 값을 복사시킨다. 이는 <code>ExecutionContext.SuppressFlow()</code> 로 제어가 가능하다.</li></ul><p>현재 사용중인 게임서버의 스레드 모델도 승모님의 JobDispatcher와 유사한 Actor 기반 구조를 채택해서 락 없이 구현하고 있다. 지금 서버 구현 기준에서 값이 복사되는 tls 변수가 문제를 일으키는 케이스는 액터를 구현하기 위한 로직 한 군데 뿐이다. 일반적으로 게임 서버를 구현할 때 스레드별로 비대칭적인(asymmetric) tls 변수를 유지해야 하는 경우가 흔치는 않을 것이다. 액터 패턴을 구현한다고 해서 tls 변수가 반드시 필수적인 것도 아니다. 이전 프로젝트에서 tls를 사용하지 않는 액터 구현도 사용해본 적이 있기 때문이다.</p><p>하지만 고성능 서버를 목표로 스레드 효율성을 튜닝한다면 반드시 사용을 염두에 두게 되는 도구가 TLS이므로, 본 글에서 언급한 내용을 숙지하고 있으면 성능 튜닝에서 많은 삽질을 세이브 하게 될것이다.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Thread/">Thread</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/AsyncLocal/">AsyncLocal</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/TLS/">TLS</category>
      
      
      <comments>http://leafbird.github.io/devnote/2021/01/01/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-Thread-Local-Storage/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - System.IO.Pipeline 도입 후기</title>
      <link>http://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/</guid>
      <pubDate>Sun, 27 Dec 2020 08:34:58 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/00.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;2018년에 네트워크 레이어 성능을 끌어올리기 위해 도입했던 System.IO.Pipeline을 간단히 소개하고, 도입 후기를 적어본다. &lt;/p&gt;
&lt;p&gt;윈도우 OS에서 고성능을 내기 위한 소켓 프로그래밍을 할 때 IOCP 의 사용은 오래도록 변하지 않는 정답의 자리를 유지하고 있다. 여기에서 좀 더 성능에 욕심을 내고자 한다면 Windows Server 2012부터 등장한 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh997032(v=ws.11)&quot;&gt;Registerd IO&lt;/a&gt; 라는 새로운 선택지가 있다. 하지만 API가 C++ 로만 열려 있어서, C# 구현에서는 사용하기가 쉽지 않다. &lt;/p&gt;
&lt;p&gt;하지만 C#에도 고성능 IO를 위한 새로운 API가 추가되었다. &lt;a href=&quot;https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines&quot;&gt;Pipeline&lt;/a&gt; 이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/00.jpg" class=""><p>2018년에 네트워크 레이어 성능을 끌어올리기 위해 도입했던 System.IO.Pipeline을 간단히 소개하고, 도입 후기를 적어본다. </p><p>윈도우 OS에서 고성능을 내기 위한 소켓 프로그래밍을 할 때 IOCP 의 사용은 오래도록 변하지 않는 정답의 자리를 유지하고 있다. 여기에서 좀 더 성능에 욕심을 내고자 한다면 Windows Server 2012부터 등장한 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh997032(v=ws.11)">Registerd IO</a> 라는 새로운 선택지가 있다. 하지만 API가 C++ 로만 열려 있어서, C# 구현에서는 사용하기가 쉽지 않다. </p><p>하지만 C#에도 고성능 IO를 위한 새로운 API가 추가되었다. <a href="https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines">Pipeline</a> 이다.</p><span id="more"></span><h2 id="System-IO-Pipeline-소개"><a href="#System-IO-Pipeline-소개" class="headerlink" title="System.IO.Pipeline 소개."></a>System.IO.Pipeline 소개.</h2><p>pipeline을 처음 들었을 때는 IOCP의 뒤를 잇는 새로운 소켓 API인줄 알았다. C++의 RIO가 iocp를 완전히 대체할 수 있는 것처럼.</p><p>RIO는 가장 핵심 요소인 <code>등록된 버퍼(registered buffer)</code> 외에, IO 요청 및 완료 통지 방식도 함께 제공하기 때문에 iocp를 완전히 드러내고 대신 사용할 수 있다. 반면 Pipeline은 RIO보다는 커버하는 범위가 좁아서, IOCP를 완전히 대체하는 물건이 될 수는 없다. 이벤트 통지는 기존의 방법들을 이용하면서, 메모리 버퍼의 운용만을 담당하는 라이브러리 이기 때문에 IOCP와 반드시 함께 사용해야 한다.</p><p>Pipeline이라는 이름을 굉장히 잘 지었다. 이름처럼 <strong>메모리 버퍼를 끝없이 연결된 긴 파이프라인처럼 쓸 수 있게 해주는 라이브러리</strong> 이기 때문이다. 단위길이 만큼의 버퍼를 계속 이어붙여서 무한하게 이어진 가상의 버퍼를 만드는데, 이걸 너네가 만들면 시간도 오래 걸리고 버그도 넘나 많을테니 우리가 미리 만들었어. 그냥 가져다 쓰렴. 하고 내놓은 것이 Pipeline이다.</p><img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/01.png" class=""><p>(이미지 출처 : <a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">devblogs.microsoft.com</a>)</p><p>이미지의 초록색 부분은 <code>class Pipe</code> 의 내부 구조를 도식화한다. 일정한 크기의 작은 버퍼들이 링크드 리스트로 연결 되어있다. 내부 구조는 안에 숨겨져있고 외부로는 <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.buffers.readonlysequence-1?view=net-5.0">ReadOnlySequence<T></a> 타입을 이용해 버퍼간 이음매가 드러나지 않는 seamless한 인터페이스만을 제공한다. 이것이 Pipeline의 핵심이다.</p><p>이 외의 디테일한 부분은 Pipeline을 이해하기 쉽게 잘 설명한 <a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">MS 블로그의 포스팅</a>이 있어 이것으로 대신한다.</p><h2 id="장점-불필요한-메모리-복사를-없앤다"><a href="#장점-불필요한-메모리-복사를-없앤다" class="headerlink" title="장점 : 불필요한 메모리 복사를 없앤다."></a>장점 : 불필요한 메모리 복사를 없앤다.</h2><p>고성능 소켓 IO 구현에 관심이 있는 C++ 프로그래머라면 google protobuf의 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.zero_copy_stream">ZeroCopyStream</a> 을 이미 접해봤을지 모른다. 그렇다면 Pipeline의 중요한 장점을 쉽게 이해할 것이다. Pipeline의 버퍼 운용 아이디어는 프로토콜 버퍼의 ZeroCopyStream과 유사하기 때문이다. 소켓으로 데이터를 주고 받는 과정에서 발생하는 불필요한 버퍼간 메모리 복사를 최소한으로 줄여주어 성능향상을 꾀한다는 점에서 두 라이브러리가 추구하는 방향은 동일하다. </p><p>프로그래밍에 미숙한 개발자가 만든 서버일수록 버퍼간 복사 발생이 빈번하게 발생한다. 커널모드 아래에서 일어나는 소켓버퍼와 NIC 버퍼간의 복사까지는 일단 관두더라도, 최소한 유저모드 위에서의 불필요한 버퍼 복사는 없어야 한다. </p><p> 전송할 데이터 타입을 버퍼로 직렬화 하면서 한 번 복사하고, 이걸 소켓에다가 send 요청을 하자니 OVERLAPPED에 연결된 버퍼에다가 넣어줘야 해서 추가로 또 복사하고… send 완료 통지 받고 나면 transferred bytes 뒤에 줄서있을 미전송 데이터들을 다시 앞으로 당겨주느라 또 한번 복사가 발생하기 쉽다. recv 받은 뒤에도 메시지 단위 하나 분량 만큼만 읽어 fetching하고 나면 뒤에 남은 데이터들을 버퍼 맨 앞으로 당겨와야겠으니… 여기서 또 한 번 추가복사 하게 될것이다.</p><p>서버가 감당할 통신량이 많아질수록 불필요한 복사들이 누적되어 쓸데없이 cpu power를 낭비하게 될텐데, Pipeline의 도입은 이런 부분을 쉽게 해결해 준다. msdn 블로그에서는 Pipeline을 사용하면 복잡한 버퍼 운용 구현을 대신 해결해주니까 프로그래머가 비즈니스 로직의 구현에 좀 더 집중할 수 있게 도와준다고 <del>약을 팔고</del> 설명하고 있다.</p><h2 id="장점-네트워크-버퍼의-고정길이-제약을-없애준다"><a href="#장점-네트워크-버퍼의-고정길이-제약을-없애준다" class="headerlink" title="장점 : 네트워크 버퍼의 고정길이 제약을 없애준다."></a>장점 : 네트워크 버퍼의 고정길이 제약을 없애준다.</h2><p>가장 단순하게 소켓 레이어를 구현하면 송&#x2F;수신용 고정 사이즈 <code>byte[]</code> 버퍼를 각각 하나씩 붙여서 만들게 될 것이다. 대략 구현중인 게임이 어느 정도 사이즈의 패킷을 주고 받는지를 <strong>귀납적</strong>으로 파악해서 (주로 게임 서버는 작은 사이즈 패킷을 많이 받고, 큰 사이즈 패킷을 많이 보낸다. 로그인할때, 캐릭터 선택할 때 보내는 패킷이 통상 제일 크다) 버퍼의 크기를 눈치껏 결정해서 <code>상수로 고정한다</code>. 버퍼를 거거익선으로 크게크게 잡으면 좋겠지만 대량의 동접을 처리해야 할때 메모리 사용량이 높아져서 부담이 된다. 그러니 적당히 오가는 패킷 사이즈를 봐서 터지지만 않을 정도의 고정길이 버퍼를 걸어두는 식으로 만들게 된다.</p><p>이렇게 만들면 불안하다. 컨텐츠를 점점 추가하다가 언젠가 한 두번은 네트워크 버퍼 overflow가 발생해 버퍼 크기를 늘려잡고 다시 빌드해야 하기 일쑤다. 아니면 버퍼를 넘치게 만든 문제 패킷의 구조를 변경하거나 두 개의 패킷으로 쪼개는 등 다이어트를 시켜서 해결할 수도 있겠다. 어느쪽이든 고성능 서버의 네트워크 레이어 구현으로는 적당하지 않은 솔루션이다. 메모리를 더 써서 해결하거나, 개발에 제약(패킷의 최대 크기)을 두어 해결하거나. 모두 석연치 않다.</p><p>Pipeline과 ZeroCopyStream 의 무한버퍼 컨셉은 이러한 고정길이 버퍼의 단점을 해결해준다. 처음엔 작은 크기의 버퍼만 가지고 있다가, 공간이 모자라면 추가로 더 할당받아 링크드 리스트 뒤에 붙이기만 하면 된다. 각각의 peer(&#x3D; single socket)가 실제 사용하는 메모리 공간은 주고받는 데이터의 크기에 따라서 늘어나거나 줄어드는 유연성이 생긴다. 메모리를 효율적으로 사용하면서도 단일 메시지의 사이즈 제약도 없어진다.</p><h2 id="단점-너무-많은-Task를-생성한다"><a href="#단점-너무-많은-Task를-생성한다" class="headerlink" title="단점 : 너무 많은 Task를 생성한다."></a>단점 : 너무 많은 Task를 생성한다.</h2><p>위의 두가지 장점만으로 Pipeline의 도입을 시도해볼 가치는 충분했다. 그래서 우리는 게임서버의 수신 버퍼를 Pipeline으로 대체하고, MS Azure 에서 F8s 급 인스턴스 수십대를 동원해 10만 동접 스트레스 테스트를 진행해 보았다. </p><p>결과는 기대와 완전히 달랐는데.. <strong>Pipeline 도입 전보다 영 더 못한 성능을 보여줬다</strong>. 이건 뭐… cpu 사용량이 높고 낮아지는 것이 문제가 아니라, 동접이 일정수치 이상 오르면 서버가 아무 일도 처리하지 않고 멈춰버렸다. 반응없는 프로세스에서 덤프를 떠서 디버거로 살펴보면… 대기상태인 스레드가 잔뜩 생겨있고, 일해야 할 스레드가 부족해서 추가 스레드를 계속해서 만들어내고 있는 것처럼 보였다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msdn 블로그에 소개된 코드 일부 발췌. Pipe를 하나 만들면 읽기/쓰기 Task를 2개 만든다.</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">ProcessLinesAsync</span>(<span class="params">Socket socket</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pipe = <span class="keyword">new</span> Pipe();</span><br><span class="line">    Task writing = FillPipeAsync(socket, pipe.Writer);</span><br><span class="line">    Task reading = ReadPipeAsync(pipe.Reader);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Task.WhenAll(reading, writing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원인은 Pipeline과 함께 사용하는 task (System.Threading.Tasks.Task) 들이었다.  <code>class Pipe</code> 인스턴스 하나를 쓸 때마다 파이프라인에 ‘읽기’와 ‘쓰기’를 담당하는 <code>class Task</code> 객체 두 개를 사용하게 된다. 수신버퍼에만 Pipe를 달면 소켓의 2배, 송수신 버퍼에 모두 달면 소켓의 4배수 만큼의 task가 생성 되어야 하기 때문이다. 게임서버 프로세스당 5,000 명의 동접을 받는다고 하면 최대 20,000개의 task가 생성되고, 이 중 상당수는 waiting 상태로 IO 이벤트를 기다리게 된다.</p><p>task가 아무리 가볍다고 해도 네트워크 레이어에만 몇 만개의 task를 만드는 것은 그리 효율적이지 않다. TPL에 대한 이야기를 시작하면 해야 할 말이 아주 많기 때문에 별도의 포스팅으로 분리해야 할 것이다. 과감히 한 줄로 정리해보면, task는 상대적으로 OS의 커널오브젝트인 스레드보다 가볍다는 것이지 수천 수만개를 만들만큼 깃털같은 물건은 아닌 것이다.</p><p>스레드가 코드를 한 단계씩 수행하다가 아직 완료되지 않은 task를 await 하는 구문을 만나면 호출 스택을 한 단계씩 거꾸로 올라가면서 동기 로직의 수행을 재개한다. 하지만 완료되지 않은 task를 만났다고 해서 그 즉시 task의 완료 및 반환값 획득을 포기하고 호출스택을 거슬러 올라가는 것은 아니다. 혹시 금방 task가 완료되지 않을까 하는 기대감으로 조금 대기하다가 완료될 기미가 보이지 않으면 그 제서야 태세를 전환하게 된다. 이 전략은 task가 동시성을 매끄럽게 처리하기 위해서는 바람직한 모습이지만, 아주 많은 개수의 task를 장시간(게임서버에서 다음 패킷을 받을 때까지의 평균 시간) 동안 대기시켜야 하는 네트워크 모델에 사용하기에는 적합하지 않다. 스레드들은 각 pipeline의 write task가 RecvComplete 통지를 받고 깨어나기를 기다리면서 수십만 cpu clock을 낭비하게 된다.</p><h2 id="의문-Kestrel은-Pipeline-때문에-엄청-빨라졌는데"><a href="#의문-Kestrel은-Pipeline-때문에-엄청-빨라졌는데" class="headerlink" title="의문 : Kestrel은 Pipeline 때문에 엄청 빨라졌는데?"></a>의문 : Kestrel은 Pipeline 때문에 엄청 빨라졌는데?</h2><img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/02.png" class=""><p>(이미지 출처 : <a href="https://stackoverflow.com/questions/34440649/iis-vs-kestrel-performance-comparison">stackoverflow.com</a>)</p><p>ASP.NET Core는 Pipeline으로 구현한 kestrel 웹서버에서 실행할 때 기존의 iis 기반보다 훨씬 더 향상된 퍼포먼스를 보여준다. Pipeline의 버퍼 운용 효율성으로 인한 이득을 제대로 누리고 있는 것이다. kestrel의 뛰어난 성능 결과를 보여주는 여러 벤치마크 결과들 덕분에 나도 기대를 가득 안고 서둘러 Pipeline을 도입하고 테스트 해보았으나.. 결과는 좋지 않았다.</p><p>그럼 우리 게임서버에 도입한 테스트 결과는 왜 이리 처참한 것인가? ms 형들이 잘못 만들었을 리는 없으니 내가 가져다 붙이는 과정에 문제가 있었던 것인가? </p><p>차이가 생기는 원인은 <strong>Kestrel은 http 통신을 하는 웹서버이고, 우리의 게임서버는 연결을 유지하고 있는 TCP 서버이기 때문</strong>이다. Kestrel은 통신량의 거의 전부가 socket이 열린 채로 길게 대기할 필요가 없기 때문에, task을 소켓의 2배수나 4배수만큼 오래도록 유지하고 있을 이유 자체가 없다. 그래서 단점으로 지적한 waiting task가 kestrel에서는 발생하지 않는다. 상술했던 단점을 다시 표현해 보자면 <strong>Pipeline의 사용시 기본적으로 task 대기가 발생하는 것을 성능 하락의 원인으로 볼 수 있지만, 이 task들의 수명 혹은 대기시간이 상당히 길다는 점과 함께 만나면 성능을 더욱 악화시키는 원인이 된다</strong>. Kestrel의 단명하는(?) 소켓들과 task들은 Pipeline와 함께 사용되면서 충분히 좋은 성능을 가져다 줄 것이다. 수많은 벤치마킹 결과들이 증명하듯이.</p><h2 id="대안-불필요한-복사가-없는-가변버퍼를-직접-만들자"><a href="#대안-불필요한-복사가-없는-가변버퍼를-직접-만들자" class="headerlink" title="대안 : 불필요한 복사가 없는 가변버퍼를 직접 만들자."></a>대안 : 불필요한 복사가 없는 가변버퍼를 직접 만들자.</h2><p>우리는 게임서버에서 Pipeline을 다시 드러냈다. http와 유사하게 single pair request&#x2F;response 통신 후 소켓을 닫아도 되는 경우가 아니면 Pipeline으로 성능상의 혜택을 보기는 힘들다고 판단했기 때문이다. 그래도 불필요한 메모리복사는 만들고 싶지 않으니 메모리 버퍼 운용하는 부분만 직접 구현해 사용하기로 했다.</p><img src="/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/03.png" class=""><p>클래스 이름이 Pipeline과 protobuf를 모두 가져다 섞어놓은 느낌이 들겠지만 착각일 뿐이다. 두 api를 모두 사용해본 경험의 영향을 받긴 했지만… *Stream.cs 클래스들은 실제로 <code>System.IO.Stream</code>을 상속받아서 이름이 좀 비슷해졌다. 이 Stream 구현들이 단위버퍼들간의 연결을 seamless하게 쓸 수 있게해주는 역할을 한다. 주요 구현을 담고 있으나 사용계층에 노출될 필요는 없기 때문에 Detail 아래로 숨겨두었다. 사용자는 부모타입인 Stream 추상 클래스만 보게 된다.</p><p>인터페이스로 <code>ReadOnlySequence&lt;T&gt;</code>를 사용하지 않은 이유는 이 구현을 Unity3D로 만든 클라이언트에서도 똑같이 사용하기 위해서였다. 현시점 유니티의 mono framework가 지원하는 C# 문법 버전이 낮아서 <code>ReadOnlySequence&lt;T&gt;</code>를 지원하지 않기 때문이다. 그런데 Stream 을 이용해도 어렵지 않게 seamless 를 구현할 수 있었고, 실제 사용하기에도 스트림 형태가 훨씬 익숙하고 편해서 결과적으로는 더 만족스러운 선택이었다. <code>ReadOnlySequence&lt;T&gt;</code> 가 뭔지 모르는 프로그래머도 Stream은 알고 있을 것이다.</p><p>실제 사용 계층으로 노출하는 클래스는 아래의 세 클래스 만으로 정리했다. </p><ul><li><code>MemoryPipe</code> : 소켓 수신버퍼 처리 전용. System.IO.Pipeline과 유사하다.</li><li><code>SendBuffer</code> : 소켓 송신버퍼 처리 전용. </li><li><code>ZeroCopyBuffer</code> : 네트워크 버퍼가 아닌 범용적인 용도의 인터페이스.</li></ul><p>패킷을 보낼때는 데이터 타입을 버퍼로 직렬화 한 후, 이 버퍼를 메모리 복사 없이 소켓에 그대로 연결해주기 위한 추가 처리가 있어야 하는데, 이건 송신 버퍼에만 필요한 동작이라서 클래스를 별도로 나누었다. 각 용도에 특화된 메서드가 추가 구현 되어있을 뿐 코어는 모두 비슷하다. 모두 단위 버퍼를 줄줄이 비엔나처럼 연결해 들고 있는 역할을 한다.</p><p>이들 중에 가장 기본이 되는 ZeroCopyBuffer 를 조금 보면 아래와 같다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Cs.ServerEngine.Network.Buffer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ZeroCopyBuffer</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Queue&lt;LohSegment&gt; segments = <span class="keyword">new</span> Queue&lt;LohSegment&gt;();</span><br><span class="line">    <span class="keyword">private</span> LohSegment last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SegmentCount =&gt; <span class="keyword">this</span>.segments.Count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CalcTotalSize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> data <span class="keyword">in</span> <span class="keyword">this</span>.segments)</span><br><span class="line">      &#123;</span><br><span class="line">        result += data.DataSize;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryWriter <span class="title">GetWriter</span>()</span> =&gt; <span class="keyword">new</span> BinaryWriter(<span class="keyword">new</span> ZeroCopyOutputStream(<span class="keyword">this</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryReader <span class="title">GetReader</span>()</span> =&gt; <span class="keyword">new</span> BinaryReader(<span class="keyword">new</span> ZeroCopyInputStream(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params"><span class="built_in">byte</span>[] buffer, <span class="built_in">int</span> offset, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.last == <span class="literal">null</span> || <span class="keyword">this</span>.last.IsFull)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">this</span>.last = LohSegment.Create(LohPool.SegmentSize.Size4k);</span><br><span class="line">          <span class="keyword">this</span>.segments.Enqueue(<span class="keyword">this</span>.last);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> copied = <span class="keyword">this</span>.last.AddData(buffer, offset, count);</span><br><span class="line"></span><br><span class="line">        offset += copied;</span><br><span class="line">        count -= copied;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> LohSegment[] <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="keyword">this</span>.segments.ToArray();</span><br><span class="line">      <span class="keyword">this</span>.segments.Clear();</span><br><span class="line">      <span class="keyword">this</span>.last = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> LohSegment <span class="title">Peek</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.segments.Peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">PopHeadSegment</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> segment = <span class="keyword">this</span>.segments.Dequeue();</span><br><span class="line">      segment.ToRecycleBin();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.segments.Count == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>본 주제와 관련한 인터페이스만 몇 개 간추려 보았다. <code>Queue&lt;LogSegment&gt;</code> 가 Pipeline 안에 있는 단위버퍼의 링크드 리스트 역할을 한다. Write()와 Move()는 메모리 복사 없이 데이터를 쓰는 인터페이스가 되고, Peek(), PopHeadSegment()는 데이터를 읽는 인터페이스가 되는데, internal 접근자니까 실제 사용계층에는 노출하지 않는다. Detail 하위의 *Stream 클래스를 위한 메서드들이다.</p><p>조각난 버퍼를 하나의 가상버퍼처럼 추상화해주는 로직은 *Stream들이 담고있다. System.IO.Stream을 상속했기 때문에 사용 계층에서는 보통의 파일스트림, 메모리 스트림을 다루던 방식과 똑같이 값을 읽고 쓰면 된다. 사용한 segment들을 새지 않게 잘 pooling하고, 버퍼 오프셋 계산할때 오차없이 더하기 빼기 잘해주는 코드가 전부인지라 굳이 옮겨붙이지는 않는다. </p><p>이렇게 하니 <code>ZeroCopyBuffer</code>는 가상의 무한 버퍼 역할을 하고, 사용 계층에는 Stream 형식의 인터페이스를 제공하는 <code>System.IO.Pipeline</code>의 유사품이 되었다. 제공되는 메서드 중에는 <code>async method</code> 가 하나도 없으니 cpu clock을 불필요하게 낭비할 일도 없다. 이렇게 디자인 하는것이 기존의 iocp 기반 소켓 구현에 익숙한 프로그래머에겐 더 친숙한 모델이면서, 성능상으로도 Pipeline보다 훨씬 낫고(tcp 기반 게임서버 한정), Unity3D처럼 최신의 Memory api가 지원 안되는 환경에서도 문제없이 사용할 수 있다.</p><h2 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h2><p><code>System.IO.Pipeline</code>은 ASP.NET Core의 성능을 크게 끌어올린 네트워크 버퍼 운용 라이브러리다. 이를 적용하면 네트워크 버퍼구현의 여러가지 문제점들과 boilerplate한 구현들을 손쉽게 해결할 수 있으나, 최소 2 tasks&#x2F;peer를 소켓의 수명만큼 열어두어야 하기 때문에 소켓을 긴 시간 유지하는 타입의 TCP서버라면 도입 전에 신중한 성능 테스트를 거쳐야 한다. </p><p>사이즈가 무한인 가상의 버퍼라는 컨셉만을 가져와 직접 만들어 사용중인 <code>ZeroCopyBuffer</code> 모듈의 인터페이스도 간단하게 소개해 보았다. Unity3D 클라이언트 네트워크 모듈에도 함께 사용하기 위해 <code>ReadOnlySequence&lt;T&gt;</code> 대신 System.IO.Stream으로 추상화한 인터페이스를 제공했는데, 이렇게 하니 요구사항을 충분히 만족하면서도 사용 계층에게는 더 익숙한 형태의 인터페이스를 제공할 수 있어서 만족스러웠다.</p><p>본 포스팅에는 단위버퍼로 이용한 구현체인 <code>LohSegment</code>에 대한 소개가 없었다. 글 분량 조절에 실패하여 일부로 언급하지 않았는데, 다음에 가비지 컬렉터를 주제로 포스팅하면서 추가로 다뤄볼 예정이다. </p><p>참고:</p><ul><li><a href="https://www.slideshare.net/sm9kr/windows-registered-io-rio">https://www.slideshare.net/sm9kr/windows-registered-io-rio</a></li><li><a href="https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines">https://docs.microsoft.com/ko-kr/dotnet/standard/io/pipelines</a></li><li><a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Network/">Network</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Socket/">Socket</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/Pipeline/">Pipeline</category>
      
      
      <comments>http://leafbird.github.io/devnote/2020/12/27/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-System-IO-Pipeline-%EB%8F%84%EC%9E%85-%ED%9B%84%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 고성능 서버 - __FILE__, __LINE__ 대체제</title>
      <link>http://leafbird.github.io/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/</link>
      <guid>http://leafbird.github.io/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/</guid>
      <pubDate>Sat, 26 Dec 2020 02:11:05 GMT</pubDate>
      
      <description>&lt;p&gt;C++에서 가장 기본적으로 사용했던 &lt;code&gt;__FILE__, __LINE__, __FUNCTION__&lt;/code&gt; 등의 매크로와 유사한 효과를 내는 방법에 대해 적어본다. 이와 함께 나에게는 생소했던 string interning 개념에 대해서도 살짝 소개해본다. 자바 같은 managed 언어를 깊이 다뤄본 적이 없는 네이티브 개발자에게는 생소한 개념일 것이다.&lt;br&gt;UI가 없는 서버에서 동작의 내용을 확인하는 가장 기본적인 방법은 file로 남기는 log다. 정상 동작이나 오류상황에 대한 상세한 로그가 남아야 문제가 생겼을 때 파악하기가 쉽기 때문에, 간단한 동작이지만 아주 빈번하게 호출되는 부분이다. 로그 출력에서 성능을 많이 빼앗기지 않도록 기반을 다져놓으면 비즈니스 로직 구현을 위해 더 많은 H&amp;#x2F;W 리소스를 배분할 수 있다.&lt;/p&gt;
&lt;p&gt;성능을 굳이 신경쓰지 않는다면 아래 있는 내용을 끝까지 모두 적용할 필요는 없다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>C++에서 가장 기본적으로 사용했던 <code>__FILE__, __LINE__, __FUNCTION__</code> 등의 매크로와 유사한 효과를 내는 방법에 대해 적어본다. 이와 함께 나에게는 생소했던 string interning 개념에 대해서도 살짝 소개해본다. 자바 같은 managed 언어를 깊이 다뤄본 적이 없는 네이티브 개발자에게는 생소한 개념일 것이다.<br>UI가 없는 서버에서 동작의 내용을 확인하는 가장 기본적인 방법은 file로 남기는 log다. 정상 동작이나 오류상황에 대한 상세한 로그가 남아야 문제가 생겼을 때 파악하기가 쉽기 때문에, 간단한 동작이지만 아주 빈번하게 호출되는 부분이다. 로그 출력에서 성능을 많이 빼앗기지 않도록 기반을 다져놓으면 비즈니스 로직 구현을 위해 더 많은 H&#x2F;W 리소스를 배분할 수 있다.</p><p>성능을 굳이 신경쓰지 않는다면 아래 있는 내용을 끝까지 모두 적용할 필요는 없다. </p><span id="more"></span><h2 id="콜스택을-얻어와서-가장-마지막-함수를-찍는-방법"><a href="#콜스택을-얻어와서-가장-마지막-함수를-찍는-방법" class="headerlink" title="콜스택을 얻어와서 가장 마지막 함수를 찍는 방법"></a>콜스택을 얻어와서 가장 마지막 함수를 찍는 방법</h2><p>현재 스레드 컨텍스트에서의 <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.diagnostics.stackframe?redirectedfrom=MSDN&view=net-5.0">StackFrame</a> 정보를 얻어온 후, 프레임 데이터의 가장 마지막 부분을 읽어 호출자의 정보를 얻어낼 수 있다. C#으로 함수 호출 위치를 얻어올 때 가장 많이 쓰이는 방법이다. 가장 태초부터 있었던 방법이기 때문이다. 다음에 설명할 CompilerServices attribute는 .Net Framework 4.5부터 사용이 가능해졌기 때문에, 초창기 C#에서는 콜스택에서 읽어내는 방법 말고는 딱히 다른 선택지도 없었다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StackTrace st = <span class="keyword">new</span> StackTrace(<span class="keyword">new</span> StackFrame(<span class="literal">true</span>)); </span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot; Stack trace for current level: &#123;0&#125;&quot;</span>, st.ToString()); </span><br><span class="line"></span><br><span class="line">StackFrame sf = st.GetFrame(<span class="number">0</span>); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; File: &#123;0&#125;&quot;</span>, sf.GetFileName()); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; Method: &#123;0&#125;&quot;</span>, sf.GetMethod().Name); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; Line Number: &#123;0&#125;&quot;</span>, sf.GetFileLineNumber()); </span><br><span class="line">Console.WriteLine(<span class="string">&quot; Column Number: &#123;0&#125;&quot;</span>, sf.GetFileColumnNumber()); </span><br></pre></td></tr></table></figure><p>C#에서 흔하게 사용하는 로깅 라이브러리인 <a href="https://logging.apache.org/log4net/">Log4Net</a>, <a href="https://nlog-project.org/">NLog</a> 등에서도 이 방법을 사용한다. </p><h4 id="콜스택-기반-장점-가장-범용적이다-프레임워크-호환성이-가장-좋음"><a href="#콜스택-기반-장점-가장-범용적이다-프레임워크-호환성이-가장-좋음" class="headerlink" title="콜스택 기반 장점 : 가장 범용적이다. 프레임워크 호환성이 가장 좋음"></a>콜스택 기반 장점 : 가장 범용적이다. 프레임워크 호환성이 가장 좋음</h4><p>.Net Framework의 태초부터 있었던 방식이므로 가장 범용적이다. 오래된 버전의 닷넷 프레임워크나 mono 프레임워크 등을 지원해야 하는 상황이라면 이 방법 말고는 마땅한 대안이 없다. 그래서 Log4Net, NLog 등의 유명한 라이브러리도 이 방법을 사용하고 있다. 이들은 불특정 다수의 환경에서 실행되어야 할 범용성이 중요한 모듈이기 때문이다. </p><h4 id="콜스택-기반-단점-말해서-무엇하랴-비용이-비싸고-느리다"><a href="#콜스택-기반-단점-말해서-무엇하랴-비용이-비싸고-느리다" class="headerlink" title="콜스택 기반 단점 : 말해서 무엇하랴. 비용이 비싸고 느리다."></a>콜스택 기반 단점 : 말해서 무엇하랴. 비용이 비싸고 느리다.</h4><p>지금 회사에서 사용하는 게임서버 엔진은 처음에 Log4Net을 쓰다가, 나중에 NLog로 바꾸었다가, 현재는 자체 구현한 파일로그 모듈을 쓰고 있다. 외부 모듈로는 내가 만족하는 성능을 얻지 못했기 때문이다. </p><p>Log4Net, NLog 모두 아주 좋은 로그 모듈인 것은 분명하다. Log4Net은 apache 소프트웨어 재단의 모듈인 만큼 아주 많은 곳에서 쓰이고 있을것이다. 두 모듈 모두 설정 문서만 읽어봐도 정말 기능이 많다. 로그파일을 사이즈나 시간에 맞춰 새 파일로 나눠주는 것은 물론이고, 메일로 로그를 전송할 수도 있고, 로그 레벨 설정도 자유롭고, 파일 생성 정책도 디테일하게 조절할 수 있고… 아무튼 아주 많다. </p><p>내가 이 두 모듈을 떠나서 직접 만들어 사용하는 가장 큰 이유는 <code>성능</code> 때문이다. 나에게는 굳이 내가 사용도 하지 않을 것 같은 다수의 편의기능들보다도 딱 내가 필요한 동작만 가지고 있더라도 가볍고 빠른 로그 모듈이 필요했다. Log4Net은 오래되서 잘 기억이 나지 않지만 NLog같은 경우 모듈 자체에서 스레드도 제법 많이 만들어서 운용하는걸 디버깅하다 본 기억이 있는데, 이런 내부 구조도 고성능 엔진을 만든다는 측면에서 부담스러웠다. (고성능을 위한 File IO 전략은 이 글의 주제에서 벗어나니까 다음 기회에 별도의 포스트로 다뤄보겠다.)</p><p>범용적인 로그 모듈들은 성능 또한 일반적이다. 크게 좋지도 않고 아주 나쁘지도 않는 수준을 보여준다. NLog를 사용할 때 설정에서 파일 이름과 라인 위치를 출력하는 동작을 끈 채로 사용해도 성능에는 별반 차이가 없었는데, 아마도 파일로 출력만 하지 않을 뿐  내부에서는 동일하게 <code>StacFrame</code> 을 얻어오는 동작이 실행되고 있을거라고 추측했다. 혹은 StackFrame 때문이 아닌, 다른 많은 부수 기능들 때문일 수도 있을 텐데, 아무튼 나의 기대치에는 맞지 않았다.</p><h2 id="System-Runtime-CompilerServices"><a href="#System-Runtime-CompilerServices" class="headerlink" title="System.Runtime.CompilerServices"></a>System.Runtime.CompilerServices</h2><p>.NET Framework 4.5부터 새로운 방식으로 함수 호출자의 정보를 가져올 수 있게 되었다. 요즘 .NET 6에 대한 뉴스도 돌고 있는 현시점에서 보면 충분히 오래된 방식이다. 만들어야 하는 프로그램의 런타임을 특정 프레임워크만 사용하도록 한정할 수 있다면 이 방식을 사용하는 것을 추천한다. 게임서버는 런타임 환경을 단 하나의 프레임워크로 고정할 수 있으니, 크게 문제될 것이 없다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TraceMessage(<span class="string">&quot;Something happened.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TraceMessage</span>(<span class="params"><span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">    [CallerMemberName] <span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    [CallerFilePath] <span class="built_in">string</span> sourceFilePath = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    [CallerLineNumber] <span class="built_in">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;message: &quot;</span> + message);</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;member name: &quot;</span> + memberName);</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;source file path: &quot;</span> + sourceFilePath);</span><br><span class="line">    Trace.WriteLine(<span class="string">&quot;source line number: &quot;</span> + sourceLineNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 인자에 기본값이 있기 때문에 작업자가 함수를 호출할 때 값을 전달하지는 않지만, 그래도 보이지 않게 뒤쪽 인자를 통해 호출자의 파일명, 라인수 등이 넘어가는 방식이다. 인자에 붙어있는 attribute로 인해 함수 호출 위치에 맞는 값들이 <code>런타임에</code> 채워진다.</p><p>과거의 오래된 프레임워크를 지원할 수 없다는 점이 거꾸로 단점이 될텐데, 사실 NLog같이 누구나 어디서나 사용해야할 로그모듈을 만들게 아니고, 게임서버처럼 특정 비즈니스 프로젝트로 사용처를 한정한다면 오래된 프레임워크 미지원은 그렇게 큰 단점은 아니다. </p><h4 id="CompilerServices-장점-가볍고-빠르다"><a href="#CompilerServices-장점-가볍고-빠르다" class="headerlink" title="CompilerServices 장점 : 가볍고 빠르다."></a>CompilerServices 장점 : 가볍고 빠르다.</h4><p>위에서 언급했던 StackFramek 클래스를 사용하는 방식보다 훨씬 빠르다. C++의 <code>__FILE__, __LINE__</code> 은 매크로니까 이미 컴파일 타임에 문자열과 숫자로 치환되어 코드에 포함된다. CompilerServices 사용 방식은 런타임에 함수의 인자로 넘어가는 방식이니까 이것만큼 optimal할 수는 없지만, 콜스택을 긁어오는 것보다는 훨씬 빠르다.</p><h4 id="CompilerService-단점-가변인자-인터페이스-사용이-불가능-해진다"><a href="#CompilerService-단점-가변인자-인터페이스-사용이-불가능-해진다" class="headerlink" title="CompilerService 단점 : 가변인자 인터페이스 사용이 불가능 해진다."></a>CompilerService 단점 : 가변인자 인터페이스 사용이 불가능 해진다.</h4> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  WriteLog(<span class="string">&quot;invalid value:&#123;0&#125;&quot;</span>, <span class="keyword">value</span>); <span class="comment">// 불가능합니다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteLog</span>(<span class="params"><span class="built_in">string</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">params</span> <span class="built_in">object</span>[] list,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerFilePath] <span class="built_in">string</span> sourceFilePath = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerLineNumber] <span class="built_in">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수의 뒷부분 인자를 사용하게 되니까, 위와 같은 사용이 불가능하다. 예시처럼 formatting이 될 문자열을 처음에 받고 두번째부터 가변 인자를 받는 방법은  C++에서 로그 인터페이스를 만드는 가장 익숙한 방식이다. </p><p>하지만 C#은 나름대로의 해결법이 있다. <a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/tokens/interpolated">보간 문자열</a>을 이용해 문자열을 포매팅하면 된다. .NET Framework 4.6 과 함께 C# 문법이 6.0으로 올라갔고 이 때부터 보간 문자열이 사용 가능해졌다. 최신의 C#에서는 String.Format보다 보간 문자열의 사용이 더 권장된다. - Effective C#, 빌 와그너. Chapter 1.4 <code>string.Format()을 보간 문자열로 대체하라</code> </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoProcessing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// WriteLog(&quot;invalid value:&#123;0&#125;&quot;, value); // C++스러워 보이지만, 촌스러운 방식이예요.</span></span><br><span class="line">  WriteLog(<span class="string">$&quot;invalid value:<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>); <span class="comment">// 가능합니다. 권장됩니다. Effective C# 읽어보세요.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteLog</span>(<span class="params"><span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerFilePath] <span class="built_in">string</span> sourceFilePath = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  [CallerLineNumber] <span class="built_in">int</span> sourceLineNumber = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#이 5.0이었을 시점만 해도 이건 큰 단점이었다. 하지만 현 시점에서 이것도 그리 문제될 것이 없다.</p><h2 id="C-은-코드영역을-사용하지만-C-은-힙을-사용한다"><a href="#C-은-코드영역을-사용하지만-C-은-힙을-사용한다" class="headerlink" title="C++은 코드영역을 사용하지만, C#은 힙을 사용한다."></a>C++은 코드영역을 사용하지만, C#은 힙을 사용한다.</h2><p>좀 더 성능에 집착해보자(?).</p><p>윗부분에서 잠시 언급했듯이, C++의 <code>__FILE__, __LINE__</code> 은 컴파일 시점에 이미 실제 값으로 변환을 완료하는 preprocessing 이다. 런타임에 함수 호출자 정보를 얻기 위해 추가로 들이는 비용이 거의 없다.</p><img src="/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/00.jpg" class=""><p>(이미지 출처 : <a href="https://en.wikipedia.org/wiki/Data_segment">wikipedia</a>)</p><p>이미지에서 text로 표현된 부분이 코드영역이다. 이 공간은 고정적인 읽기 전용의 공간이다. C++의 <code>__FILE__</code> 매크로를 다르게 표현하면 결국 이 코드영역의 특정 위치를 가르키는 char*로 변환될 뿐이다. 추가적인 객체 할당은 없다.</p><p>하지만 C#은 코드영역을 사용하지 않는다. <code>[CallerFilepath] string filePath</code> 는 <strong>함수 호출이 일어날 때마다 heap 영역에 스트링 객체를 할당한다</strong>. 디버그를 위해 상세하게 로그를 달면 달 수록 heap에는 동일한 텍스트가 반복적으로 할당되어 메모리에 압력을 가하게 된다. </p><p>C#에서는 C++처럼 코드영역을 참조하는 문자열을 만드는 방법이 없다. 모든 참조형식의 객체는 heap이 아닌 공간을 사용할 수 없기 때문으로 추측이 된다. value type을 object 형식으로 가리키면 굳이 비싼 비용을 들이면서까지 heap에 추가할당을 만드는 boxing을 하는 이유와 같을 것이다. </p><p>반복적으로 사용하는 똑같은 문자열인데도, 매번 함수가 불릴 때마다 이걸 heap에 재할당을 할까? 하고 나도 처음엔 그렇게 생각했다. C++을 하면서 생긴 사고의 관성일 것이다. C#의 string은 참조 타입이고, immutable해서 한 번 할당하면 변경도 불가한 성격을 갖고 있기 때문에 충분히 착각할 만한 상황이기도 하다 - 라고 자기 합리화를 해본다.  하지만 windbg를 이용해 heap을 디버깅 하던 중 무수히 많은 파일 경로 텍스트가 중복으로 잔뜩 들어있는걸 보고 나서야 아닌 것을 깨달았다. </p><h2 id="Interned-String"><a href="#Interned-String" class="headerlink" title="Interned String"></a>Interned String</h2><p>완전하게 내용이 같은 string을 pooling하여 heap에 한 번만 할당하고 돌려쓰는 방법이 없는 것은 아니다. 이렇게 언어 자체적으로 문자열을 풀링하는 처리를 Java와 C#에서는 모두 Interning이라고 부른다. </p><ul><li>Java - <a href="https://www.javatpoint.com/java-string-intern">String Intern()</a></li><li>C# - <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.string.intern?view=net-5.0">String Intern()</a></li></ul><p>사용법은 간단하다. 풀링하고 싶은 문자열을 사용할 때 <code>string.Intern()</code> 메소드를 한 번 더 감싸주면 된다. 현재 회사에서 실제 사용중인 모듈의 인터페이스 부분만 보면 아래처럼 되어있다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Log</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Debug</span>(<span class="params"><span class="built_in">string</span> message, [CallerFilePath] <span class="built_in">string</span> <span class="keyword">file</span> = <span class="string">&quot;&quot;</span>, [CallerLineNumber] <span class="built_in">int</span> line = <span class="number">0</span></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ... 중략...</span></span><br><span class="line">    provider.Debug(<span class="string">$&quot;<span class="subst">&#123;message&#125;</span> (<span class="subst">&#123;BuildTag(<span class="keyword">file</span>, line)&#125;</span>)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">BuildTag</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">file</span>, <span class="built_in">int</span> line</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Intern(<span class="string">$&quot;<span class="subst">&#123;Path.GetFileName(<span class="keyword">file</span>)&#125;</span>:<span class="subst">&#123;line.ToString()&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전달받은 파일명을 바로 사용하지 않고 string.Intern()으로 한 번 감싸서 사용한다. 로그를 출력하면 아래처럼 찍힌다. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-12-21 12:08:02.144 [Debug] [ConnectionMonitor] add uid:1 #connection:1 (ConnectionMonitor.cs:32)</span><br><span class="line">2020-12-21 12:08:02.145 [Info] [Send] [20017] kREGISTER_GAME_SERVER_REQ actionId:3 (SerializableExt.cs:92)</span><br><span class="line">2020-12-21 12:08:02.205 [Info] db connection Initialized. type:Auth server:localhost count:16 (DbPool.cs:40)</span><br><span class="line">2020-12-21 12:08:02.221 [Info] db connection Initialized. type:Contents server:localhost count:16 (DbPool.cs:40)</span><br><span class="line">2020-12-21 12:08:02.238 [Info] db connection Initialized. type:Game server:localhost count:16 (DbPool.cs:40)</span><br></pre></td></tr></table></figure><p>interning은 입구만 있고, 출구는 없는 string pool이다. 풀에 등록은 할 수 있지만 해제할 수는 없다. 한 번 쓰고 마는 동적인 문자열은 당연히 interning해서는 안된다. 반복적으로 사용하더라도 빈도가 낮아서, heap의 할당과 해제에 큰 압력을 주지 않는다면 이것도 굳이 interning할 필요는 없다. 이런 문자열들을 interning하면 장시간 떠있어야 하는 서버 프로그램의 경우 오히려 더 악영향을 끼칠 수 있다. 용도에 맞게 적절하게 적용해야 한다. </p><p>C#에서 코드에 함께 적혀있는 literl text들은 기본적으로 interning된다. C++처럼 code segment를 직접 가르키지는 않지만, 비슷한 효과를 내기 위함이다. 그 외에 프로그램이 사용하는 나머지 문자열에 대해서는 어떤 것을 interning할지 직접 판단하고 선별 적용해야 한다. 로그 메세지에 반복적으로 찍히는 소스코드 파일명은 interning하기에 적합한 대상이다. </p><h2 id="마치면서"><a href="#마치면서" class="headerlink" title="마치면서"></a>마치면서</h2><p>로그파일에서 로그 출력 위치를 남기는 방식에 관련해 성능 위주의 고려사항을 정리해 보았다. </p><ul><li>함수 호출자 정보를 얻고 싶을 땐 StackFrame 사용 보다 CompileServices 하위 어트리뷰트를 쓰는게 낫다. </li><li>C#은 모든 문자열을 항상 heap에 할당한다. 심지어 literal text같은 상수 문자열을 사용한다 하더라도 메모리 코드영역의 직접 참조가 불가능하다. </li><li>로그를 찍을 때마다 heap에 불필요한 객체 할당이 발생하는 것을 줄이고 싶다면 문자열을 Interning하면 된다.</li></ul>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c#</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B3%A0%EC%84%B1%EB%8A%A5/">고성능</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EA%B2%8C%EC%9E%84%EC%84%9C%EB%B2%84/">게임서버</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC/">메모리</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/string-interning/">string interning</category>
      
      
      <comments>http://leafbird.github.io/devnote/2020/12/26/C-%EA%B3%A0%EC%84%B1%EB%8A%A5-%EC%84%9C%EB%B2%84-FILE-LINE-%EB%8C%80%EC%B2%B4%EC%A0%9C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>테크니컬 리더십: 시작하기</title>
      <link>http://leafbird.github.io/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</link>
      <guid>http://leafbird.github.io/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</guid>
      <pubDate>Mon, 12 Nov 2018 14:05:29 GMT</pubDate>
      
      <description>&lt;p&gt;예전에 트위터 하다가 읽었던 글인데, 개인적으로 마음에 들어서 부족하게나마 번역해 보았습니다.&lt;br&gt;원문은 슬랙 개발 블로그의 &lt;a href=&quot;https://slack.engineering/technical-leadership-getting-started-e5161b1bf85c&quot;&gt;Technical Leadership: Getting Started&lt;/a&gt;라는 글입니다.&lt;br&gt;번역에 크게 자신이 없으니 부담이 없으신 분들은 원문을 보셔요. &lt;/p&gt;
&lt;img src=&quot;/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/00.png&quot; class=&quot;&quot; title=&quot;개발 실무자의 리더십은 스스로를 리딩하는 것에서 시작한다&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>예전에 트위터 하다가 읽었던 글인데, 개인적으로 마음에 들어서 부족하게나마 번역해 보았습니다.<br>원문은 슬랙 개발 블로그의 <a href="https://slack.engineering/technical-leadership-getting-started-e5161b1bf85c">Technical Leadership: Getting Started</a>라는 글입니다.<br>번역에 크게 자신이 없으니 부담이 없으신 분들은 원문을 보셔요. </p><img src="/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/00.png" class="" title="개발 실무자의 리더십은 스스로를 리딩하는 것에서 시작한다"><span id="more"></span><h2 id="테크니컬-리더십-시작하기"><a href="#테크니컬-리더십-시작하기" class="headerlink" title="테크니컬 리더십: 시작하기"></a>테크니컬 리더십: 시작하기</h2><p>내가 소프트웨어 엔지니어가 되기 전에는 이 직업에서 가장 중요한 점은 코딩이라고 생각했다. 그것은 잘못된 생각이었고, 소프트웨어 공학의 가장 중요한(그리고 가장 어려운)점은 다른 사람들과 원만하게 잘 협력하는 것이다. </p><p>나는 “관리자는 되지 않을거야!”라고 스스로에게 말해왔고, “그렇게 하면, 내 모든 에너지를 개발에만 집중시킬 수 있을거야!” 라고 생각했다. 내 이후의 경력도 기술 지향적인 실무자 위주로만 관리해 간다면 이 어려운 대인관계를 어느 정도 무시할 수 있을 거라고 생각했다. </p><blockquote><p>빨리 가려거든 혼자 가고, 멀리 가려거든 함께 가라.</p></blockquote><p>내가 업무에서 대인관계를 소홀히 여기던 때 의아하게 생각했던 점은 “왜 사람들은 나의 의견을 들어주지 않지?” 하는 점이었다. 이는 슬랙(Slack)의 플랫폼 팀에서 처음 작업을 시작했을 때 특히 그러했다. 나는 슬랙의 API가 토큰을 사용하고 있는 점을 변경하여 보안을 강화하고, 제품 개발팀 전체에 걸쳐 일관된 개발 과정을 유지하도록 개선하고 싶었다. 그러나 몇 달 동안, 나의 제안이 많은 이들의 시간을 보다 가치있게 활용할 수 있는 방법이라고 PM이나 팀원들을 설득하는 것은 불가능했다.</p><p>이후로도 몇 차례 나의 의견은 받아들여지지 않고, 같은 팀 수석 엔지니어들의 의견이 채택되는 것을 지켜보면서 내게 무언가 빠진 요소가 있다는 것을 알게 되었는데, 그것은 바로 ‘리더십’이었다. 나는 매일같이 키보드에만 코를 박고 있으면 안되는 것이었다. 내가 성장하기를 원한다면, 다른 사람들이 나와 동등한 수준으로 기여할 수 있도록 도움을 주어야 했던 것이다. 나는 리더십을 통해 나의 영향력을 키워야 할 필요가 있었다. </p><p>이 글을 통해 필자 스스로가 리더십에 대해 배운 점과, 개발자 리더십의 절차(Path)에 대해 이야기해 보고자 한다. </p><h2 id="자기-자신을-리딩하기"><a href="#자기-자신을-리딩하기" class="headerlink" title="자기 자신을 리딩하기"></a>자기 자신을 리딩하기</h2><p>슬랙의 엔지니어로 지내면서, 나는 관리(management)와 리더십(leadership)이 어떻게 다른지 이해하게 되었다. </p><p>관리자(manager)는 자신의 보고서에 대한 책임이 있다. 관리자들은 코칭과 구조화를 통해 좋은 팀을 구축하는 것에 중점을 둔다. 또한 팀의 성장을 위해 성과를 관리한다. </p><p>관리자(manager)는 종종 리더(leader)를 겸임하지만, 리딩은 사실 다른 누구라도 할 수 있는 별개의 것이다. 리딩은 권위에 의존하는 무언가가 아니라, 다른 사람에게 미치는 영향력에 대한 것이다. 리딩은 비전에 대해 소통하고, 비전을 실현하기 위해 다른 이들에게 힘을 실어주는 것이다.</p><p>당신은 다른 이들을 리드하기 전에, 먼저 당신 자신을 리드할 수 있어야 한다. 자신을 리딩하는 것은 타인을 리드하거나, 조직을 리드하기 전에 반드시 먼저 선행되어야 한다. 자신을 리딩한다는 개념은 다양한 분야와 기업에서 정리한 여러 리더십의 정의들에서 찾아볼 수 있다. </p><p>자기 자신을 리딩하는 것은 그 사람의 우수한 역량과 밀접한 관련이 있다. 모범적인 자세를 통해 드러나는 리더십은 타인에게 자극을 주는 가장 강력한 방법이기 때문이다. 자신을 리딩한다는 말은 늘 최선을 다해서 개인의 업무를 수행하고, 스스로가 만들어내는 결과물의 품질에 대해 책임을 지는 것을 의미한다. </p><p>자기 자신에게 성공적인 리더십을 발휘하기 위한 다섯하기 요소는 방향 맞추기, 전문가 되기, 공유하기, 일관되게 실행하기, 효과적인 의사소통하기 이다. </p><h2 id="방향-맞추기-Finding-Alignment"><a href="#방향-맞추기-Finding-Alignment" class="headerlink" title="방향 맞추기(Finding Alignment)"></a>방향 맞추기(Finding Alignment)</h2><img src="/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/01.jpg" class="" title="“Surya Namaskara” by Indian Navy licensed under Creative Commons."><p>직장에서 우수함을 나타내려면 먼저, 팀을 이해해야 하고, 회사를 이해해야 한다. </p><p>‘원칙’이란 어떤 행동이 바람직한지, 혹은 바람직하지 않은지를 안내하는 회사의 규범을 말한다. 대개는 이런 원칙들이 명확하게 규정되지 않은 경우도 많은데, 이런 숨은 원칙을 잘 찾아내는 것 역시 개인의 몫이다. 이 원칙들은 당신의 나침반과도 같다. 원칙들은 당신이 회사의 목표와 가치에 맞는 결정을 내리는데 큰 도움을 줄 것이다. </p><p>슬랙에서의 예를 들어보면, 우리는 슬랙의 사용자들에게 매우 뛰어난 사용 경험을 제공하고 있다는 믿음이 있다. 어떤 고객이 슬랙의 핵심 기능 중의 하나가 망가졌다는 제보를 한다면, 나에게는 그 즉시 내가 하고 있던 일을 모두 멈추고 현상을 확인해 즉시 문제를 해결하는 것이 가장 중요하다. 하지만 다른 회사에서는 내가 하던 일을 내팽개치는 것이 완전히 잘못된 판단이 될 수도 있는 것이다. </p><p>대부분의 결정은 여러가지 가치를 두고 다각도로 고민하면서 내려져야 한다. 오늘은 그동안 쌓아둔 기술 부채를 해결하는데 시간을 쓸 것인가? 아니면 좀 더 미루고 내일의 작업을 위한 기반작업을 할 것인가? 버그를 잡는 것, 툴을 만드는 것, 새로운 기능을 개발하는 것이 더 중요하진 않은가? 직장에서 할애할 수 있는 총 시간과 에너지의 양은 제한되어 있다. 회사가 중요하게 생각하는 것과 개인이 노력을 기울이는 방향을 동일하게 맞출 때 당신의 기여도는 가장 최대의 효율을 발휘할 것이다. </p><p>방향성 맞추기는 단지 회사가 당신에게 바라는 일을 수행하는 것만을 뜻하지 않는다. 여러분들은 리더로서 여러가지 문제를 직면하고, 이를 해결하기 위한 (숨어있는) 솔루션을 제시할 숱한 기회들을 마주하게 될 것이다. 하지만 그 때마다 다른 동료들에게 이것이 왜 문제이며, 왜 이를 해결하기 위해 에너지를 써야 하는가를 납득시키기 위해서는 먼저 회사가 무엇을 중요하게 생각하는지를 이해하고 다른사람에게 잘 설명할 수 있어야 한다. </p><h2 id="전문가-되기-Become-an-Expert"><a href="#전문가-되기-Become-an-Expert" class="headerlink" title="전문가 되기(Become an Expert)"></a>전문가 되기(Become an Expert)</h2><p>전문가가 되는 것은 개인 스킬을 연마하는 것에 관한 이야기다. 잠재력을 가진 상태라는 것이 하나의 좋은 자질일 순 있겠지만, 그걸로는 충분하지 않다. 리더는 실제로 뛰어난 전문가(export)여야 한다. 콜로라도 대학의 앤더스 에릭슨 교수에 따르면, 전문가가 되기 위해서는 평균 10년 이상 <a href="https://hbr.org/2007/07/the-making-of-an-expert">높은 수준의 의식적인 노력을 10,000시간 이상 기울여야 한다</a>고 말한다.</p><p>사람들은 종종 내가 오페라를 불렀던 경험이 소프트웨어 공학 경력에 도움이 되는지를 묻곤한다. 맞다! 음악을 통해서 나는 스스로의 마음가짐을 발전시킬 수 있었다. 아리아를 연습할 때면 가장 자신 없는 파트를 제일 자신있는 파트만큼의 자연 스러운 소리가 나올 때까지 몇시간이고 반복해서 연습했다. 소프트웨어 공학도 이것과 똑같다. 우리는 자신이 취약한 부분을 개발하는데 더욱 많은 시간을 투자해야 한다.</p><p>숙련을 쌓는 방법에 지름길이란 없다. 다만 꾸준하고 의식적인 노력으로 개발시키는 것 뿐이다. 내 자신에게(그리고 당신 주변의 사람들에게) 질문을 던져보자: 내가 가장 크게 성장할 수 있는 분야는 무엇인가? 전문가가 되기 위해서 나는 어떤 스킬을 개발해야 하는가?</p><p>당신이 개발하기 원하는 많은 스킬들이 있을 수 있지만, 노력을 기울이기 전에 먼저 다음의 질문을 던져보기를 권장한다: 그 스킬은 회사가 추구하는 방향에 부합하는가? 그 스킬은 나의 개인적인 목표에도 부합하는가?</p><p>‘아직 아무것도 이룬 것이 없다’는 생각만 하고 있을 게 아니라 매일 꾸준히 지식과 스킬을 체득하고자 노력하는 과정이 필요하다. 누구나 태어날 때부터 전문가였던 사람은 없다. </p><h2 id="공유하기-Share"><a href="#공유하기-Share" class="headerlink" title="공유하기(Share)"></a>공유하기(Share)</h2><p>자기 자신을 리딩하는 과정이 지나면, 다른 사람을 리드할 기회가 주어지고, 당신의 동료들이 최고의 성과를 내도록 역할을 부여하게 된다. 이를 성공적으로 수행하기 위해서는 먼저 지식을 공유해야 한다. </p><p>스킬을 습득하기 위해 많은 개인 시간을 소비한 후라면 선뜻 지식을 공유하는 것이 쉽지 않을 수도 있다. 특별한 전문성을 혼자만 “소유”하고 싶은 것은 본능적인 생각이다. 전문 지식은 체득 과정의 노력이 보이지 않을 땐 마치 마술처럼 느껴질 수도 있다. 당신은 혼자만의 마법을 비밀 상자에 숨겨놓고 외딴 곳에 보관하고 있다가 필요할 때만 꺼내서 사용하고 싶어할 수 있다. 다른 사람들은 그걸 어떻게 하는지 모르기 때문에, 당신만의 전문성은 여전히 마법을 유지하게 될 것이다. </p><p>하지만 바로 이 부분이 핵심이다. 당신의 노하우를 혼자만 알고 있으면 동료들은 당신에게 의존하게 되고, 결국 동료들의 성장을 방해하는 셈이 된다. 당신 스스로도 새로운 일을 배우는 것을 불안하다고 여기게 되어, 자신의 성장마저 방해하는 셈이 된다. 당신은 동료들이 팀에 기여하는 것을 막고 있으며, 팀을 아주 적극적으로 망치고 있는 셈이다. </p><p>나도 내가 가진 정보를 혼자만 유지하곤 했는데, 일부러 숨기고자 해서 그랬다기 보다는 이것이 유익한 정보인지 깨닫지 못했던 경우였다. 예를 들어, 나의 프로젝트에서는 업무의 진행을 방해하는 일반적인 문제점들에 대해 탐구하고 정리해왔다: 킥오프, 최종 마일스톤, 회귀 없는 릴리즈 같은 것들(역주: 예시의 내용들이 무엇을 말하는지는 잘 모르겠습니다). 나는 주위 동료들도 함께 성공했으면 하는 마음에 내가 유지하던 정보들 중 다른 팀들과 공유할 수 있는 기술들을 분류하기 시작했다. 사실 내 프로젝트만 잘 돌아가면 상관 없는 일이었지만.. 그것은 추가 확장이 없는 x1배의 영향력이다. 허나 이런 정보들은 모든 팀들에게 적용 가능한 것들이었고, 이것은 xN 배의 영향력을 발휘하게 된다.</p><p>지식을 숨기는 대신 공유하라. 멘토링이나 페어 프로그래밍 같은 1:1 방식도 좋고, 프레젠테이션이나 문서화 같은 1:N 방식도 좋다. 당신이 배운 사실을 다른 사람들에게도 가르쳐라. 그럼 다른 사람들은 다시 그 다음 사람들을 가르칠 것이다. 당신은 다시 배우고자 하는 그 다음 스킬로 자유롭게 이동할 수 있다. 지식이란 마르지 않는 샘이다. 아무리 배워도 항상 더 많이 남아있다. </p><img src="/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/02.jpeg" class="" title="by Nguyen Hung Vu licensed under Creative Commons."><h2 id="일관되게-실행하기-Execute-Consistently"><a href="#일관되게-실행하기-Execute-Consistently" class="headerlink" title="일관되게 실행하기(Execute Consistently)"></a>일관되게 실행하기(Execute Consistently)</h2><p>일전에 나의 관리자와 나눴던 대화가 기억난다. 나는 관리자에게 최근의 프로젝트에서 내가 매우 뛰어난 성과를 기록했다고 말하고, 내가 언제쯤 승진할 수 있느냐고 질문했다. 그는 현명하게 대답했다: “당신은 이번과 같은 좋은 성과를 일관되고 꾸준하게 달성할 수 있음을 증명해야 합니다.”</p><p>일관성. 그것은 일시적인 운과 리더십의 차이를 말해준다.</p><p>당신이 어느 한가지 일을 딱 한 번 잘해냈다는 것은 별로 중요하지 않다. 정말 중요한 것은 당신이 그 일을 다시, 또 다시, 그리고 또 다시 잘 해낼 수 있는가 하는 것이다. </p><p>일관성 있는 실행력을 갖기 위해서는, 다양한 규모와 유형의 여러가지 프로젝트를 해봐야 할 것이다. 작은 규모, 큰 규모, 복합적인 기능, 사용자 친화적 UX, 백엔드 솔루션 등등. 이러한 경험들에서 당신은 다양한 도전 과제를 마주하고 해결 방안들을 개발하게 된다. 당신의 약점이 무엇인지를 드러내주고 당신이 스킬을 연마하도록 도울것이다.</p><p>당신의 관리자에게, 당신이 익히려고 하는 기술들을 미리 공유하라. 앞으로 맡게 될 프로젝트를 주시하고 그 중에 자신이 흥미가 가는 부분이 무엇이며 왜 그렇게 생각하는지를 관리자에게 미리 알려라. 당신이 지금 프로젝트를 진행중이라면, 작업하는 동안 나는 어떤 스킬을 선정해 발전시켜갈 것인가에 대해 생각하라. 이것은 직장에서의 시간을 최대의 효율로 활용하는데 큰 도움을 줄 것이다. </p><p>때로는 당신이 크게 열정을 느끼지 못하지만 팀의 임무에는 중요한(mission-critical)일에 배정이 될 때도 있다. 당신은 이 또한 잘 해낼 수 있음을 증명해야 한다. </p><p>일관되게 실행하는 것은 개인의 브랜드를 개발시키고 동료들에게 신뢰를 쌓을 수 있는 방법이다. 신뢰감을 형성하고 키우는 데에는 많은 시간과 경험이 필요하다. 하룻밤 만에 만들어지지 않는다. 한 번 신뢰를 얻었다 하더라도 지속적인 노력이 뒤따라야만 이를 오래도록 유지할 수 있다. </p><h2 id="효과적인-의사소통하기-Communicate-Effectively"><a href="#효과적인-의사소통하기-Communicate-Effectively" class="headerlink" title="효과적인 의사소통하기(Communicate Effectively)"></a>효과적인 의사소통하기(Communicate Effectively)</h2><p>“왜 사람들이 내 말을 들어주지 않는거야?” 하고 궁금해 한 적이 있는가?</p><p>나는 신입일 때 여러 차례 위와 같은 질문을 하곤 했다. 그러던 어느날 문득 내가 성장의 준비가 되었을 즈음에, 사장님이 중요한 단서를 주었다: 나는 동료들에게 부정적인 성향으로 인식되고 있었다는 점이다. 처음엔 그 피드백을 듣고 기분이 상했다. 하지만 이것이 나의 경력에서 중요한 전환점이 되었다. 그 후로 나는 ‘목소리’ 코치와 함께 일하게 되었고, 효과적인 커뮤니케이션의 중요한 비밀을 깨닫게 되었다. 그것은 경청(listening)이다.</p><p>경청이란 단순히 정보를 받아들이는 것이 아니다. 경청은 정보와 함께 그것의 맥락을 모두 합쳐 하나의 덩어리로 합성하는 것이다. 경청은 상대방의 의견이 어디에서 왔는지를 이해하고, 더 깊은 이해를 얻기 위해 명확한 질문을 던지는 것을 말한다. 이 합성의 듣기는 효과적인 커뮤니케이션의 가장 기본임과 동시에, 당신이 말하고자 하는 아이디어에도 엄청난 힘을 실어준다 - 믿거나 말거나.</p><div class="twitter-wrapper"><blockquote class="twitter-tweet"><a href="https://twitter.com/sarahmei/status/862584755849539584"></a></blockquote></div><script async defer src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote><p>레벨이 올라감에 따라 관리자 트랙과 엔지니어 트랙에게는 모두 동일한 의사소통 기술이 요구됩니다. 각 트랙의 진정한 능력자들이 서로 다른 트랙의 능력자를 존재할 수 있게 만듭니다. - Sarah Mei</p></blockquote><p>효과적인 의사소통의 또 다른 측면은 적절한 맥락으로 반복하는 것이다. 사람들이 왜 내 말에 귀기울이지 않는지 몰랐을 때의 나는 했던 말을 다시 반복해야 할 때면 화를 내면서 말했다. </p><p>나중에서야 효과적인 의사소통의 고수들을 관찰하기 시작했다. 그들은 다방면으로 정보를 노출한다. 적절한 시간 간격을 두고 반복적으로 정보를 전달하고, 듣는 사람이 누군가에 따라 그에 맞는 다양한 세부 정보들을 제공한다.</p><p>정보를 듣고 종합하고, 효과적으로 공유하는 방법을 익히는 것은 직급에서 오는 권위에 의존하지 않고 사람들에게 영향을 미치는 기본적 기술이다. 모두가 하나의 비전을 바라하도록 사람들을 모으기 위해서는 이러한 영향력이 필요하다.</p><p>. . . </p><p>소프트웨어 엔지니어로 일을 시작할 때, 왜 나의 아이디어가 회사에서-그리고 업계에서-잘 받아들여지지 않는 것인가를 궁금해했다. 그러던 중 컴퓨터만 골똘히 들여다보던 시선을 잠시 벗어나, 주변의 훌륭한 동료들을 만나보게 되면서 깨달았다. 내가 생각하는 방향성을 다른 사람들이 함께 공감하고, 실현하기 위해 같이 노력하도록 동기부여할 수 있다면 훨씬 더 큰 영향력을 미칠 수 있다는 것을.</p><p>리더십에 관해서는 배워야 할 것이 많고, 필자 개인적으로는 더 많은 것들을 배워야 한다. 리더급 개발자가 되고자 한다면, 먼저 자기 자신을 리딩하는 것부터 시작하기를 권한다. 이 외에 당신이 찾아낸 리더십에 대해 내게도 알려주길 바란다!</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/%EB%A6%AC%EB%8D%94%EC%8B%AD/">리더십</category>
      
      
      <comments>http://leafbird.github.io/devnote/2018/11/12/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC-%EB%A6%AC%EB%8D%94%EC%8B%AD-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ 코드 정리 자동화 - 3. pch 사이즈 확인, #include 순서정리</title>
      <link>http://leafbird.github.io/devnote/2014/09/29/cleanup-cpp-project-3rd/</link>
      <guid>http://leafbird.github.io/devnote/2014/09/29/cleanup-cpp-project-3rd/</guid>
      <pubDate>Mon, 29 Sep 2014 21:17:15 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;pch-파일-사이즈&quot;&gt;&lt;a href=&quot;#pch-파일-사이즈&quot; class=&quot;headerlink&quot; title=&quot;pch 파일 사이즈&quot;&gt;&lt;/a&gt;pch 파일 사이즈&lt;/h2&gt;&lt;p&gt;팀에서 만지는 코드에서는, 290Mb에 육박하는 pch파일을 본 적이 있다(…) 그 땐 코드를 정리하면서 pch 사이즈 변화를 자주 확인해봐야 했는데, 탐색기나 커맨드 창에서 매번 사이즈를 조회하기가 불편했던 기억이 있어서 pch 사이즈 확인하는 걸 만들어봤다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="pch-파일-사이즈"><a href="#pch-파일-사이즈" class="headerlink" title="pch 파일 사이즈"></a>pch 파일 사이즈</h2><p>팀에서 만지는 코드에서는, 290Mb에 육박하는 pch파일을 본 적이 있다(…) 그 땐 코드를 정리하면서 pch 사이즈 변화를 자주 확인해봐야 했는데, 탐색기나 커맨드 창에서 매번 사이즈를 조회하기가 불편했던 기억이 있어서 pch 사이즈 확인하는 걸 만들어봤다.</p><span id="more"></span><p>MSBuild로 단일 cpp 파일을 컴파일하면 이런 메시지가 나오는데,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\amd64\CL.exe </span><br><span class="line">/c </span><br><span class="line">/ID:\Dev\uni\External\ </span><br><span class="line">/ID:\Dev\uni\Test\ </span><br><span class="line">/ID:\Dev\uni\ </span><br><span class="line">/Zi </span><br><span class="line">/nologo </span><br><span class="line">/W4 </span><br><span class="line">/WX </span><br><span class="line">/sdl </span><br><span class="line">/Od </span><br><span class="line">/D WIN32 </span><br><span class="line">/D _DEBUG </span><br><span class="line">/D _CONSOLE </span><br><span class="line">/D _LIB </span><br><span class="line">/D _UNICODE </span><br><span class="line">/D UNICODE </span><br><span class="line">/Gm </span><br><span class="line">/EHsc </span><br><span class="line">/RTC1 </span><br><span class="line">/MDd </span><br><span class="line">/GS </span><br><span class="line">/fp:precise </span><br><span class="line">/Zc:wchar_t </span><br><span class="line">/Zc:forScope </span><br><span class="line">/Yc&quot;stdafx.h&quot; </span><br><span class="line">/Fp&quot;x64\Debug\unittest.pch&quot; </span><br><span class="line">/Fo&quot;x64\Debug\\&quot; </span><br><span class="line">/Fd&quot;x64\Debug\vc120.pdb&quot; </span><br><span class="line">/Gd </span><br><span class="line">/TP </span><br><span class="line">/errorReport:queue </span><br><span class="line">stdafx.cpp</span><br></pre></td></tr></table></figure><p>여기 <code>cl.exe</code>로 들어가는 인자 중에 <code>/Fp&quot;x64\Debug\unittest.pch&quot;</code> 요 부분에 pch 경로가 있음. 그러니까 결국 툴에서 pch사이즈를 구하려면</p><ol><li>프로젝트 리빌드하고</li><li>pch 생성 헤더를 cl.exe로 컴파일하면서 &#x2F;Fp 스위치를 읽어 경로 파악.</li><li>위에서 새로 생성된 pch파일의 사이즈를 확인.</li></ol><p>… 해주면 된다.</p><h2 id="include-순서-자동-정렬"><a href="#include-순서-자동-정렬" class="headerlink" title="#include 순서 자동 정렬"></a>#include 순서 자동 정렬</h2><p>구글의 C++ 스타일 가이드 문서 중에 <a href="http://jongwook.github.io/google-styleguide/trunk/cppguide.xml#include%EC%9D%98_%EC%9D%B4%EB%A6%84%EA%B3%BC_%EC%88%9C%EC%84%9C">include 의 이름과 순서</a> 항목에 보면 헤더 인클루드에 몇가지 카테고리와 순서를 정해 두었는데, </p><blockquote><p>주된 목적이 dir2&#x2F;foo2.h에 있는 것들을 구현하거나 테스트하기 위한 dir&#x2F;foo.cc나 dir&#x2F;foo_test.cc에서 include를 아래처럼 순서에 따라 배열하라.</p><ol><li>dir2&#x2F;foo2.h (아래 설명 참조).</li><li>C 시스템 파일</li><li>C++ 시스템 파일</li><li>다른 라이브러리의 .h 파일</li><li>현재 프로젝트의 .h 파일</li></ol></blockquote><p>팀에서 정한 컨벤션도 이 규칙을 그대로 따라야 해서.. 매번 코딩할 때마다 인클루드 순서에 신경쓰기 싫어서 자동화 처리를 작성. 더불어 경로 없이 파일명만 적은 경우나 상대경로를 사용한 인클루드도 지정된 path를 모두 적어주도록 컨버팅하는 처리도 만듦. 만드는 과정이야 대단한 건 없다. sln, vcxproj파일 파싱하는 것은 만들어 두었으니, 그냥 스트링 처리만 좀 더 해주면 금방 만들어진다. 툴로 sorting하고나면 아래처럼 만들어줌.</p><figure class="highlight cpp"><figcaption><span>TestCode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/ProjRoot/TestCode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system headers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// other project&#x27;s headers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/OuterProject.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/OuterProjectX.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inner project&#x27;s headers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/ProjRoot/InterProject.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/ProjRoot/InterProjectA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/ProjRoot/InterProjectB.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestAsset/ProjRoot/InterProjectC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epilog"><a href="#epilog" class="headerlink" title="epilog"></a>epilog</h2><p>대충 이정도 돌아가는 툴을 만들어서 개인 pc에 셋팅해둔 jenkins에 물려놓고 사용중. 원래는 필요없는 include찾아주는 기능만 만들려다가 include sorting 기능은 그냥 한 번 추가나 해볼까 싶어 넣은건데, 아주 편하다. 코딩할 땐 순서 상관 없이 상대경로로 대충 넣어놓고 툴을 돌리면 컨벤션에 맞게 예쁘게 수정해준다.</p><p>불필요 인클루드를 찾는 동작은 회사 코드 기준으로 컨텐츠 코드 전체 검색시 50분 정도 걸리는 듯. 이건 매일 새벽에 jenkins가 한 번씩 돌려놓게 해놓고, 매일 아침에 출근해서 확인한다.</p><p>pch사이즈는 baseline 구축을 생각하고 만들어 본건데.. (박일, <a href="http://www.slideshare.net/parkpd/in-ndc2010">사례로 살펴보는 디버깅</a> 참고) baseline을 만들려면 지표들을 좀 더 모아야 하고, db도 붙여야 하니 이건 제대로 만들려면 시간이 필요할 것 같다(..라고 쓰고 ‘더이상 업데이트 되지 않는다’ 라고 읽는다.)</p><h3 id="그리고-C"><a href="#그리고-C" class="headerlink" title="그리고 C#."></a>그리고 C#.</h3><p>C#은 재미있다. 이번에 툴 만들때도 한참 빠져들어서 재미있게 만들었다. Attribute를 달아서 xml 파일을 자동으로 로딩하는 처리를 만들어 보았는데, cpp에서 하기 힘든 깔끔한 이런 가능성들이 마음에 든다. 규모 큰 프로젝트는 안해봐서 모르겠지만 개인적으로 가지고 놀기에는 제일 맘에 듬. 디버깅 하기 좋고 코드 짜기도 좋고.</p><h3 id="Visual-Stuio-Online"><a href="#Visual-Stuio-Online" class="headerlink" title="Visual Stuio Online"></a>Visual Stuio Online</h3><p>코드 관리를 <a href="http://www.visualstudio.com/en-us/products/what-is-visual-studio-online-vs.aspx">visual studio online</a>에서 해봤다. 비공개 코드는 주로 개인 Nas나 bitbucket에 올려놓는데, VS IDE에서 링크가 있길래 한 번 눌러봤다가 한 번 써봄.<br>bitbucket보다 좀 더 많은 기능이 있다. 빌드나 단위테스트를 돌려볼 수 있고(하지만 유료), backlog, splint관리용 보드가 좀 더 디테일하다. 개인 코딩 말고 팀을 꾸려서 작업을 한다면 한 번 제대로 사용해 보는 것을 고려해 볼 순 있겠으나… 왠지 그냥 마음이 안간다. 나같으면 그냥 github 유료 결제해서 쓸 거 같애 ‘ㅅ’)</p><p>이제 이건 고마하고 다음 toy project로 넘어가야지.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c++</category>
      
      
      <comments>http://leafbird.github.io/devnote/2014/09/29/cleanup-cpp-project-3rd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ 코드 정리 자동화 - 2. 불필요한 #include 찾기 下</title>
      <link>http://leafbird.github.io/devnote/2014/09/17/cleanup-cpp-project-2nd/</link>
      <guid>http://leafbird.github.io/devnote/2014/09/17/cleanup-cpp-project-2nd/</guid>
      <pubDate>Wed, 17 Sep 2014 02:30:24 GMT</pubDate>
      
      <description>&lt;p&gt;이전 포스트 ‘&lt;a href=&quot;/devnote/2014/09/12/claenup-cpp-project-1st/&quot; title=&quot;C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上&quot;&gt;C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上&lt;/a&gt;‘ 에서 이어진다.&lt;/p&gt;
&lt;h2 id=&quot;지워도-되는-인클루드를-찾아냈다&quot;&gt;&lt;a href=&quot;#지워도-되는-인클루드를-찾아냈다&quot; class=&quot;headerlink&quot; title=&quot;지워도 되는 인클루드를 찾아냈다&quot;&gt;&lt;/a&gt;지워도 되는 인클루드를 찾아냈다&lt;/h2&gt;&lt;p&gt;개별 파일 하나씩을 컴파일 할 수 있다면 이제 모든 인클루드를 하나씩 삭제하면서 컴파일 가능 여부를 확인해보면 된다. 이 부분은 간단한 file seeking과 string 처리 작업일 뿐이니 굳이 부연 설명은 필요 없다. 카페에서 여유롭게 음악을 들으며 즐겁게 툴을 만들자. 뚝딱뚝딱.&lt;/p&gt;
&lt;p&gt;이정도 하고 나니 이제 vcxproj파일 경로를 주면 해당 프로젝트에 들어있는 소스코드에서 불필요한 인클루드를 색출해 위치정보를 출력해주는 물건이 만들어졌다.&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;작업 대상으로 1개의 프로젝트가 입력 되었습니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Service : 프로젝트 정리.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Service : PCH 생성.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;컴파일 : stdafx.cpp ... 성공. 걸린 시간 : 1.04초&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Client.cpp의 인클루드를 검사합니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 Client.cpp (1/2) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 Client.cpp (2/2) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ClientAcceptor.cpp의 인클루드를 검사합니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 ClientAcceptor.cpp (1/2) ... 컴파일 가능!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 ClientAcceptor.cpp (2/2) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ClientConnection.cpp의 인클루드를 검사합니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 ClientConnection.cpp (1/3) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 ClientConnection.cpp (2/3) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 ClientConnection.cpp (3/3) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Start.cpp의 인클루드를 검사합니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 Start.cpp (1/4) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 Start.cpp (2/4) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 Start.cpp (3/4) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 Start.cpp (4/4) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ThreadEntry.cpp의 인클루드를 검사합니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - process #1 ThreadEntry.cpp (1/1) ... X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Project : Service 모두 1개의 인클루드가 불필요한 것으로 의심됩니다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D:&#92;Dev&#92;uni&#92;World&#92;Service&#92;ClientAcceptor.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 2 line : #include &amp;quot;World/Service/Client.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;총 소요 시간 : 13.289 sec&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이전 포스트 ‘<a href="/devnote/2014/09/12/claenup-cpp-project-1st/" title="C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上">C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上</a>‘ 에서 이어진다.</p><h2 id="지워도-되는-인클루드를-찾아냈다"><a href="#지워도-되는-인클루드를-찾아냈다" class="headerlink" title="지워도 되는 인클루드를 찾아냈다"></a>지워도 되는 인클루드를 찾아냈다</h2><p>개별 파일 하나씩을 컴파일 할 수 있다면 이제 모든 인클루드를 하나씩 삭제하면서 컴파일 가능 여부를 확인해보면 된다. 이 부분은 간단한 file seeking과 string 처리 작업일 뿐이니 굳이 부연 설명은 필요 없다. 카페에서 여유롭게 음악을 들으며 즐겁게 툴을 만들자. 뚝딱뚝딱.</p><p>이정도 하고 나니 이제 vcxproj파일 경로를 주면 해당 프로젝트에 들어있는 소스코드에서 불필요한 인클루드를 색출해 위치정보를 출력해주는 물건이 만들어졌다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">작업 대상으로 1개의 프로젝트가 입력 되었습니다.</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Service : 프로젝트 정리.</span><br><span class="line">Service : PCH 생성.</span><br><span class="line">컴파일 : stdafx.cpp ... 성공. 걸린 시간 : 1.04초</span><br><span class="line">Client.cpp의 인클루드를 검사합니다.</span><br><span class="line"> - process #1 Client.cpp (1/2) ... X</span><br><span class="line"> - process #1 Client.cpp (2/2) ... X</span><br><span class="line">ClientAcceptor.cpp의 인클루드를 검사합니다.</span><br><span class="line"> - process #1 ClientAcceptor.cpp (1/2) ... 컴파일 가능!</span><br><span class="line"> - process #1 ClientAcceptor.cpp (2/2) ... X</span><br><span class="line">ClientConnection.cpp의 인클루드를 검사합니다.</span><br><span class="line"> - process #1 ClientConnection.cpp (1/3) ... X</span><br><span class="line"> - process #1 ClientConnection.cpp (2/3) ... X</span><br><span class="line"> - process #1 ClientConnection.cpp (3/3) ... X</span><br><span class="line">Start.cpp의 인클루드를 검사합니다.</span><br><span class="line"> - process #1 Start.cpp (1/4) ... X</span><br><span class="line"> - process #1 Start.cpp (2/4) ... X</span><br><span class="line"> - process #1 Start.cpp (3/4) ... X</span><br><span class="line"> - process #1 Start.cpp (4/4) ... X</span><br><span class="line">ThreadEntry.cpp의 인클루드를 검사합니다.</span><br><span class="line"> - process #1 ThreadEntry.cpp (1/1) ... X</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Project : Service 모두 1개의 인클루드가 불필요한 것으로 의심됩니다.</span><br><span class="line">D:\Dev\uni\World\Service\ClientAcceptor.cpp</span><br><span class="line"> - 2 line : #include &quot;World/Service/Client.h&quot;</span><br><span class="line"></span><br><span class="line">총 소요 시간 : 13.289 sec</span><br></pre></td></tr></table></figure><span id="more"></span><p>이 정도 만들어서 회사에서 만들고 있는 프로젝트에 조금 돌려 보았는데, <strong>덕분에 꽤나 많은 불필요 인클루드를 색출해 내었다.</strong> 회사 프로젝트는 덩치가 제법 크고, 아직 서비스 중이지 않은 코드여서 용감무쌍한 리팩토링이 자주 일어나기 때문에 관리가 잘 안되는 파일이 제법 있더라. 아무튼 덕을 톡톡히 보았다.</p><h2 id="튜닝-솔루션-단위로-검사할-수-있게-만들자"><a href="#튜닝-솔루션-단위로-검사할-수-있게-만들자" class="headerlink" title="튜닝 : 솔루션 단위로 검사할 수 있게 만들자"></a>튜닝 : 솔루션 단위로 검사할 수 있게 만들자</h2><p>프로젝트 파일 단위로 어느 정도 돌아가니까, 솔루션 파일 단위로도 돌릴수 있게 확장했다. sln 파일을 파싱해서 프로젝트 리스트만 얻어오면 끝나는 일이다. </p><p>하지만 sln 파일은 vcxproj 파일처럼 쉽게 파싱할 수는 없다. 이녀석은 xml 포맷이 아니라, 자체적인 포맷을 가지고 있다. 사실 sln 파일을 파싱해 본 게 이번이 처음이 아닌데, 예전에는 lua를 써서 직접 노가다 파싱을 했더니 별로 재미도 없고 잘 돌아가지도 않고 코딩하는 재미도 별로 없더라. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 솔루션 파일은 이렇게 생겼다. 왜죠...</span><br><span class="line"></span><br><span class="line">Microsoft Visual Studio Solution File, Format Version 12.00</span><br><span class="line"># Visual Studio 2013</span><br><span class="line">VisualStudioVersion = 12.0.30723.0</span><br><span class="line">MinimumVisualStudioVersion = 10.0.40219.1</span><br><span class="line">... 중략 ...</span><br><span class="line">Project(&quot;&#123;2150E333-8FDC-42A3-9474-1A3956D46DE8&#125;&quot;) = &quot;External&quot;, &quot;External&quot;, &quot;&#123;F95C61E3-AF95-4CA9-8837-A203762B2B29&#125;&quot;</span><br><span class="line">EndProject</span><br><span class="line">Project(&quot;&#123;8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942&#125;&quot;) = &quot;gtest&quot;, &quot;External\gtest\gtest.vcxproj&quot;, &quot;&#123;C7A81BFC-6E28-4859-A8B5-2FEA80E012B2&#125;&quot;</span><br><span class="line">EndProject</span><br><span class="line">Project(&quot;&#123;2150E333-8FDC-42A3-9474-1A3956D46DE8&#125;&quot;) = &quot;Test&quot;, &quot;Test&quot;, &quot;&#123;042F2157-2118-44AA-8BB9-8B5DD01FA3A9&#125;&quot;</span><br><span class="line">EndProject</span><br><span class="line">Project(&quot;&#123;8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942&#125;&quot;) = &quot;unittest&quot;, &quot;Test\unittest.vcxproj&quot;, &quot;&#123;24A57754-D332-4575-AEBF-2AFCBC0A7E4B&#125;&quot;</span><br><span class="line">EndProject</span><br><span class="line">... 후략 ...</span><br></pre></td></tr></table></figure><p>C#으로 sln 파일을 파싱해주는 적당히 괜찮은 코드가 인터넷 어딘가에 돌아다닌다. <a href="http://stackoverflow.com/questions/707107/library-for-parsing-visual-studio-solution-files">이곳</a>에 있는 놈을 가져다 붙였다. build configuration 같은 걸 얻어올 순 없지만 프로젝트 리스트 얻는 데에는 충분하다.</p><h2 id="튜닝-느리다-멀티-스레드로-돌리자"><a href="#튜닝-느리다-멀티-스레드로-돌리자" class="headerlink" title="튜닝 : 느리다. 멀티 스레드로 돌리자"></a>튜닝 : 느리다. 멀티 스레드로 돌리자</h2><p>한때는 툴을 만들때 lua도 써보고 python도 써봤지만 요즘은 C#만 쓰게된다. 디버깅 하기도 편하고, <strong>특히 멀티스레딩으로 돌리기가 너무 편하다.</strong> TPL, Concurrent Collection조금 갖다 끄적거리면 금방 병렬처리된다.</p><p>특히나 이런 식으로 병렬성이 좋은 툴은 훨씬 빠르게 돌릴 수 있게 된다. 커맨드 라인 인자로 <code>--multi-thread</code>를 주면 주요 작업을 <code>Parallel.ForEach</code>로 돌리도록 처리했다. 다만 멀티스레드로 돌리면 파일로 남기는 로그가 엉망이 되기 때문에… 단일 스레드로도 돌 수 있도록 남겨둠. </p><p>이번엔 병렬처리할 때 thread-safe한 container가 필요했는데, <a href="http://msdn.microsoft.com/ko-kr/library/system.collections.concurrent.aspx">System.Collections.Concurrent</a>에 가면 queue, stack, dictionary등 종류별로 잔뜩 들어있으니 적당한 놈으로 바로 갖다 쓰면 된다. 편하다 C#. 네이티브 코더는 그냥 웁니다 ㅠㅠ…</p><p>지금 내가 가진 개인 코드 중에는 덩치큰 cpp 프로젝트가 없어서, 조그만 솔루션 하나 시험삼아 돌려봤다.</p><img src="/devnote/images/140917_00.PNG" class="center"><p>87초 걸리던 것이 24초로 빨리짐. 대충 4배 가량 빨라졌다. 내일 회사에서 대빵 큰 프로젝트에 한 번 돌려봐야지. 생각하니 기대된다.</p><h2 id="More-Improvement-불필요한-전방선언-forward-declaration-색출"><a href="#More-Improvement-불필요한-전방선언-forward-declaration-색출" class="headerlink" title="More Improvement : 불필요한 전방선언(forward declaration) 색출."></a>More Improvement : 불필요한 전방선언(forward declaration) 색출.</h2><p>툴을 좀 더 확장할 수 있을거 같다. 클래스와 구조체 전방선언을 써놓고 지우지 않아서 찌꺼기가 된 부분을 이것으로 찾아낼 수 있을 것 같다. 이건 파일을 일일이 컴파일 하지 않아도 되니까 훨씬 빠르게 가능할 듯.</p><p>전방선언 확인 작업도 따지고 보면 단순 string 처리니까… 시간될 때 카페에 가서 찬찬히 코딩하다보면 금방 짤 수 있겠지. cpp 파일을 write하는 작업도 없어서 read만 하면 되기 때문에 아마 병렬성도 훨씬 더 좋을 것이다.  </p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c++</category>
      
      
      <comments>http://leafbird.github.io/devnote/2014/09/17/cleanup-cpp-project-2nd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ 코드 정리 자동화 - 1. 불필요한 #include 찾기 上</title>
      <link>http://leafbird.github.io/devnote/2014/09/12/claenup-cpp-project-1st/</link>
      <guid>http://leafbird.github.io/devnote/2014/09/12/claenup-cpp-project-1st/</guid>
      <pubDate>Fri, 12 Sep 2014 02:26:14 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;지워도-되는-헤더-인클루드를-색출하고-싶다&quot;&gt;&lt;a href=&quot;#지워도-되는-헤더-인클루드를-색출하고-싶다&quot; class=&quot;headerlink&quot; title=&quot;지워도 되는 헤더 인클루드를 색출하고 싶다&quot;&gt;&lt;/a&gt;지워도 되는 헤더 인클루드를 색출하고 싶다&lt;/h2&gt;&lt;p&gt;매우 느리게 찔끔찔끔 진행하는 토이 프로젝트가 있는데, 오늘 처음으로 무언가 그럴싸한 아웃풋이 나오게 되어 스냅샷을 하는 느낌으로 간단히 포스팅.&lt;/p&gt;
&lt;p&gt;cpp 프로젝트 규모가 점점 커지게 되면 빌드 시간 때문에 많은 고통을 겪는다. 이때문에 &lt;a href=&quot;https://www.incredibuild.com/&quot;&gt;increadi build&lt;/a&gt; 같은 분산 빌드 솔루션도 쓰는거고 &lt;a href=&quot;http://www.slideshare.net/devcatpublications/ndc2010-unity-build&quot;&gt;unity build&lt;/a&gt; 같은 꼼수도 사용하게 되는거다. &lt;/p&gt;
&lt;p&gt;하지만 저런 솔루션들을 사용하기 이전에, 코드를 정리하는 것이 먼저 선행될 필요가 있다. cpp는 특성상 작업하다보면 소스파일에 불필요한 헤더파일의 #include가 남게되고, 이것들이 불필요한 dependency를 만들어내면서 늘어지는 빌드 시간을 무시할 수 없기 때문이다. &lt;/p&gt;
&lt;p&gt;그런데 문제는 그렇게 생긴 불필요 인클루드 구문이 무엇인지를 골라내기가 힘들다는 점이다. 프로젝트 규모가 커질수록 더욱 힘들다. c#같은 경우 불필요 using 구문을 아예 visual studio IDE가 자체적으로 정리해주기까지 하지만, cpp는 색출조차 힘들다 보니 이런 기능을 제공하는 3rd party tool도 없어 보인다. &lt;a href=&quot;http://www.wholetomato.com/downloads/spaghettiDownload.asp&quot;&gt;Whole Tomato의 Spaghetti&lt;/a&gt; 처럼 인클루드간의 관계를 그래프로 보여주는 툴은 몇 번 본 적 있다. 조낸 멋지게 그래프까지 보여주었지만 정작 불필요한 놈이 무언지 콕 짚어주는 녀석은 없음. 참으로 척박한 현실이다. &lt;/p&gt;
&lt;p&gt;그래서 한 번 직접 만들어보기로 했다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="지워도-되는-헤더-인클루드를-색출하고-싶다"><a href="#지워도-되는-헤더-인클루드를-색출하고-싶다" class="headerlink" title="지워도 되는 헤더 인클루드를 색출하고 싶다"></a>지워도 되는 헤더 인클루드를 색출하고 싶다</h2><p>매우 느리게 찔끔찔끔 진행하는 토이 프로젝트가 있는데, 오늘 처음으로 무언가 그럴싸한 아웃풋이 나오게 되어 스냅샷을 하는 느낌으로 간단히 포스팅.</p><p>cpp 프로젝트 규모가 점점 커지게 되면 빌드 시간 때문에 많은 고통을 겪는다. 이때문에 <a href="https://www.incredibuild.com/">increadi build</a> 같은 분산 빌드 솔루션도 쓰는거고 <a href="http://www.slideshare.net/devcatpublications/ndc2010-unity-build">unity build</a> 같은 꼼수도 사용하게 되는거다. </p><p>하지만 저런 솔루션들을 사용하기 이전에, 코드를 정리하는 것이 먼저 선행될 필요가 있다. cpp는 특성상 작업하다보면 소스파일에 불필요한 헤더파일의 #include가 남게되고, 이것들이 불필요한 dependency를 만들어내면서 늘어지는 빌드 시간을 무시할 수 없기 때문이다. </p><p>그런데 문제는 그렇게 생긴 불필요 인클루드 구문이 무엇인지를 골라내기가 힘들다는 점이다. 프로젝트 규모가 커질수록 더욱 힘들다. c#같은 경우 불필요 using 구문을 아예 visual studio IDE가 자체적으로 정리해주기까지 하지만, cpp는 색출조차 힘들다 보니 이런 기능을 제공하는 3rd party tool도 없어 보인다. <a href="http://www.wholetomato.com/downloads/spaghettiDownload.asp">Whole Tomato의 Spaghetti</a> 처럼 인클루드간의 관계를 그래프로 보여주는 툴은 몇 번 본 적 있다. 조낸 멋지게 그래프까지 보여주었지만 정작 불필요한 놈이 무언지 콕 짚어주는 녀석은 없음. 참으로 척박한 현실이다. </p><p>그래서 한 번 직접 만들어보기로 했다. </p><span id="more"></span><h2 id="프로젝트-내의-cpp-파일을-개별-컴파일-하기"><a href="#프로젝트-내의-cpp-파일을-개별-컴파일-하기" class="headerlink" title="프로젝트 내의 cpp 파일을 개별 컴파일 하기"></a>프로젝트 내의 cpp 파일을 개별 컴파일 하기</h2><p>일단은 만들려는 툴에서, 입력으로 받은 vc 프로젝트에 포함된 cpp 파일을 개별로 컴파일 할 수 있어야 한다.<br>그렇게 되면 cpp 파일마다 돌면서 코드 안에 있는 #include를 직접 하나씩 제거해보면서 컴파일이 성공하는지를 확인할거다. 그러면 불필요할 것이라 예상되는 #include의 후보를 만들 수 있다. </p><p>무식한 방법이다. cpu를 많이 먹을거고 시간도 오래 걸릴거다. 하지만 저렇게라도 알 수 있다면 새벽에 실행해서 리포트 뽑아놓도록 CI에 물려놓으면 그만이다.</p><p>무식하기도 하지만 또한 불완전한 방법이기도 하다. 위의 동작으로 불필요 #include 후보 리스트를 만들었다고 해도,<br> 헤더파일 끼리의 상호 참조관계, 내부 포함 관계등이 여러 복잡한 상황을 연출하기 때문에<br>후보로 지목된 헤더가 실은 필요한 녀석일 수도 있다. </p><p>하지만 일단은 후보 리스트 색출까지 먼저 진행해 보기로 한다.<br>사실 정말 확실한 불필요 #include가 색출 가능하다면 tool이 아예 코드를 코치는 것까지 자동으로 처리해 줄 수도 있을 것 같지만… 일단 나중에 생각하기로.</p><p>프로젝트에 포함된 cpp 파일의 리스트를 구하는 것은 일도 아니다. vcxproj파일은 xml 형태로 되어 있으므로, <code>/Project/ItemGroup/ClCompile</code> 경로의 xml element를 얻어와 파일 경로를 읽어내면 끝이다. </p><p>그다음은 이 파일을 각각 컴파일 할 수 있어야 하는데… 이것은 생각보다 만만치가 않다. <code>cl.exe</code>를 실행해서 컴파일 하면 되지만, <code>cl.exe</code>의 커맨드라인 옵션으로 들어가야 하는 인자가 엄청나게 많고, 이 옵션을 vcxproj 파일에서 일일이 파싱하고 다시 조합하기란 상당히 귀찮고 짜증나는 작업이다. </p><p>이 귀찮은 작업을 MSBuild에 맡겨버릴 수 있다. MSBuild에 <code>/t:BuildCompile</code> 옵션과 <code>/p:SelectedFiles=xxx</code>을 쓰면 vcxproj를 알아서 파싱해서 cl.exe의 커맨드라인 인자를 직접 만들어준다. </p><p>이렇게 해서 일단 프로젝트 파일에 있는 cpp를 개별 컴파일 하는 것까지 성공.</p><img src="/devnote/images/140912_00.png" class="center"><p>여기까지 하고 나니 cpp 파일당 컴파일 시간까지 덤으로 얻게 됨.<br>앗싸.</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c++</category>
      
      
      <comments>http://leafbird.github.io/devnote/2014/09/12/claenup-cpp-project-1st/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Yoda Notation</title>
      <link>http://leafbird.github.io/devnote/2014/08/18/yoda-notation/</link>
      <guid>http://leafbird.github.io/devnote/2014/08/18/yoda-notation/</guid>
      <pubDate>Mon, 18 Aug 2014 23:08:44 GMT</pubDate>
      
      <description>&lt;img src=&quot;/devnote/images/yoda1.jpg&quot; class=&quot;center&quot;&gt;

&lt;p&gt;지난번에 &lt;a href=&quot;/devnote/2014/07/18/google-c-plus-plus-style-guide/&quot; title=&quot;google c++ style guide&quot;&gt;google c++ style guide&lt;/a&gt; 에 대해서 한참 수다를 떨었는데,&lt;br&gt;요즘에도 비슷한 주제의 책을 읽고 있습니다. 임백준씨가 번역하신 &lt;a href=&quot;http://www.yes24.com/24/goods/6692314?scode=032&amp;OzSrank=1&quot;&gt;‘읽기 좋은 코드가 좋은 코드다’&lt;/a&gt; 인데요,&lt;br&gt; 이것도 가볍게 읽을 수 있는 내용이어서 빌드 시간 중간에 띄엄띄엄 읽고 있어요.  &lt;/p&gt;
&lt;p&gt;이 책을 읽다가 ‘Yoda Notation’이란 표현을 처음 접했습니다. 표현이 재미있어서 블로그에 한 번 적어봅니다. 구글링해보면 &lt;a href=&quot;http://en.wikipedia.org/wiki/Yoda_conditions&quot;&gt;Yoda Conditions&lt;/a&gt; 라고도 부르는 것 같네요. 프로그램 코드 상에서 조건문에 값 비교 구문을 적을 때 변수와 상수의 위치를 바꾸어 적는 것을 말합니다. &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;May the force be with you.&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; val = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; == val) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// &amp;lt;- yoda notation here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<img src="/devnote/images/yoda1.jpg" class="center"><p>지난번에 <a href="/devnote/2014/07/18/google-c-plus-plus-style-guide/" title="google c++ style guide">google c++ style guide</a> 에 대해서 한참 수다를 떨었는데,<br>요즘에도 비슷한 주제의 책을 읽고 있습니다. 임백준씨가 번역하신 <a href="http://www.yes24.com/24/goods/6692314?scode=032&OzSrank=1">‘읽기 좋은 코드가 좋은 코드다’</a> 인데요,<br> 이것도 가볍게 읽을 수 있는 내용이어서 빌드 시간 중간에 띄엄띄엄 읽고 있어요.  </p><p>이 책을 읽다가 ‘Yoda Notation’이란 표현을 처음 접했습니다. 표현이 재미있어서 블로그에 한 번 적어봅니다. 구글링해보면 <a href="http://en.wikipedia.org/wiki/Yoda_conditions">Yoda Conditions</a> 라고도 부르는 것 같네요. 프로그램 코드 상에서 조건문에 값 비교 구문을 적을 때 변수와 상수의 위치를 바꾸어 적는 것을 말합니다. </p><figure class="highlight cpp"><figcaption><span>May the force be with you.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">20</span> == val) &#123; <span class="comment">// &lt;- yoda notation here.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <span id="more"></span><p>조건문을 <code>val == 20</code>으로 적는 것이 일반적인 언어 어순과 같아서 읽기가 좋지만<br>프로그래머의 실수로 <code>val = 20</code>과 같이 잘못된 코드가 만들어지고 컴파일 에러 없이 그대로 실행되는 것을 막기 위해서<br>일부러 변수와 상수의 위치를 서로 바꾸는 거죠. </p><p>요다는 영화 스타워즈에서 영문권 사람들도 이해하기 어려울 정도로 꼬인 문법의 말을 사용합니다. 이를 빗대어 위와 같은 조건문 표기 방식을 Yoda Notation이라고 부르는군요. 재미있는 네이밍입니다 :)</p><p>책에서는 요즘의 컴파일러들이 조건절 내에서의 할당에 대해 경고를 내주기 때문에, 요다 표기법은 ‘점차 불필요한 과거의 일이 되어가고 있다’ 고 말합니다.<br>저도 쉽게 읽히지 않는 이상한 순서 때문에 요다 표기법을 안 좋아하는데,<br>책에서도 저랑 같은 생각을 이야기 하고 있어서 반갑네요. 이 뿐만 아니라 이 책은 전반적으로 소스코드의 스타일에 대해 많은 부분 공감가는 방식들을 다수 소개하고 있습니다.</p><p>예전에 함께 작업했던 어떤 프로그래머분이, 제가 올린 코드를 리뷰하고 나서 제가 추가한 코드의 조건절을 모두 요다 표기법으로 바꾸었던 적이 있습니다. 그거 참… 별 거 아닌데 기분이 나쁘더군요. 그 뒤로 요다 표기법이 싫어졌는지도 모르겠습니다. 하지만 어쨌든 이젠 옛날 이야기가 되어가고 있는겁니다. Visual Studio 2012 기준으로 &#x2F;W4(경고 수준 4) 설정에 &#x2F;WX(경고를 오류로 처리) 설정을 더하면 <a href="http://msdn.microsoft.com/ko-kr/library/7hw7c1he.aspx">C4706 경고</a>의 발생으로 인해 컴파일 시점에서 코딩 실수를 미리 잡아낼 수 있습니다. </p><p>에, 그러니까 내가 하고 싶었던 말은, <strong>이제 이런 거 필요 없다</strong> 이겁니다 :)</p>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/coding-convention/">coding convention</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/c/">c++</category>
      
      
      <comments>http://leafbird.github.io/devnote/2014/08/18/yoda-notation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Octopress Tips on windows</title>
      <link>http://leafbird.github.io/devnote/2014/07/20/octopress-tips-on-windows/</link>
      <guid>http://leafbird.github.io/devnote/2014/07/20/octopress-tips-on-windows/</guid>
      <pubDate>Sun, 20 Jul 2014 22:44:48 GMT</pubDate>
      
      <description>&lt;p&gt;개인적으로 Octopress를 윈도우에서 사용하도록 구성하면서 도움이 되었던 팁들을 몇가지 정리해 보려고 합니다.&lt;br&gt;앞으로 계속 사용해 가면서 추가적인 팁이 생길 때에도 이 포스팅에 업데이트 할 생각이예요. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>개인적으로 Octopress를 윈도우에서 사용하도록 구성하면서 도움이 되었던 팁들을 몇가지 정리해 보려고 합니다.<br>앞으로 계속 사용해 가면서 추가적인 팁이 생길 때에도 이 포스팅에 업데이트 할 생각이예요. </p><span id="more"></span><h2 id="윈도우-실행-Windows-R-창에서-블로그-패스로-바로-이동-하기"><a href="#윈도우-실행-Windows-R-창에서-블로그-패스로-바로-이동-하기" class="headerlink" title="윈도우 실행 (Windows + R) 창에서 블로그 패스로 바로 이동 하기"></a>윈도우 실행 (Windows + R) 창에서 블로그 패스로 바로 이동 하기</h2><img src="/devnote/images/140721_00.png" class="center"><p>이거야 뭐… 환경변수에 블로그 경로를 넣어주면 된다. 이렇게 하면 실행 창에 <code>%변수이름%</code>만 입력하면 바로 탐색기를 열 수 있다.<br>환경 변수 설정을 해주는 PowerShell 스크립트를 만들어서 블로그 폴더의 루트에 놔두면 경로를 옮기거나 depot을 새로 받아도 편하게 셋팅할 수 있다. </p><figure class="highlight powershell"><figcaption><span>ps_register_path.ps1</span><a href="https://github.com/leafbird/devnote/blob/master/ps_register_path.ps1">code from github</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 현재 스크립트의 실행 경로를 얻는다.</span></span><br><span class="line"><span class="variable">$blog_path</span> = (<span class="built_in">Get-Item</span> <span class="literal">-Path</span> <span class="string">&quot;.\&quot;</span> <span class="literal">-Verbose</span>).FullName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 경로 확인</span></span><br><span class="line"><span class="string">&quot;blog path : <span class="variable">$blog_path</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행 경로를 환경변수에 등록(유저 레벨)</span></span><br><span class="line">[<span class="type">Environment</span>]::SetEnvironmentVariable(<span class="string">&quot;blogpath&quot;</span>, <span class="variable">$blog_path</span>, <span class="string">&quot;User&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output result</span></span><br><span class="line"><span class="string">&quot;Environment Variable update. &#123;0&#125; = &#123;1&#125;&quot;</span> <span class="operator">-f</span> <span class="string">&quot;blogpath&quot;</span>, <span class="variable">$blog_path</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pause</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Press any key to continue ...&quot;</span></span><br><span class="line"><span class="variable">$x</span> = <span class="variable">$host</span>.UI.RawUI.ReadKey(<span class="string">&quot;NoEcho,IncludeKeyDown&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="blogpath-이외에-자주-접근하는-경로는-바로가기를-만든다"><a href="#blogpath-이외에-자주-접근하는-경로는-바로가기를-만든다" class="headerlink" title="%blogpath% 이외에 자주 접근하는 경로는 바로가기를 만든다"></a>%blogpath% 이외에 자주 접근하는 경로는 바로가기를 만든다</h2><img src="/devnote/images/140721_01.PNG" class="center"><p>octopress를 쓰면서 커맨드를 실행하는 주된 경로는 root path다. 이외에도 첨부파일 경로나 글 본문을 저장하는 <code>./source/_posts</code> 등이 흔히 쓰이는데, 이런 경로에 대한 .lnk 파일을 만들어두면 훨씬 편하다.<br>위 스샷처럼 바로가기를 만들어두고 <code>po</code>정도 타이핑하고 엔터하면 <code>./source/_posts</code>로 이동한다.</p><p>나는 탐색기를 주로 이용하고자 이렇게 했지만 cmd창에서 바로가기 하고 싶다면 symbolic link를 만들면 될거다. </p><p>웹페이지 바로가기도 만들어 두면 편하게 이동 가능. (웹 바로가기는 .url 확장자. 브라우저 주소창에서 슥 끌어다 놓으면 생김)</p><h2 id="자주-쓰는-동작들은-스크립트로-자동화한다"><a href="#자주-쓰는-동작들은-스크립트로-자동화한다" class="headerlink" title="자주 쓰는 동작들은 스크립트로 자동화한다"></a>자주 쓰는 동작들은 스크립트로 자동화한다</h2><img src="/devnote/images/140721_02.PNG" class="center"><p><strong>Note : 이 항목이 이 포스팅의 핵심 입니다.</strong></p><p>Octopress를 쓰면서 마음에 드는 점 중에 하나인데, 마음만 먹으면 조작 과정을 내맘대로 스크립팅할 수 있다는 점이다.<br>처음 octopress를 이용하려면 갖가지 명령어들을 일일이 숙지하고 사용하기가 불편한 것이 사실이지만,<br>batch파일과 PowerShell을 통해서 얼마든지 내 입맛대로 자동화 할 수 있다.<br>PowerShell을 한 번 다뤄보고 싶었지만 딱히 기회가 없었는데 이참에 다뤄보게 되어 재미있었다.<br>지금은 몇 개 안되긴 하지만 개인적으로 만들어 사용중인 스크립트들은 <a href="http://github.com/leafbird/devnote/">http://github.com/leafbird/devnote/</a> 에서 확인할 수 있다. </p><p>예제로 한 가지만 살펴보자.</p><h3 id="자동화-예시-새글-작성을-간편하게"><a href="#자동화-예시-새글-작성을-간편하게" class="headerlink" title="자동화 예시 : 새글 작성을 간편하게"></a>자동화 예시 : 새글 작성을 간편하게</h3><p>ocotpress에서 새 글을 적으려면 아래의 순서대로 실행해야 한다. </p><ol><li>blog path로 이동.</li><li>cmd창 오픈</li><li><code>rake new_post[&#39;포스팅 제목&#39;]</code> 명령 실행</li><li><code>./source/_posts</code>로 이동</li><li>자동으로 생성된 .markdown 파일을 찾아서 오픈</li><li>글 작성 시작</li></ol><p>이 절차를 아래처럼 PowerShell로 스크립팅한다.</p><figure class="highlight powershell"><figcaption><span>ps_rake_new_post.ps1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 환경변수 BLOG_PATH에 설정된 블로그 root 경로로 이동</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$env:blogpath</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#input으로 새 글의 제목을 받는다. </span></span><br><span class="line"><span class="variable">$title</span> = <span class="built_in">Read-Host</span> <span class="string">&#x27;Enter Title&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행 : rake new_post[&#x27;제목&#x27;]</span></span><br><span class="line"><span class="variable">$argument</span> = [<span class="built_in">string</span>]::Format(<span class="string">&quot;new_post[&#123;0&#125;]&quot;</span>, <span class="variable">$title</span>)</span><br><span class="line"><span class="variable">$out</span> = rake.bat <span class="variable">$argument</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 생성된 파일의 이름과 경로를 추출한다.</span></span><br><span class="line"><span class="variable">$out</span> = <span class="variable">$out</span>.Replace(<span class="string">&quot;Creating new post: &quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 생성된 파일을 gvim으로 오픈!</span></span><br><span class="line"><span class="variable">$new_file_path</span> = [<span class="type">System.IO.Path</span>]::Combine(<span class="variable">$PSScriptRoot</span>, <span class="variable">$out</span>)</span><br><span class="line">gvim.exe <span class="variable">$new_file_path</span></span><br></pre></td></tr></table></figure><p>커맨드 창에 <code>PowerShell ./ps_rake_new_post.ps1</code> 입력하는 것도 귀찮으니 이것도 batch파일로 만들자.</p><figure class="highlight bat"><figcaption><span>02_ps_rake_new_post.bat</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">powershell ./ps_rake_new_post.ps1</span><br></pre></td></tr></table></figure><p>이제 이 batch를 실행해서 새 글 제목을 입력하면 에디터까지 자동으로 열린다. </p><h2 id="git-conflict-여러-머신에서-하나의-블로그에-번갈아-포스팅-하는-경우"><a href="#git-conflict-여러-머신에서-하나의-블로그에-번갈아-포스팅-하는-경우" class="headerlink" title="git conflict : 여러 머신에서 하나의 블로그에 번갈아 포스팅 하는 경우"></a>git conflict : 여러 머신에서 하나의 블로그에 번갈아 포스팅 하는 경우</h2><p>git을 사용할 때 불편한 점 중의 하나가 머지(merge)다. 여러 머신을 사용할 경우엔 다른 곳에서 수정했던 사항을 미리 pull 받고 난 후 작업해야 하는데, 이걸 혹시나 깜박 잊고 새 글을 써서 generate했다면 conflict 대 참사가 일어난다. </p><p>blog root경로는 보통의 git repository를 사용하는 것과 유사하기 때문에 큰 문제가 없는데 <code>_deploy</code>폴더가 문제다. 이 폴더는 블로그 엔진이 generate한 블로그 리소스를 배포하기 위해 사용하는데, 실제로는 <code>gh-pages</code> 브랜치의 clone이기 때문이다. 그래서 서로 다른 여러 개의 depot clone을 가지고 블로깅을 할 땐 blog root와 함께 <code>_deploy</code>도 함께 <code>git pull</code> 해주어야 문제가 없다. </p><p>하지만 <code>_deploy</code>폴더는 굳이 동기화까지 받을 필요는 없다. 어차피 블로그 엔진이 배포하는 과정에서 새로 만들기 때문이다.<br>어떻게 활용하든 상관없지만 만약 <code>_deploy</code>폴더가 충돌이나서 html파일을 한땀 한땀 머지해야 하는 상황이 되었다면 주저없이 삭제해 버리고 새로 만들자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd %blogpath%</span><br><span class="line">rmdir /s /q _deploy</span><br><span class="line">mkdir _deploy</span><br><span class="line">cd _deploy</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://....</span><br><span class="line">git pull</span><br><span class="line">git check --track origin/gh-pages</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://leafbird.github.io/devnote/tags/octopress/">octopress</category>
      
      <category domain="http://leafbird.github.io/devnote/tags/windows/">windows</category>
      
      
      <comments>http://leafbird.github.io/devnote/2014/07/20/octopress-tips-on-windows/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
